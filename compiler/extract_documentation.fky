#!/usr/bin/env fkyrun

  Copyright (C) 2023 by
  Dipl.-Ing. Michael Niederle

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License, version 2, or
  (at your option) version 3.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  For details of the GNU General Public License see the accompanying
  files GPLv2.txt and GLPv3.txt or
  http://www.gnu.org/licenses/gpl-2.0.html
  http://www.gnu.org/licenses/gpl-3.0.html
  or write to the
  Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

# Funky is a one based language

<require basic/stdlib>
<require basic/export/html>

<using std>
<using html>

<allow unused>

# Kinds

$TOPIC .
$TYPE .
$POLYMORPHIC_FUNCTION .
$POLYMORPHIC_FUNCTION_WITH_SETTER .
$ATTRIBUTE .
$OBJECT .
$DERIVED .
$FUNCTION .
$TYPE_FUNCTION .
$LITERAL .
$UNIQUE .
$METHOD .
$UNIQUE_ITEM .

program_parameters!
  list
    COPYRIGHT "
      Copyright (C) 2023 by
      Dipl.-Ing. Michael Niederle

      This program is free software; you can redistribute it and/or modify
      it under the terms of the GNU General Public License, version 2, or
      (at your option) version 3.

      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      GNU General Public License for more details.

      For details of the GNU General Public License see the accompanying
      files GPLv2.txt and GLPv3.txt or
      http://www.gnu.org/licenses/gpl-2.0.html
      http://www.gnu.org/licenses/gpl-3.0.html
      or write to the
      Free Software Foundation, Inc.,
      51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  $libraries
  list
    MANY_PARAMETERS "libraries" "
      one or more libraries from which to extract documentation
  $be_verbose
  list
    "verbose" "
      output detailed information about the build process

$topics empty_key_order_table
  #
    key: topic name
    value:
      tuple:
	kind
	undefined
	undefined
	undefined
	list of paragraphs
	filename

$definitions empty_hash_table
  #
    key: name of defined entity
    value:
      tuple:
	kind
	short description
	list of parameters
	list of results
	list of paragraphs
	filename

$kind_of_definition
  hash_table
    "TYPE" = TYPE
    "FUNCTION" = FUNCTION
    "METHOD" = METHOD
    "OBJECT" = OBJECT
    "UNIQUE" = UNIQUE_ITEM
    "POLY" = POLYMORPHIC_FUNCTION
    "ATTR" = ATTRIBUTE

$is_a_private_namespace
  hash_set
    "basic_collections"

$current_filename undefined

for_each libraries
  : (library)
    traverse_files! library !topics !definitions
    next!
  :
    for_each topics
      : (topic info)
	save! "html/@(topic.to_filename)" create_html_page(topic info)
	next!
      :
	for_each definitions
	  : (definition info)
	    save! "html/@(definition.to_filename)"
	      create_html_page(definition info)
	    next!
	  :
	    save! "html/style.css" style

$traverse_files: (library)
  directory! $entries library
  for_each entries
    : (entry)
      $name std::name_of(entry)
      case type_of(entry)
	DIRECTORY:
	  if
	    name .has_prefix. '.'
	    next
	    :
	      traverse_files! append(library "/" name) !topics !definitions
	      next!
	REGULAR_FILE:
	  cond
	    -> name .has_suffix. ".fky":
	      extract_from_funky! append(library "/" name) !topics !definitions
	      next!
	    -> name .has_suffix. ".template":
	      extract_from_template! append(library "/" name) !definitions
	      next!
	    -> true
	      next
	next
    -> topics definitions

$extract_from_funky: (filename)
  on be_verbose: println! filename
  !current_filename filename
  load_groups! $groups filename
  handle_groups groups

$extract_from_template: (filename)
  on be_verbose: println! filename
  !current_filename filename
  load_groups! $groups filename
  handle_template_groups groups

$handle_groups: (groups)
  for_each groups
    : (group)
      if
	group.is_undefined
	next
	:
	  group $indent $text
	  if
	    indent != 0
	    next
	    :
	      cond
		-> text(1) == '#' && is_a_topic(group):
		  handle_topic group !topics
		  next
		-> is_a_namespaced_definition(text):
		  handle_definition group !definitions
		  next
		-> true next
    -> topics definitions

$is_a_topic: (group)
  $subgroups subgroups_of(group)
  if
    subgroups.is_undefined
    -> false
    :
      $head subgroups(1)
      if
	head.is_undefined
	-> false
	:
	  head $_indent $text
	  -> text .has_prefix. "Topic:" || text .has_prefix. "Topics:"

$GLOBAL_DEFINITION '$', FUNKY_IDENTIFIER, "::", FUNKY_IDENTIFIER

$is_a_namespaced_definition: (text)
  -> match(GLOBAL_DEFINITION text).is_defined

$handle_template_groups: (groups)
  for_each groups
    : (group)
      group $_indent $text
      $keyword text .truncate_from. ' '
      update_if keyword == "PUBLIC" &keyword
	-> (text .behind. ' ') .truncate_from. ' '
      $kind kind_of_definition(keyword)
      if
	kind.is_undefined
	next
	:
	  behind &text keyword
	  trim &text
	  case kind
	    FUNCTION:
	      if
		text .contains. ' '
		next
		: add_definition text
	    METHOD:
	      if
		text .contains. "/_"
		next
		: add_definition text
	    TYPE:
	      $name (text .truncate_from. ' ')
	      $base (text .behind. "->").trim
	      update_if base.is_empty &base -> undefined
	      add_definition name base
	    next

      $add_definition: (name extra_info = undefined)
	maybe_add_namespace &name
	$subgroups subgroups_of(group)
	if
	  subgroups.is_undefined || subgroups(1).is_undefined
	  next
	  :
	    split_into_groups &subgroups
	    !subgroups subgroups_of(subgroups(1))
	    if
	      subgroups.is_defined:
		!definitions(name) collect_info(kind extra_info subgroups)
		next
	      next
    -> definitions

$handle_topic: (group)
  $subgroups subgroups_of(group)
  $head subgroups(1)
  head $_indent $text
  $topic trim(text .behind. ':')
  -> topics(topic collect_info(TOPIC range(subgroups 2 -1)))

$handle_definition: (group)
  group $_indent $text
  $namespace between(text '$' "::")
  $rest behind(text "::")
  $id_len match(FUNKY_IDENTIFIER rest)
  $name range(rest 1 id_len)
  range &rest id_len+1 -1
  $identifier append(namespace "::" name)
  if
    rest.is_empty:
      debug_write "
	@(namespace)::@(name) ???
      -> definitions
    :
      case rest(1)
	' ':
	  trim_left &rest
	  case rest(1)
	    '.': handle UNIQUE_ITEM
	    '(':
	      cond
		-> rest .has_prefix. "()": handle POLYMORPHIC_FUNCTION
		-> rest .has_prefix. "(!)": handle POLYMORPHIC_FUNCTION_WITH_SETTER
		-> true: handle undefined
	    '@apos;': handle LITERAL
	    '@quot;': handle LITERAL
	    '0'..'9': handle LITERAL
	    :
	      $derived_len match(FUNKY_IDENTIFIER rest)
	      if
		derived_len.is_defined: handle DERIVED
		: handle undefined
	':': handle FUNCTION
	'/':
	  if
	    rest(2) == ':':
	      handle TYPE_FUNCTION
	    :
	      handle_slot_definition METHOD
	'.': handle_slot_definition ATTRIBUTE
	: handle undefined

  $handle_slot_definition: (kind)
    $separator range(rest 1 1)
    range &rest 2 -1
    $slot_len match(FUNKY_IDENTIFIER rest)
    if
      slot_len.is_undefined:
	handle undefined
      :
	$slot_name range(rest 1 slot_len)
	range &rest slot_len+1 -1
	if
	  rest .has_prefix. "::":
	    range &rest 3 -1
	    $slot_name_len match(FUNKY_IDENTIFIER rest)
	    if
	      slot_name_len.is_undefined:
		handle undefined
	      :
		$real_slot_name range(rest 1 slot_name_len)
		append &identifier separator slot_name "::" real_slot_name
		handle kind
	  :
	    append &identifier separator "std::" slot_name
	    handle kind

  $handle: (kind)
    cond
      -> (identifier .before. "::").is_a_private_namespace
	-> definitions
      -> kind.is_undefined:
	edump `identifier
	debug_write "
	  CANNOT DETERMINE TYPE: @(identifier)
	-> definitions
      -> true:
	$subgroups subgroups_of(group)
	if
	  subgroups.is_undefined
	  missing_documentation
	  :
	    split_into_groups &subgroups
	    $description find_first(subgroups is_a_remark)
	    if
	      description.is_undefined
	      missing_documentation
	      :
		$descriptions subgroups_of(description)
		if
		  descriptions.is_undefined
		  missing_documentation
		  :
		    if
		      ||
			kind == FUNCTION
			kind == METHOD
			kind == TYPE_FUNCTION
		      :
			$parameters find_first(subgroups is_a_parameter_list)
			update_if parameters.is_defined &parameters
			  -> split_into_groups(subgroups_of(parameters))
			->
			  definitions
			    identifier
			    collect_info(kind parameters descriptions)
		      -> definitions(identifier collect_info(kind descriptions))

  $missing_documentation:
    #debug_write "
      MISSING DOCUMENTATION: @(identifier)
    -> definitions

$is_a_remark: (line) -> line.is_defined && second(line)(1) == '#'

$is_a_parameter_list: (line) -> line.is_defined && second(line)(1) == '('

$PARAMETER .
$RESULT .

$collect_info:
  (
    kind
    extra_info = undefined # parameters, derived or value
    description_groups
  )
  $paragraph ""
  $paragraphs empty_list
  $is_preformatted false
  $base_indent undefined
  $parameters
    case
      kind
      sequence
	FUNCTION
	METHOD
	TYPE_FUNCTION
	POLYMORPHIC_FUNCTION
	POLYMORPHIC_FUNCTION_WITH_SETTER
      :
	!parameters empty_list
	if
	  extra_info.is_defined:
	    for_each extra_info
	      : (group)
		add_result_or_parameter &parameters group
		next
	      -> parameters
	  -> parameters
      -> undefined
  $results
    case
      kind
      FUNCTION, METHOD, TYPE_FUNCTION
      -> empty_list
      -> undefined

  $mode undefined
  for_each description_groups
    : (group)
      if
	group.is_undefined:
	  !mode undefined
	  if
	    paragraph.is_empty
	    next
	    :
	      push &paragraphs paragraph
	      !paragraph ""
	      next
	:
	  cond
	    -> mode == PARAMETER:
	      add_result_or_parameter &parameters group
	      next
	    -> mode == RESULT:
	      add_result_or_parameter &results group
	      next
	    -> true:
	      group $indent $text
	      if !is_preformatted !base_indent
		is_preformatted:
		  if
		    base_indent.is_undefined
		    -> true indent
		    :
		      if
			indent < base_indent
			-> false undefined
			-> true base_indent
		-> false undefined
	      range &text 1 -2 # remove trailing newline
	      update_if is_preformatted &text:
		append spaces(indent-base_indent) replace_all(text '<' = "&lt;")
	      if
		paragraph.is_empty:
		  cond
		    ->
		      ||
			text .has_prefix. "Parameter:"
			text .has_prefix. "Parameters:"
		      :
			!mode PARAMETER
			next
		    ->
		      ||
			text .has_prefix. "Result:"
			text .has_prefix. "Results:"
		      :
			!mode RESULT
			next
		    -> true:
		      !paragraph text
		      if
			||
			  text .has_prefix. "Example:"
			  text .has_prefix. "Output:"
			:
			  !is_preformatted true
			  next
			next
		:
		  push &paragraph
		    if
		      is_preformatted
		      -> '@nl;'
		      -> ' '
		  append &paragraph text
		  next
    :
      update_if paragraph.is_not_empty &paragraphs -> push(paragraphs paragraph)
      if
	kind == TOPIC
	-> tuple(kind undefined undefined undefined paragraphs current_filename)
	->
	  tuple
	    kind
	    paragraphs(1)
	    if
	      parameters.is_defined
	      -> parameters
	      -> extra_info
	    results
	    range(paragraphs 2 -1)
	    current_filename

$add_result_or_parameter: (parameters group)
  $text second(group)
  $parameter (text .truncate_from. '#').trim
  $subgroups subgroups_of(group)
  update_if subgroups.is_defined &text -> second(subgroups(1))
  $remark (text .behind. '#').trim
  push parameters tuple(parameter remark)

$create_html_page: (title info)
  info $kind $short_descripition $extra_info $results $paragraphs $filename
  $parameters
    case
      kind
      sequence
	FUNCTION
	METHOD
	TYPE_FUNCTION
	POLYMORPHIC_FUNCTION
	POLYMORPHIC_FUNCTION_WITH_SETTER
      -> extra_info
      -> undefined
  HTML
    : HEAD
      : TITLE title
      : LINK "rel" = "stylesheet" "href" = "style.css"
    : BODY
      : P
	: A "class" = "Button" "href" = "index.html" "Home"
	: A "class" = "Button" "href" = "manual.html" "Manual"
	: A "class" = "Button" "href" = "topics_index.html" "Topics"
	: A "class" = "Button" "href" = "type_index.html" "Type Index"
	: A "class" = "Button" "href" = "symbol_index.html" "Symbol Index"
      : if
	  kind == TOPIC:
	    H1 title
	  :
	    H1 "class" = "pre" title
      :
	$description empty_list
	$associated_topics empty_list
	$preformatted empty_list
	$see_also empty_list
	$already_consumed false
	for_each paragraphs
	  : (idx paragraph)
	    cond
	      ->
		||
		  paragraph .has_prefix. "Topic:"
		  paragraph .has_prefix. "Topics:"
		:
		  !associated_topics map(split(paragraph .behind. ':' ',') trim)
		  next
	      -> paragraph .has_prefix. "See also:":
		!see_also
		  map
		    split(paragraph .behind. ':' ','): (item)
		      maybe_add_namespace item.trim
		next
	      -> paragraph .has_prefix. "Example:":
		push &preformatted "Example" = paragraphs(idx+1)
		!already_consumed true
		next
	      -> paragraph .has_prefix. "Output:":
		push &preformatted "Output" = paragraphs(idx+1)
		!already_consumed true
		next
	      -> true:
		if
		  already_consumed:
		    !already_consumed false
		    next
		  :
		    push &description paragraph
		    next
	  :
	    GROUP
	      : if
		  short_descripition.is_undefined
		  -> ""
		  : P "class" = "short" short_descripition
	      :
		if
		  parameters.is_undefined
		  -> ""
		  : GROUP
		    : H2
		      if
			length_of(parameters) == 1
			-> "Parameter"
			-> "Parameters"
		    :
		      if
			parameters.is_empty:
			  P: I "None"
			: DL
			  :
			    FOR_EACH parameters: (parameter)
			      parameter $parameter_name $parameter_description
			      GROUP
				: DT parameter_name
				: DD parameter_description
	      :
		if
		  results.is_undefined
		  -> ""
		  : GROUP
		    : H2
		      if
			length_of(results) == 1
			-> "Result"
			-> "Results"
		    :
		      if
			results.is_empty:
			  P: I "None"
			: DL
			  :
			    FOR_EACH results: (result)
			      result $result_name $result_description
			      GROUP
				: DT result_name
				: DD result_description
	      :
		if
		  description.is_empty
		  -> ""
		  : GROUP
		    : H2 "Description"
		    : FOR_EACH description: (paragraph) P convert(paragraph)
	      :
		map_reduce
		  preformatted
		  : (info)
		    info $class $paragraph
		    GROUP
		      : H2 class
		      : DIV "class" = class paragraph
		  append
		  ""
	      :
		if
		  associated_topics.is_empty
		  -> ""
		  : GROUP
		    : H2
		      if
			length_of(associated_topics) == 1
			-> "Topic"
			-> "Topics"
		    : P
		      : FOR_EACH associated_topics: (item)
			P: A "href" = to_filename(item) item
	      :
		if
		  kind == TYPE && extra_info.is_defined:
		    GROUP
		      : H2 "Derived from"
		      : TABLE: link_to extra_info
		  -> ""
	      :
		if
		  see_also.is_empty
		  -> ""
		  : GROUP
		    : H2 "See also"
		    : TABLE
		      :
			FOR_EACH see_also: (item)
			  link_to item
	      :
		case kind
		  TOPIC:
		    $names empty_list
		    for_each definitions
		      : (name definition)
			definition
			  $_kind $_short_descripition $_parameters $_results
			  $definition_paragraphs
			for_each definition_paragraphs
			  : (paragraph)
			    if
			      ||
				paragraph .has_prefix. "Topic:"
				paragraph .has_prefix. "Topics:"
			      :
				if
				  paragraph .contains. title:
				    push &names name
				    next
				  next
			      next
		      :
			sort &names
			GROUP
			  : TABLE:
			    FOR_EACH names: (name)
			      link_to name
		  TYPE:
		    $names empty_list
		    for_each definitions
		      : (name definition)
			if
			  (name .before. '/') == title:
			    push &names name
			    next
			  next
		      :
			if
			  names.is_empty
			  -> ""
			  :
			    sort &names
			    GROUP
			      : H2 "Supported polymorphic functions"
			      : TABLE:
				FOR_EACH names: (name)
				  link_to name
		  -> ""
	      : DIV "class" = "footer" "(defined in @(filename))"

$link_to: (item)
  TR
    : TD : A "href" = to_filename(item) item .truncate_until. '/'
    :
      $item_definition definitions(item)
      if
	item_definition.is_undefined
	-> ""
	:
	  item_definition $_item_kind $item_description
	  TD "class" = "description": I item_description

$maybe_add_namespace: (name)
  if
    name(1) == '@@'
    -> range(name 2 -1)
    :
      cond
	-> name .contains. '.':
	  append
	    handle(name .before. '.' "std_types")
	    "."
	    handle(name .behind. '.')
	-> name .contains. '/':
	  append
	    handle(name .before. '/' "std_types")
	    "/"
	    handle(name .behind. '/')
	-> true:
	  handle name

      $handle: (part default_namespace = "std")
	if
	  part .contains. "::"
	  -> part
	  -> "@(default_namespace)::@(part)"

$convert: (text)
  $buf ""
  if
    text .has_prefix. "* "
    insert_list_item
    convert_rest

  $insert_list_item:
    !buf "<li>"
    range &text 3 -1
    convert_rest

  $convert_rest:
    $i 0
    $n length_of(text)
    $s 1
    $within_italics false
    $within_bold false
    $within_link false
    loop:
      inc &i
      if
	i > n
	-> append(buf range(text s n))
	:
	  case text(i)
	    '*':
	      if
		i < n && text(i+1) == '*':
		  if
		    within_bold:
		      append &buf range(text s i-1)
		      append &buf "</b>"
		      inc &i
		      !s i+1
		      !within_bold false
		      next
		    :
		      append &buf range(text s i-1)
		      append &buf "<b>"
		      inc &i
		      !s i+1
		      !within_bold true
		      next
		:
		  if
		    within_italics:
		      append &buf range(text s i-1)
		      append &buf "</i>"
		      !s i+1
		      !within_italics false
		      next
		    :
		      append &buf range(text s i-1)
		      append &buf "<i>"
		      !within_italics true
		      !s i+1
		      next
	    '<':
	      append &buf range(text s i-1)
	      !within_link true
	      !s i+1
	      next
	    '>':
	      if
		within_link:
		  $link range(text s i-1)
		  maybe_add_namespace &link
		  append &buf "
		    <a href="@(link.to_filename)">@(link)</a>@
		  !within_link false
		  !s i+1
		  next
		next
	    next

$load_groups: (filename)
  load! $source filename
  cond
    -> source.is_empty:
      Error! "
	Empty source file "@(filename)"!@
    -> source(-1) != '@nl;':
      Error! "
	Missing trailing newline character in "@(filename)"!@
  from_utf8 &source
  split_into_indented_lines $lines source
  split_into_groups lines

$to_filename: (name)
  to_lower_case &name
  replace_all &name
    ' ' = "_"
    "::" = "__"
    '.' = "___"
    '/' = "___"
  -> "@(name).html"

$style "
  body {
    font-family: Arial, Helvetica;;
    font-size: 12pt;
    color: #222;
    background-color: white;
  }
  h1 {
    font-family: Arial, Helvetica;
    font-size: 20pt;
    color: #333;
    margin-top: 0pt;
    margin-bottom: 8pt;
  }
  h2 {
    font-family: Arial, Helvetica;
    font-size: 16pt;
    color: #222;
    margin-top: 6pt;
    margin-bottom: 7pt;
  }
  h1.pre {
    font-family: Courier New, Courier; Typewriter;
    font-size: 22pt;
    color: black;
    margin-top: 5pt;
    margin-bottom: 11pt;
  }
  dt {
    font-style: italic;
    margin-bottom: 2pt;
  }
  dd {
    padding-left: 0pt;
    margin-left: 16pt;
    margin-top: 0pt;
    margin-bottom: 4pt;
  }
  p {
    margin-top: 0pt;
    margin-bottom: 8pt;
  }
  p.short {
    font-style: italic;
    font-size: 14pt;
  }
  a {
    font-family: Times New Roman, Times;
    font-size: 13pt;
    text-decoration: none;
  }
  i {
    font-family: Times New Roman, Times;
    font-size: 14pt;
  }
  a.Button {
    display: inline-block;
    padding-top: 2pt;
    padding-bottom: 3pt;
    padding-left: 3pt;
    padding-right: 3pt;
    margin-right: 5pt;
    border-radius: 8pt;
    border-width: 2pt;
    border-style: solid;
  }
  div.Example {
    font-family: Courier New, Courier, Typewriter;
    font-size: 13pt;
    background-color: #ffc;
    border: solid 1pt;
    margin-top: 6pt;
    margin-bottom: 8pt;
    padding: 2pt;
    white-space: pre;
    border-radius: 6pt;
  }
  div.Output {
    font-family: Courier New, Courier, Typewriter;
    font-size: 13pt;
    background-color: #cff;
    border: solid 1pt;
    margin-top: 6pt;
    margin-bottom: 8pt;
    padding: 2pt;
    white-space: pre;
    border-radius: 6pt;
  }
  div.footer {
    padding-top: 10pt;
    font-size: 10pt;
  }
  pre {
    font-family: Courier New, Courier, Typewriter;
    font-size: 13pt;
    padding-top: 0pt;
    padding-bottom: 0pt;
    margin-top: 2pt;
    margin-bottom: 2pt;
  }
  td.description {
    padding-left: 10pt;
  }

  @@media (prefers-color-scheme: dark) {
    body {
      color: #eee;
      background-color: #222;
    }
    h1 {
      color: #ddd;
    }
    h1.pre {
      color: white;
    }
    h2 {
      color: #ccc;
    }
    a {
      color: #aaf;
    }
    a:visited {
      color: #faf;
    }
    div.Example, div.Output {
      color: #222;
    }
  }
