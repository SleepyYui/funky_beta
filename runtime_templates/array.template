
#
  Copyright (C) 2024 by
  Dipl.-Ing. Michael Niederle

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License, version 2, or
  (at your option) version 3.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  For details of the GNU General Public License see the accompanying
  files GPLv2.txt and GLPv3.txt or
  http://www.gnu.org/licenses/gpl-2.0.html
  http://www.gnu.org/licenses/gpl-3.0.html
  or write to the
  Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

TYPE std_types::generic_array -> std_types::object
  #
    the prototype object for all kind of arrays

    Topic: Collections

    See also:

    std_types::array,
    std_types::boolean_array,
    std_types::character_array,
    std_types::int8_array,
    std_types::uint8_array,
    std_types::int16_array,
    std_types::uint16_array,
    std_types::int32_array,
    std_types::uint32_array,
    std_types::int64_array,
    std_types::uint64_array,
    std_types::float32_array,
    std_types::float64_array

METHOD std_types::generic_array/_type
  {
    RUNTIME_ERROR(
      "Attempt to call the generic array prototype object as a function!")
  }

RECORD ARRAY_INFO
  long dimension_count
  int dimensions[]

RECORD DIMENSION_INFO
  long first_index
  long width

RECORD ARRAY_VIEW
  long dimension_count
  DIMENSION_INFO dimensions[]

RECORD ARRAY_UPDATES
  long size
  long length
  char buffer[]

CODE
  static ARRAY_DATA *allocate_array_data
    (
      int dimension_count,
      int item_size
    )
    {
      ARRAY_INFO *info =
        allocate(
          ALLOCATION_SIZE(sizeof(ARRAY_INFO)+dimension_count*sizeof(int)));
      info->dimension_count = dimension_count;
      int i;
      for (i = 0; i < dimension_count; ++i) {
        int dimension;
        if (!to_int(ARGUMENTS(i), &dimension)) return NULL;
        if (dimension < 1) {
          invalid_arguments();
          return NULL;
        }
        info->dimensions[i] = dimension;
      }
      long size = info->dimensions[0];
      for (i = 1; i < dimension_count; ++i) {
        size *= info->dimensions[i];
      }
      ARRAY_DATA *data =
        allocate_large(ALLOCATION_SIZE(sizeof(ARRAY_DATA)+size*item_size));
      data->info = info;
      data->size = size;
      return data;
    }

  static ARRAY_DATA *new_array_data
    (
      ARRAY_INFO *info,
      int item_size
    )
    {
      int i;
      long size = info->dimensions[0];
      for (i = 1; i < info->dimension_count; ++i) {
        size *= info->dimensions[i];
      }
      ARRAY_DATA *data =
        allocate_large(ALLOCATION_SIZE(sizeof(ARRAY_DATA)+size*item_size));
      data->info = info;
      data->size = size;
      return data;
    }

  static ARRAY_VIEW *create_array_view
    (
      ARRAY_INFO *info
    )
    {
      ARRAY_VIEW *view =
        allocate(ALLOCATION_SIZE(
          sizeof(ARRAY_VIEW)+info->dimension_count*sizeof(DIMENSION_INFO)));
      view->dimension_count = info->dimension_count;
      int i;
      for (i = 0; i < info->dimension_count; ++i) {
        view->dimensions[i].first_index = 0;
        view->dimensions[i].width = info->dimensions[i];
      }
      return view;
    }

  static ARRAY_VIEW *create_sub_view
    (
      ARRAY_VIEW *view
    )
    {
      int dimension_count = view->dimension_count;
      ARRAY_VIEW *sub_view =
        allocate(ALLOCATION_SIZE(
          sizeof(ARRAY_VIEW)+dimension_count*sizeof(DIMENSION_INFO)));
      sub_view->dimension_count = dimension_count;
      int i;
      for (i = 0; i < dimension_count; ++i) {
        NODE *argument = ARGUMENTS(1+i);
        if (TYPEOF(argument) != TYPE(std_types::value_range)) {
          invalid_arguments();
          return NULL;
        }
        long first;
        long last;
        if (
          !to_long(argument->tuple2.node_0, &first) ||
          !to_long(argument->tuple2.node_1, &last)
        ) {
          invalid_arguments();
          return NULL;
        }
        if (first < 0) {
          first += view->dimensions[i].width;
        } else {
          --first;
        }

        if (last < 0) {
          last += view->dimensions[i].width;
        } else {
          --last;
        }
        if (
          first < 0 || first >= view->dimensions[i].width ||
          last < 0 || last >= view->dimensions[i].width ||
          first > last
        ) {
          invalid_arguments();
          return NULL;
        }
        sub_view->dimensions[i].first_index =
          view->dimensions[i].first_index+first;
        sub_view->dimensions[i].width = last-first+1;
      }
      return sub_view;
    }

  static void *add_update
    (
      ARRAY *node,
      long item_size
    )
    {
      long length = node->updates_length;
      ARRAY_UPDATES *updates = node->updates;
      if (length == 0) {
        long size = ALLOCATION_SIZE(item_size);
        updates = allocate_large(sizeof(ARRAY_UPDATES)+size);
        updates->size = size;
        updates->length = length+item_size;
      } else if (
        length != node->updates->length ||
        length+item_size > node->updates->size
      ) {
        long size = ALLOCATION_SIZE(sizeof(ARRAY_UPDATES)+2*length+item_size);
        updates = allocate_large(size);
        updates->size = size;
        memcpy(updates->buffer, node->updates->buffer, length);
      }
      updates->length = length+item_size;
      ARRAY *new_node = allocate(sizeof(ARRAY));
      new_node->type = node->type;
      new_node->attributes = node->attributes;
      new_node->updates_length = length+item_size;
      new_node->data = node->data;
      new_node->view = node->view;
      new_node->updates = updates;
      return new_node;
    }

  static long compute_array_offset
    (
      NODE *array,
      ARRAY_INFO *info,
      ARRAY_VIEW *view
    )
    {
      int i;
      long offset = 0;
      i = view->dimension_count-1;
      int idx;
      next:
      if (!to_int(ARGUMENTS(i), &idx)) return -1;
      if (idx < 0) {
        idx += view->dimensions[i].width;
      } else {
        --idx;
      }
      if (idx < 0 || idx >= view->dimensions[i].width) {
        invalid_index(array);
        return -1;
      }
      offset += view->dimensions[i].first_index+idx;
      if (--i < 0) return offset;
      offset *= info->dimensions[i];
      goto next;
    }

  static long array_debug_string
    (
      ARRAY_INFO *info,
      ARRAY_VIEW *view,
      int indent,
      char *buf,
      const char *typename
    )
    {
      char type[1024];
      char *p = type;
      print(&p, "<%s_array(", typename);
      int i;
      for (i = 0; i < view->dimension_count; ++i) {
        if (i) *p++ = ' ';
        print(&p,
          "%d..%d",
          view->dimensions[i].first_index+1,
          view->dimensions[i].first_index+view->dimensions[i].width
        );
      }
      *p++ = ')';
      *p++ = '>';
      *p = 0;
      return debug_print(indent, buf, type);
    }

  static int equal_array_type
    (
      NODE *left,
      NODE *right
    )
    {
      if (TYPEOF(left) != TYPEOF(right)) {
        error:
        invalid_arguments();
        return false;
      }
      ARRAY_INFO *left_info = left->array.data->info;
      ARRAY_INFO *right_info = right->array.data->info;
      if (left_info->dimension_count != right_info->dimension_count) goto error;
      int i;
      for (i = 0; i < left_info->dimension_count; ++i) {
        if (left_info->dimensions[i] != right_info->dimensions[i]) goto error;
      }
      return true;
    }

#######
# ARRAY OF OBJECTS
#

RECORD ARRAY_DATA
  ARRAY_INFO *info
  long size
  NODE *items[]

UNION UPDATE_ARRAY_DATA/SET_VALUE
  long offset
  NODE *value

TYPE std_types::array -> std_types::generic_array
  # an array of objects
  long updates_length
  ARRAY_DATA *data
  ARRAY_VIEW *view
  ARRAY_UPDATES *updates

CODE
  static ARRAY_DATA *apply_array_updates(ARRAY *node)
    {
      ARRAY_DATA *data = node->data;
      ARRAY_INFO *info = data->info;
      ARRAY_VIEW *view = node->view;
      long size = data->size;
      if (node->updates_length > 0) {
        // copy items
        data = allocate_large(
          ALLOCATION_SIZE(sizeof(ARRAY_DATA)+size*sizeof(NODE *)));
        memcpy(
          data->items,
          node->data->items,
          size*sizeof(NODE *));
        // apply updates
        char *update = node->updates->buffer;
        char *end_p = update+node->updates_length;
        while (update < end_p) {
          switch (*(TAG *)update) {
            case SET_VALUE:;
              UPDATE_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
              data->items[set_value->offset] = set_value->value;
              update += sizeof(UPDATE_ARRAY_DATA_SET_VALUE);
              break;
          }
        }
        data->info = info;
        data->size = size;
        node->updates_length = 0;
        node->data = data;
        node->view = view;
        node->updates = NULL;
      }
      return data;
    }

METHOD std_types::array/_type
  {
    ARRAY_DATA *data = MYSELF->array.data;
    ARRAY_INFO *info = data->info;
    ARRAY_VIEW *view = MYSELF->array.view;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, info, view);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_array_updates((ARRAY *)MYSELF);
      NODE *value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(value);
    } else {
      // set item
      NODE *value;
      value = ARGUMENTS(dimension_count);
      long length = MYSELF->array.updates_length;
      MYSELF =
        add_update(
          (ARRAY *)MYSELF, sizeof(UPDATE_ARRAY_DATA_SET_VALUE));
      UPDATE_ARRAY_DATA_SET_VALUE *update =
        (UPDATE_ARRAY_DATA_SET_VALUE *)
        (MYSELF->array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->array.data->info, node->array.view,
      indent, buf, "");
  }

METHOD std_types::array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
        invalid_dimension(ARGUMENTS(0));
        return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    ARRAY_DATA *data = ARGUMENTS(0)->array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

FUNCTION std::array
  #
    constructs an empty array

    See also: std_types::array/new, std::initialized_array
  {
    MIN_ARGUMENTS(1)
    ARRAY_DATA *data = (ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(NODE *));
    if (!data) return;
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = (NODE *)&std_types::undefined;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::array, 0, data, view, NULL))
  }

FUNCTION std::initialized_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::array, std_types::array/new
  {
    MIN_ARGUMENTS(2)
    ARRAY_DATA *data = (ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(NODE *));
    if (!data) return;
    NODE *initial_value;
    initial_value = ARGUMENTS(ARGUMENT_COUNT-1);
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::array, 0, data, view, NULL))
  }

METHOD std_types::array/new
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    ARRAY_DATA *data = (ARRAY_DATA *)
      new_array_data(ARGUMENTS(0)->array.data->info, sizeof(NODE *));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = (NODE *)&std_types::undefined;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::array, 0, data,
      ARGUMENTS(0)->array.view, NULL))
  }
METHOD std_types::array/range
  #
    creates a new array with the elements in the given ranges
  {
    ARRAY *array = (ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    ARRAY_DATA *data = apply_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::array, 0, data, view, NULL))
  }

#######
# ARRAY OF BOOLEAN VALUES
#

RECORD BOOLEAN_ARRAY_DATA
  ARRAY_INFO *info
  long size
  int items[]

UNION UPDATE_BOOLEAN_ARRAY_DATA/SET_VALUE
  long offset
  int value

TYPE std_types::boolean_array -> std_types::generic_array
  # an array of boolean values
  long updates_length
  BOOLEAN_ARRAY_DATA *data
  ARRAY_VIEW *view
  ARRAY_UPDATES *updates

CODE
  static BOOLEAN_ARRAY_DATA *apply_boolean_array_updates(BOOLEAN_ARRAY *node)
    {
      BOOLEAN_ARRAY_DATA *data = node->data;
      ARRAY_INFO *info = data->info;
      ARRAY_VIEW *view = node->view;
      long size = data->size;
      if (node->updates_length > 0) {
        // copy items
        data = allocate_large(
          ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
        memcpy(
          data->items,
          node->data->items,
          size*sizeof(int));
        // apply updates
        char *update = node->updates->buffer;
        char *end_p = update+node->updates_length;
        while (update < end_p) {
          switch (*(TAG *)update) {
            case SET_VALUE:;
              UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
              data->items[set_value->offset] = set_value->value;
              update += sizeof(UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE);
              break;
          }
        }
        data->info = info;
        data->size = size;
        node->updates_length = 0;
        node->data = data;
        node->view = view;
        node->updates = NULL;
      }
      return data;
    }

METHOD std_types::boolean_array/_type
  {
    BOOLEAN_ARRAY_DATA *data = MYSELF->boolean_array.data;
    ARRAY_INFO *info = data->info;
    ARRAY_VIEW *view = MYSELF->boolean_array.view;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, info, view);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_boolean_array_updates((BOOLEAN_ARRAY *)MYSELF);
      int value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_bool(value));
    } else {
      // set item
      int value;
      CHECK(to_bool(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->boolean_array.updates_length;
      MYSELF =
        add_update(
          (ARRAY *)MYSELF, sizeof(UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE));
      UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE *update =
        (UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE *)
        (MYSELF->boolean_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::boolean_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->boolean_array.data->info, node->boolean_array.view,
      indent, buf, "boolean");
  }

METHOD std_types::boolean_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->boolean_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
        invalid_dimension(ARGUMENTS(0));
        return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::boolean_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    BOOLEAN_ARRAY_DATA *data = ARGUMENTS(0)->boolean_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::boolean_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    BOOLEAN_ARRAY_DATA *left = apply_boolean_array_updates((BOOLEAN_ARRAY *)ARGUMENTS(0));
    BOOLEAN_ARRAY_DATA *right = apply_boolean_array_updates((BOOLEAN_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
        left->items, right->items,sizeof(int)*left->size) == 0)
  }
METHOD std_types::boolean_array/bit_and
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    BOOLEAN_ARRAY_DATA *left = apply_boolean_array_updates((BOOLEAN_ARRAY *)ARGUMENTS(0));
    BOOLEAN_ARRAY_DATA *right = apply_boolean_array_updates((BOOLEAN_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    BOOLEAN_ARRAY_DATA *data =
      allocate_large(
        ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0, data,
      ARGUMENTS(0)->boolean_array.view, NULL))
  }

METHOD std_types::boolean_array/bit_or
  #
    implements the *or* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    BOOLEAN_ARRAY_DATA *left = apply_boolean_array_updates((BOOLEAN_ARRAY *)ARGUMENTS(0));
    BOOLEAN_ARRAY_DATA *right = apply_boolean_array_updates((BOOLEAN_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    BOOLEAN_ARRAY_DATA *data =
      allocate_large(
        ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0, data,
      ARGUMENTS(0)->boolean_array.view, NULL))
  }

METHOD std_types::boolean_array/bit_xor
  #
    implements the *xor* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    BOOLEAN_ARRAY_DATA *left = apply_boolean_array_updates((BOOLEAN_ARRAY *)ARGUMENTS(0));
    BOOLEAN_ARRAY_DATA *right = apply_boolean_array_updates((BOOLEAN_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    BOOLEAN_ARRAY_DATA *data =
      allocate_large(
        ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0, data,
      ARGUMENTS(0)->boolean_array.view, NULL))
  }

FUNCTION std::boolean_array
  #
    constructs an empty array

    See also: std_types::boolean_array/new, std::initialized_boolean_array
  {
    MIN_ARGUMENTS(1)
    BOOLEAN_ARRAY_DATA *data = (BOOLEAN_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(int));
    if (!data) return;
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = false;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0, data, view, NULL))
  }

FUNCTION std::initialized_boolean_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::boolean_array, std_types::boolean_array/new
  {
    MIN_ARGUMENTS(2)
    BOOLEAN_ARRAY_DATA *data = (BOOLEAN_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(int));
    if (!data) return;
    int initial_value;
    CHECK(to_bool(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0, data, view, NULL))
  }

METHOD std_types::boolean_array/new
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    BOOLEAN_ARRAY_DATA *data = (BOOLEAN_ARRAY_DATA *)
      new_array_data(ARGUMENTS(0)->boolean_array.data->info, sizeof(int));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = false;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0, data,
      ARGUMENTS(0)->boolean_array.view, NULL))
  }
METHOD std_types::boolean_array/range
  #
    creates a new array with the elements in the given ranges
  {
    BOOLEAN_ARRAY *array = (BOOLEAN_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    BOOLEAN_ARRAY_DATA *data = apply_boolean_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0, data, view, NULL))
  }

#######
# ARRAY OF CHARACTERS
#

RECORD CHARACTER_ARRAY_DATA
  ARRAY_INFO *info
  long size
  uint32_t items[]

UNION UPDATE_CHARACTER_ARRAY_DATA/SET_VALUE
  long offset
  uint32_t value

TYPE std_types::character_array -> std_types::generic_array
  # an array of characters
  long updates_length
  CHARACTER_ARRAY_DATA *data
  ARRAY_VIEW *view
  ARRAY_UPDATES *updates

CODE
  static CHARACTER_ARRAY_DATA *apply_character_array_updates(CHARACTER_ARRAY *node)
    {
      CHARACTER_ARRAY_DATA *data = node->data;
      ARRAY_INFO *info = data->info;
      ARRAY_VIEW *view = node->view;
      long size = data->size;
      if (node->updates_length > 0) {
        // copy items
        data = allocate_large(
          ALLOCATION_SIZE(sizeof(CHARACTER_ARRAY_DATA)+size*sizeof(uint32_t)));
        memcpy(
          data->items,
          node->data->items,
          size*sizeof(uint32_t));
        // apply updates
        char *update = node->updates->buffer;
        char *end_p = update+node->updates_length;
        while (update < end_p) {
          switch (*(TAG *)update) {
            case SET_VALUE:;
              UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
              data->items[set_value->offset] = set_value->value;
              update += sizeof(UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE);
              break;
          }
        }
        data->info = info;
        data->size = size;
        node->updates_length = 0;
        node->data = data;
        node->view = view;
        node->updates = NULL;
      }
      return data;
    }

METHOD std_types::character_array/_type
  {
    CHARACTER_ARRAY_DATA *data = MYSELF->character_array.data;
    ARRAY_INFO *info = data->info;
    ARRAY_VIEW *view = MYSELF->character_array.view;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, info, view);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_character_array_updates((CHARACTER_ARRAY *)MYSELF);
      uint32_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_uchar32(value));
    } else {
      // set item
      uint32_t value;
      CHECK(to_uchar32(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->character_array.updates_length;
      MYSELF =
        add_update(
          (ARRAY *)MYSELF, sizeof(UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE));
      UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE *update =
        (UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE *)
        (MYSELF->character_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::character_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->character_array.data->info, node->character_array.view,
      indent, buf, "uchar32");
  }

METHOD std_types::character_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->character_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
        invalid_dimension(ARGUMENTS(0));
        return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::character_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    CHARACTER_ARRAY_DATA *data = ARGUMENTS(0)->character_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::character_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    CHARACTER_ARRAY_DATA *left = apply_character_array_updates((CHARACTER_ARRAY *)ARGUMENTS(0));
    CHARACTER_ARRAY_DATA *right = apply_character_array_updates((CHARACTER_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
        left->items, right->items,sizeof(uint32_t)*left->size) == 0)
  }

FUNCTION std::character_array
  #
    constructs an empty array

    See also: std_types::character_array/new, std::initialized_character_array
  {
    MIN_ARGUMENTS(1)
    CHARACTER_ARRAY_DATA *data = (CHARACTER_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(uint32_t));
    if (!data) return;
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::character_array, 0, data, view, NULL))
  }

FUNCTION std::initialized_character_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::character_array, std_types::character_array/new
  {
    MIN_ARGUMENTS(2)
    CHARACTER_ARRAY_DATA *data = (CHARACTER_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(uint32_t));
    if (!data) return;
    uint32_t initial_value;
    CHECK(to_uchar32(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::character_array, 0, data, view, NULL))
  }

METHOD std_types::character_array/new
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    CHARACTER_ARRAY_DATA *data = (CHARACTER_ARRAY_DATA *)
      new_array_data(ARGUMENTS(0)->character_array.data->info, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::character_array, 0, data,
      ARGUMENTS(0)->character_array.view, NULL))
  }
METHOD std_types::character_array/range
  #
    creates a new array with the elements in the given ranges
  {
    CHARACTER_ARRAY *array = (CHARACTER_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    CHARACTER_ARRAY_DATA *data = apply_character_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::character_array, 0, data, view, NULL))
  }

#######
# ARRAY OF SIGNED 8-BIT NUMBERS
#

RECORD INT8_ARRAY_DATA
  ARRAY_INFO *info
  long size
  int8_t items[]

UNION UPDATE_INT8_ARRAY_DATA/SET_VALUE
  long offset
  int8_t value

TYPE std_types::int8_array -> std_types::generic_array
  # an array of signed 8-bit numbers
  long updates_length
  INT8_ARRAY_DATA *data
  ARRAY_VIEW *view
  ARRAY_UPDATES *updates

CODE
  static INT8_ARRAY_DATA *apply_int8_array_updates(INT8_ARRAY *node)
    {
      INT8_ARRAY_DATA *data = node->data;
      ARRAY_INFO *info = data->info;
      ARRAY_VIEW *view = node->view;
      long size = data->size;
      if (node->updates_length > 0) {
        // copy items
        data = allocate_large(
          ALLOCATION_SIZE(sizeof(INT8_ARRAY_DATA)+size*sizeof(int8_t)));
        memcpy(
          data->items,
          node->data->items,
          size*sizeof(int8_t));
        // apply updates
        char *update = node->updates->buffer;
        char *end_p = update+node->updates_length;
        while (update < end_p) {
          switch (*(TAG *)update) {
            case SET_VALUE:;
              UPDATE_INT8_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
              data->items[set_value->offset] = set_value->value;
              update += sizeof(UPDATE_INT8_ARRAY_DATA_SET_VALUE);
              break;
          }
        }
        data->info = info;
        data->size = size;
        node->updates_length = 0;
        node->data = data;
        node->view = view;
        node->updates = NULL;
      }
      return data;
    }

METHOD std_types::int8_array/_type
  {
    INT8_ARRAY_DATA *data = MYSELF->int8_array.data;
    ARRAY_INFO *info = data->info;
    ARRAY_VIEW *view = MYSELF->int8_array.view;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, info, view);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_int8_array_updates((INT8_ARRAY *)MYSELF);
      int8_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_int8(value));
    } else {
      // set item
      int8_t value;
      CHECK(to_int8(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->int8_array.updates_length;
      MYSELF =
        add_update(
          (ARRAY *)MYSELF, sizeof(UPDATE_INT8_ARRAY_DATA_SET_VALUE));
      UPDATE_INT8_ARRAY_DATA_SET_VALUE *update =
        (UPDATE_INT8_ARRAY_DATA_SET_VALUE *)
        (MYSELF->int8_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::int8_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int8_array.data->info, node->int8_array.view,
      indent, buf, "int8");
  }

METHOD std_types::int8_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->int8_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
        invalid_dimension(ARGUMENTS(0));
        return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::int8_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT8_ARRAY_DATA *data = ARGUMENTS(0)->int8_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::int8_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    INT8_ARRAY_DATA *left = apply_int8_array_updates((INT8_ARRAY *)ARGUMENTS(0));
    INT8_ARRAY_DATA *right = apply_int8_array_updates((INT8_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
        left->items, right->items,sizeof(int8_t)*left->size) == 0)
  }

FUNCTION std::int8_array
  #
    constructs an empty array

    See also: std_types::int8_array/new, std::initialized_int8_array
  {
    MIN_ARGUMENTS(1)
    INT8_ARRAY_DATA *data = (INT8_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(int8_t));
    if (!data) return;
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int8_array, 0, data, view, NULL))
  }

FUNCTION std::initialized_int8_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::int8_array, std_types::int8_array/new
  {
    MIN_ARGUMENTS(2)
    INT8_ARRAY_DATA *data = (INT8_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(int8_t));
    if (!data) return;
    int8_t initial_value;
    CHECK(to_int8(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int8_array, 0, data, view, NULL))
  }

METHOD std_types::int8_array/new
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT8_ARRAY_DATA *data = (INT8_ARRAY_DATA *)
      new_array_data(ARGUMENTS(0)->int8_array.data->info, sizeof(int8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int8_array, 0, data,
      ARGUMENTS(0)->int8_array.view, NULL))
  }
METHOD std_types::int8_array/range
  #
    creates a new array with the elements in the given ranges
  {
    INT8_ARRAY *array = (INT8_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    INT8_ARRAY_DATA *data = apply_int8_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::int8_array, 0, data, view, NULL))
  }

#######
# ARRAY OF UNSIGNED 8-BIT NUMBERS
#

RECORD UINT8_ARRAY_DATA
  ARRAY_INFO *info
  long size
  uint8_t items[]

UNION UPDATE_UINT8_ARRAY_DATA/SET_VALUE
  long offset
  uint8_t value

TYPE std_types::uint8_array -> std_types::generic_array
  # an array of unsigned 8-bit numbers
  long updates_length
  UINT8_ARRAY_DATA *data
  ARRAY_VIEW *view
  ARRAY_UPDATES *updates

CODE
  static UINT8_ARRAY_DATA *apply_uint8_array_updates(UINT8_ARRAY *node)
    {
      UINT8_ARRAY_DATA *data = node->data;
      ARRAY_INFO *info = data->info;
      ARRAY_VIEW *view = node->view;
      long size = data->size;
      if (node->updates_length > 0) {
        // copy items
        data = allocate_large(
          ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
        memcpy(
          data->items,
          node->data->items,
          size*sizeof(uint8_t));
        // apply updates
        char *update = node->updates->buffer;
        char *end_p = update+node->updates_length;
        while (update < end_p) {
          switch (*(TAG *)update) {
            case SET_VALUE:;
              UPDATE_UINT8_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
              data->items[set_value->offset] = set_value->value;
              update += sizeof(UPDATE_UINT8_ARRAY_DATA_SET_VALUE);
              break;
          }
        }
        data->info = info;
        data->size = size;
        node->updates_length = 0;
        node->data = data;
        node->view = view;
        node->updates = NULL;
      }
      return data;
    }

METHOD std_types::uint8_array/_type
  {
    UINT8_ARRAY_DATA *data = MYSELF->uint8_array.data;
    ARRAY_INFO *info = data->info;
    ARRAY_VIEW *view = MYSELF->uint8_array.view;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, info, view);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_uint8_array_updates((UINT8_ARRAY *)MYSELF);
      uint8_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_uint8(value));
    } else {
      // set item
      uint8_t value;
      CHECK(to_uint8(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->uint8_array.updates_length;
      MYSELF =
        add_update(
          (ARRAY *)MYSELF, sizeof(UPDATE_UINT8_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT8_ARRAY_DATA_SET_VALUE *update =
        (UPDATE_UINT8_ARRAY_DATA_SET_VALUE *)
        (MYSELF->uint8_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::uint8_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint8_array.data->info, node->uint8_array.view,
      indent, buf, "uint8");
  }

METHOD std_types::uint8_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->uint8_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
        invalid_dimension(ARGUMENTS(0));
        return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::uint8_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT8_ARRAY_DATA *data = ARGUMENTS(0)->uint8_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::uint8_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(0));
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
        left->items, right->items,sizeof(uint8_t)*left->size) == 0)
  }
METHOD std_types::uint8_array/bit_and
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(0));
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT8_ARRAY_DATA *data =
      allocate_large(
        ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0, data,
      ARGUMENTS(0)->uint8_array.view, NULL))
  }

METHOD std_types::uint8_array/bit_or
  #
    implements the *or* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(0));
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT8_ARRAY_DATA *data =
      allocate_large(
        ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0, data,
      ARGUMENTS(0)->uint8_array.view, NULL))
  }

METHOD std_types::uint8_array/bit_xor
  #
    implements the *xor* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(0));
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT8_ARRAY_DATA *data =
      allocate_large(
        ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0, data,
      ARGUMENTS(0)->uint8_array.view, NULL))
  }

FUNCTION std::uint8_array
  #
    constructs an empty array

    See also: std_types::uint8_array/new, std::initialized_uint8_array
  {
    MIN_ARGUMENTS(1)
    UINT8_ARRAY_DATA *data = (UINT8_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(uint8_t));
    if (!data) return;
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0, data, view, NULL))
  }

FUNCTION std::initialized_uint8_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::uint8_array, std_types::uint8_array/new
  {
    MIN_ARGUMENTS(2)
    UINT8_ARRAY_DATA *data = (UINT8_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(uint8_t));
    if (!data) return;
    uint8_t initial_value;
    CHECK(to_uint8(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0, data, view, NULL))
  }

METHOD std_types::uint8_array/new
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT8_ARRAY_DATA *data = (UINT8_ARRAY_DATA *)
      new_array_data(ARGUMENTS(0)->uint8_array.data->info, sizeof(uint8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0, data,
      ARGUMENTS(0)->uint8_array.view, NULL))
  }
METHOD std_types::uint8_array/range
  #
    creates a new array with the elements in the given ranges
  {
    UINT8_ARRAY *array = (UINT8_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    UINT8_ARRAY_DATA *data = apply_uint8_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0, data, view, NULL))
  }

#######
# ARRAY OF SIGNED 16-BIT NUMBERS
#

RECORD INT16_ARRAY_DATA
  ARRAY_INFO *info
  long size
  int16_t items[]

UNION UPDATE_INT16_ARRAY_DATA/SET_VALUE
  long offset
  int16_t value

TYPE std_types::int16_array -> std_types::generic_array
  # an array of signed 16-bit numbers
  long updates_length
  INT16_ARRAY_DATA *data
  ARRAY_VIEW *view
  ARRAY_UPDATES *updates

CODE
  static INT16_ARRAY_DATA *apply_int16_array_updates(INT16_ARRAY *node)
    {
      INT16_ARRAY_DATA *data = node->data;
      ARRAY_INFO *info = data->info;
      ARRAY_VIEW *view = node->view;
      long size = data->size;
      if (node->updates_length > 0) {
        // copy items
        data = allocate_large(
          ALLOCATION_SIZE(sizeof(INT16_ARRAY_DATA)+size*sizeof(int16_t)));
        memcpy(
          data->items,
          node->data->items,
          size*sizeof(int16_t));
        // apply updates
        char *update = node->updates->buffer;
        char *end_p = update+node->updates_length;
        while (update < end_p) {
          switch (*(TAG *)update) {
            case SET_VALUE:;
              UPDATE_INT16_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
              data->items[set_value->offset] = set_value->value;
              update += sizeof(UPDATE_INT16_ARRAY_DATA_SET_VALUE);
              break;
          }
        }
        data->info = info;
        data->size = size;
        node->updates_length = 0;
        node->data = data;
        node->view = view;
        node->updates = NULL;
      }
      return data;
    }

METHOD std_types::int16_array/_type
  {
    INT16_ARRAY_DATA *data = MYSELF->int16_array.data;
    ARRAY_INFO *info = data->info;
    ARRAY_VIEW *view = MYSELF->int16_array.view;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, info, view);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_int16_array_updates((INT16_ARRAY *)MYSELF);
      int16_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_int16(value));
    } else {
      // set item
      int16_t value;
      CHECK(to_int16(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->int16_array.updates_length;
      MYSELF =
        add_update(
          (ARRAY *)MYSELF, sizeof(UPDATE_INT16_ARRAY_DATA_SET_VALUE));
      UPDATE_INT16_ARRAY_DATA_SET_VALUE *update =
        (UPDATE_INT16_ARRAY_DATA_SET_VALUE *)
        (MYSELF->int16_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::int16_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int16_array.data->info, node->int16_array.view,
      indent, buf, "int16");
  }

METHOD std_types::int16_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->int16_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
        invalid_dimension(ARGUMENTS(0));
        return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::int16_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT16_ARRAY_DATA *data = ARGUMENTS(0)->int16_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::int16_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    INT16_ARRAY_DATA *left = apply_int16_array_updates((INT16_ARRAY *)ARGUMENTS(0));
    INT16_ARRAY_DATA *right = apply_int16_array_updates((INT16_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
        left->items, right->items,sizeof(int16_t)*left->size) == 0)
  }

FUNCTION std::int16_array
  #
    constructs an empty array

    See also: std_types::int16_array/new, std::initialized_int16_array
  {
    MIN_ARGUMENTS(1)
    INT16_ARRAY_DATA *data = (INT16_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(int16_t));
    if (!data) return;
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int16_array, 0, data, view, NULL))
  }

FUNCTION std::initialized_int16_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::int16_array, std_types::int16_array/new
  {
    MIN_ARGUMENTS(2)
    INT16_ARRAY_DATA *data = (INT16_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(int16_t));
    if (!data) return;
    int16_t initial_value;
    CHECK(to_int16(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int16_array, 0, data, view, NULL))
  }

METHOD std_types::int16_array/new
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT16_ARRAY_DATA *data = (INT16_ARRAY_DATA *)
      new_array_data(ARGUMENTS(0)->int16_array.data->info, sizeof(int16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int16_array, 0, data,
      ARGUMENTS(0)->int16_array.view, NULL))
  }
METHOD std_types::int16_array/range
  #
    creates a new array with the elements in the given ranges
  {
    INT16_ARRAY *array = (INT16_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    INT16_ARRAY_DATA *data = apply_int16_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::int16_array, 0, data, view, NULL))
  }

#######
# ARRAY OF UNSIGNED 16-BIT NUMBERS
#

RECORD UINT16_ARRAY_DATA
  ARRAY_INFO *info
  long size
  uint16_t items[]

UNION UPDATE_UINT16_ARRAY_DATA/SET_VALUE
  long offset
  uint16_t value

TYPE std_types::uint16_array -> std_types::generic_array
  # an array of unsigned 16-bit numbers
  long updates_length
  UINT16_ARRAY_DATA *data
  ARRAY_VIEW *view
  ARRAY_UPDATES *updates

CODE
  static UINT16_ARRAY_DATA *apply_uint16_array_updates(UINT16_ARRAY *node)
    {
      UINT16_ARRAY_DATA *data = node->data;
      ARRAY_INFO *info = data->info;
      ARRAY_VIEW *view = node->view;
      long size = data->size;
      if (node->updates_length > 0) {
        // copy items
        data = allocate_large(
          ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
        memcpy(
          data->items,
          node->data->items,
          size*sizeof(uint16_t));
        // apply updates
        char *update = node->updates->buffer;
        char *end_p = update+node->updates_length;
        while (update < end_p) {
          switch (*(TAG *)update) {
            case SET_VALUE:;
              UPDATE_UINT16_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
              data->items[set_value->offset] = set_value->value;
              update += sizeof(UPDATE_UINT16_ARRAY_DATA_SET_VALUE);
              break;
          }
        }
        data->info = info;
        data->size = size;
        node->updates_length = 0;
        node->data = data;
        node->view = view;
        node->updates = NULL;
      }
      return data;
    }

METHOD std_types::uint16_array/_type
  {
    UINT16_ARRAY_DATA *data = MYSELF->uint16_array.data;
    ARRAY_INFO *info = data->info;
    ARRAY_VIEW *view = MYSELF->uint16_array.view;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, info, view);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_uint16_array_updates((UINT16_ARRAY *)MYSELF);
      uint16_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_uint16(value));
    } else {
      // set item
      uint16_t value;
      CHECK(to_uint16(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->uint16_array.updates_length;
      MYSELF =
        add_update(
          (ARRAY *)MYSELF, sizeof(UPDATE_UINT16_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT16_ARRAY_DATA_SET_VALUE *update =
        (UPDATE_UINT16_ARRAY_DATA_SET_VALUE *)
        (MYSELF->uint16_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::uint16_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint16_array.data->info, node->uint16_array.view,
      indent, buf, "uint16");
  }

METHOD std_types::uint16_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->uint16_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
        invalid_dimension(ARGUMENTS(0));
        return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::uint16_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT16_ARRAY_DATA *data = ARGUMENTS(0)->uint16_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::uint16_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(0));
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
        left->items, right->items,sizeof(uint16_t)*left->size) == 0)
  }
METHOD std_types::uint16_array/bit_and
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(0));
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT16_ARRAY_DATA *data =
      allocate_large(
        ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0, data,
      ARGUMENTS(0)->uint16_array.view, NULL))
  }

METHOD std_types::uint16_array/bit_or
  #
    implements the *or* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(0));
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT16_ARRAY_DATA *data =
      allocate_large(
        ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0, data,
      ARGUMENTS(0)->uint16_array.view, NULL))
  }

METHOD std_types::uint16_array/bit_xor
  #
    implements the *xor* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(0));
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT16_ARRAY_DATA *data =
      allocate_large(
        ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0, data,
      ARGUMENTS(0)->uint16_array.view, NULL))
  }

FUNCTION std::uint16_array
  #
    constructs an empty array

    See also: std_types::uint16_array/new, std::initialized_uint16_array
  {
    MIN_ARGUMENTS(1)
    UINT16_ARRAY_DATA *data = (UINT16_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(uint16_t));
    if (!data) return;
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0, data, view, NULL))
  }

FUNCTION std::initialized_uint16_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::uint16_array, std_types::uint16_array/new
  {
    MIN_ARGUMENTS(2)
    UINT16_ARRAY_DATA *data = (UINT16_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(uint16_t));
    if (!data) return;
    uint16_t initial_value;
    CHECK(to_uint16(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0, data, view, NULL))
  }

METHOD std_types::uint16_array/new
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT16_ARRAY_DATA *data = (UINT16_ARRAY_DATA *)
      new_array_data(ARGUMENTS(0)->uint16_array.data->info, sizeof(uint16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0, data,
      ARGUMENTS(0)->uint16_array.view, NULL))
  }
METHOD std_types::uint16_array/range
  #
    creates a new array with the elements in the given ranges
  {
    UINT16_ARRAY *array = (UINT16_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    UINT16_ARRAY_DATA *data = apply_uint16_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0, data, view, NULL))
  }

#######
# ARRAY OF SIGNED 32-BIT NUMBERS
#

RECORD INT32_ARRAY_DATA
  ARRAY_INFO *info
  long size
  int32_t items[]

UNION UPDATE_INT32_ARRAY_DATA/SET_VALUE
  long offset
  int32_t value

TYPE std_types::int32_array -> std_types::generic_array
  # an array of signed 32-bit numbers
  long updates_length
  INT32_ARRAY_DATA *data
  ARRAY_VIEW *view
  ARRAY_UPDATES *updates

CODE
  static INT32_ARRAY_DATA *apply_int32_array_updates(INT32_ARRAY *node)
    {
      INT32_ARRAY_DATA *data = node->data;
      ARRAY_INFO *info = data->info;
      ARRAY_VIEW *view = node->view;
      long size = data->size;
      if (node->updates_length > 0) {
        // copy items
        data = allocate_large(
          ALLOCATION_SIZE(sizeof(INT32_ARRAY_DATA)+size*sizeof(int32_t)));
        memcpy(
          data->items,
          node->data->items,
          size*sizeof(int32_t));
        // apply updates
        char *update = node->updates->buffer;
        char *end_p = update+node->updates_length;
        while (update < end_p) {
          switch (*(TAG *)update) {
            case SET_VALUE:;
              UPDATE_INT32_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
              data->items[set_value->offset] = set_value->value;
              update += sizeof(UPDATE_INT32_ARRAY_DATA_SET_VALUE);
              break;
          }
        }
        data->info = info;
        data->size = size;
        node->updates_length = 0;
        node->data = data;
        node->view = view;
        node->updates = NULL;
      }
      return data;
    }

METHOD std_types::int32_array/_type
  {
    INT32_ARRAY_DATA *data = MYSELF->int32_array.data;
    ARRAY_INFO *info = data->info;
    ARRAY_VIEW *view = MYSELF->int32_array.view;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, info, view);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_int32_array_updates((INT32_ARRAY *)MYSELF);
      int32_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_int32(value));
    } else {
      // set item
      int32_t value;
      CHECK(to_int32(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->int32_array.updates_length;
      MYSELF =
        add_update(
          (ARRAY *)MYSELF, sizeof(UPDATE_INT32_ARRAY_DATA_SET_VALUE));
      UPDATE_INT32_ARRAY_DATA_SET_VALUE *update =
        (UPDATE_INT32_ARRAY_DATA_SET_VALUE *)
        (MYSELF->int32_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::int32_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int32_array.data->info, node->int32_array.view,
      indent, buf, "int32");
  }

METHOD std_types::int32_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->int32_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
        invalid_dimension(ARGUMENTS(0));
        return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::int32_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT32_ARRAY_DATA *data = ARGUMENTS(0)->int32_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::int32_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    INT32_ARRAY_DATA *left = apply_int32_array_updates((INT32_ARRAY *)ARGUMENTS(0));
    INT32_ARRAY_DATA *right = apply_int32_array_updates((INT32_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
        left->items, right->items,sizeof(int32_t)*left->size) == 0)
  }

FUNCTION std::int32_array
  #
    constructs an empty array

    See also: std_types::int32_array/new, std::initialized_int32_array
  {
    MIN_ARGUMENTS(1)
    INT32_ARRAY_DATA *data = (INT32_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(int32_t));
    if (!data) return;
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int32_array, 0, data, view, NULL))
  }

FUNCTION std::initialized_int32_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::int32_array, std_types::int32_array/new
  {
    MIN_ARGUMENTS(2)
    INT32_ARRAY_DATA *data = (INT32_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(int32_t));
    if (!data) return;
    int32_t initial_value;
    CHECK(to_int32(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int32_array, 0, data, view, NULL))
  }

METHOD std_types::int32_array/new
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT32_ARRAY_DATA *data = (INT32_ARRAY_DATA *)
      new_array_data(ARGUMENTS(0)->int32_array.data->info, sizeof(int32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int32_array, 0, data,
      ARGUMENTS(0)->int32_array.view, NULL))
  }
METHOD std_types::int32_array/range
  #
    creates a new array with the elements in the given ranges
  {
    INT32_ARRAY *array = (INT32_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    INT32_ARRAY_DATA *data = apply_int32_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::int32_array, 0, data, view, NULL))
  }

#######
# ARRAY OF UNSIGNED 32-BIT NUMBERS
#

RECORD UINT32_ARRAY_DATA
  ARRAY_INFO *info
  long size
  uint32_t items[]

UNION UPDATE_UINT32_ARRAY_DATA/SET_VALUE
  long offset
  uint32_t value

TYPE std_types::uint32_array -> std_types::generic_array
  # an array of unsigned 32-bit numbers
  long updates_length
  UINT32_ARRAY_DATA *data
  ARRAY_VIEW *view
  ARRAY_UPDATES *updates

CODE
  static UINT32_ARRAY_DATA *apply_uint32_array_updates(UINT32_ARRAY *node)
    {
      UINT32_ARRAY_DATA *data = node->data;
      ARRAY_INFO *info = data->info;
      ARRAY_VIEW *view = node->view;
      long size = data->size;
      if (node->updates_length > 0) {
        // copy items
        data = allocate_large(
          ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
        memcpy(
          data->items,
          node->data->items,
          size*sizeof(uint32_t));
        // apply updates
        char *update = node->updates->buffer;
        char *end_p = update+node->updates_length;
        while (update < end_p) {
          switch (*(TAG *)update) {
            case SET_VALUE:;
              UPDATE_UINT32_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
              data->items[set_value->offset] = set_value->value;
              update += sizeof(UPDATE_UINT32_ARRAY_DATA_SET_VALUE);
              break;
          }
        }
        data->info = info;
        data->size = size;
        node->updates_length = 0;
        node->data = data;
        node->view = view;
        node->updates = NULL;
      }
      return data;
    }

METHOD std_types::uint32_array/_type
  {
    UINT32_ARRAY_DATA *data = MYSELF->uint32_array.data;
    ARRAY_INFO *info = data->info;
    ARRAY_VIEW *view = MYSELF->uint32_array.view;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, info, view);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_uint32_array_updates((UINT32_ARRAY *)MYSELF);
      uint32_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_uint32(value));
    } else {
      // set item
      uint32_t value;
      CHECK(to_uint32(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->uint32_array.updates_length;
      MYSELF =
        add_update(
          (ARRAY *)MYSELF, sizeof(UPDATE_UINT32_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT32_ARRAY_DATA_SET_VALUE *update =
        (UPDATE_UINT32_ARRAY_DATA_SET_VALUE *)
        (MYSELF->uint32_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::uint32_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint32_array.data->info, node->uint32_array.view,
      indent, buf, "uint32");
  }

METHOD std_types::uint32_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->uint32_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
        invalid_dimension(ARGUMENTS(0));
        return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::uint32_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT32_ARRAY_DATA *data = ARGUMENTS(0)->uint32_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::uint32_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(0));
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
        left->items, right->items,sizeof(uint32_t)*left->size) == 0)
  }
METHOD std_types::uint32_array/bit_and
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(0));
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT32_ARRAY_DATA *data =
      allocate_large(
        ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0, data,
      ARGUMENTS(0)->uint32_array.view, NULL))
  }

METHOD std_types::uint32_array/bit_or
  #
    implements the *or* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(0));
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT32_ARRAY_DATA *data =
      allocate_large(
        ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0, data,
      ARGUMENTS(0)->uint32_array.view, NULL))
  }

METHOD std_types::uint32_array/bit_xor
  #
    implements the *xor* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(0));
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT32_ARRAY_DATA *data =
      allocate_large(
        ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0, data,
      ARGUMENTS(0)->uint32_array.view, NULL))
  }

FUNCTION std::uint32_array
  #
    constructs an empty array

    See also: std_types::uint32_array/new, std::initialized_uint32_array
  {
    MIN_ARGUMENTS(1)
    UINT32_ARRAY_DATA *data = (UINT32_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(uint32_t));
    if (!data) return;
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0, data, view, NULL))
  }

FUNCTION std::initialized_uint32_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::uint32_array, std_types::uint32_array/new
  {
    MIN_ARGUMENTS(2)
    UINT32_ARRAY_DATA *data = (UINT32_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(uint32_t));
    if (!data) return;
    uint32_t initial_value;
    CHECK(to_uint32(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0, data, view, NULL))
  }

METHOD std_types::uint32_array/new
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT32_ARRAY_DATA *data = (UINT32_ARRAY_DATA *)
      new_array_data(ARGUMENTS(0)->uint32_array.data->info, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0, data,
      ARGUMENTS(0)->uint32_array.view, NULL))
  }
METHOD std_types::uint32_array/range
  #
    creates a new array with the elements in the given ranges
  {
    UINT32_ARRAY *array = (UINT32_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    UINT32_ARRAY_DATA *data = apply_uint32_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0, data, view, NULL))
  }

#######
# ARRAY OF SIGNED 64-BIT NUMBERS
#

RECORD INT64_ARRAY_DATA
  ARRAY_INFO *info
  long size
  int64_t items[]

UNION UPDATE_INT64_ARRAY_DATA/SET_VALUE
  long offset
  int64_t value

TYPE std_types::int64_array -> std_types::generic_array
  # an array of signed 64-bit numbers
  long updates_length
  INT64_ARRAY_DATA *data
  ARRAY_VIEW *view
  ARRAY_UPDATES *updates

CODE
  static INT64_ARRAY_DATA *apply_int64_array_updates(INT64_ARRAY *node)
    {
      INT64_ARRAY_DATA *data = node->data;
      ARRAY_INFO *info = data->info;
      ARRAY_VIEW *view = node->view;
      long size = data->size;
      if (node->updates_length > 0) {
        // copy items
        data = allocate_large(
          ALLOCATION_SIZE(sizeof(INT64_ARRAY_DATA)+size*sizeof(int64_t)));
        memcpy(
          data->items,
          node->data->items,
          size*sizeof(int64_t));
        // apply updates
        char *update = node->updates->buffer;
        char *end_p = update+node->updates_length;
        while (update < end_p) {
          switch (*(TAG *)update) {
            case SET_VALUE:;
              UPDATE_INT64_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
              data->items[set_value->offset] = set_value->value;
              update += sizeof(UPDATE_INT64_ARRAY_DATA_SET_VALUE);
              break;
          }
        }
        data->info = info;
        data->size = size;
        node->updates_length = 0;
        node->data = data;
        node->view = view;
        node->updates = NULL;
      }
      return data;
    }

METHOD std_types::int64_array/_type
  {
    INT64_ARRAY_DATA *data = MYSELF->int64_array.data;
    ARRAY_INFO *info = data->info;
    ARRAY_VIEW *view = MYSELF->int64_array.view;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, info, view);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_int64_array_updates((INT64_ARRAY *)MYSELF);
      int64_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_int64(value));
    } else {
      // set item
      int64_t value;
      CHECK(to_int64(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->int64_array.updates_length;
      MYSELF =
        add_update(
          (ARRAY *)MYSELF, sizeof(UPDATE_INT64_ARRAY_DATA_SET_VALUE));
      UPDATE_INT64_ARRAY_DATA_SET_VALUE *update =
        (UPDATE_INT64_ARRAY_DATA_SET_VALUE *)
        (MYSELF->int64_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::int64_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int64_array.data->info, node->int64_array.view,
      indent, buf, "int64");
  }

METHOD std_types::int64_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->int64_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
        invalid_dimension(ARGUMENTS(0));
        return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::int64_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT64_ARRAY_DATA *data = ARGUMENTS(0)->int64_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::int64_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    INT64_ARRAY_DATA *left = apply_int64_array_updates((INT64_ARRAY *)ARGUMENTS(0));
    INT64_ARRAY_DATA *right = apply_int64_array_updates((INT64_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
        left->items, right->items,sizeof(int64_t)*left->size) == 0)
  }

FUNCTION std::int64_array
  #
    constructs an empty array

    See also: std_types::int64_array/new, std::initialized_int64_array
  {
    MIN_ARGUMENTS(1)
    INT64_ARRAY_DATA *data = (INT64_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(int64_t));
    if (!data) return;
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int64_array, 0, data, view, NULL))
  }

FUNCTION std::initialized_int64_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::int64_array, std_types::int64_array/new
  {
    MIN_ARGUMENTS(2)
    INT64_ARRAY_DATA *data = (INT64_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(int64_t));
    if (!data) return;
    int64_t initial_value;
    CHECK(to_int64(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int64_array, 0, data, view, NULL))
  }

METHOD std_types::int64_array/new
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT64_ARRAY_DATA *data = (INT64_ARRAY_DATA *)
      new_array_data(ARGUMENTS(0)->int64_array.data->info, sizeof(int64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int64_array, 0, data,
      ARGUMENTS(0)->int64_array.view, NULL))
  }
METHOD std_types::int64_array/range
  #
    creates a new array with the elements in the given ranges
  {
    INT64_ARRAY *array = (INT64_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    INT64_ARRAY_DATA *data = apply_int64_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::int64_array, 0, data, view, NULL))
  }

#######
# ARRAY OF UNSIGNED 64-BIT NUMBERS
#

RECORD UINT64_ARRAY_DATA
  ARRAY_INFO *info
  long size
  uint64_t items[]

UNION UPDATE_UINT64_ARRAY_DATA/SET_VALUE
  long offset
  uint64_t value

TYPE std_types::uint64_array -> std_types::generic_array
  # an array of unsigned 64-bit numbers
  long updates_length
  UINT64_ARRAY_DATA *data
  ARRAY_VIEW *view
  ARRAY_UPDATES *updates

CODE
  static UINT64_ARRAY_DATA *apply_uint64_array_updates(UINT64_ARRAY *node)
    {
      UINT64_ARRAY_DATA *data = node->data;
      ARRAY_INFO *info = data->info;
      ARRAY_VIEW *view = node->view;
      long size = data->size;
      if (node->updates_length > 0) {
        // copy items
        data = allocate_large(
          ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
        memcpy(
          data->items,
          node->data->items,
          size*sizeof(uint64_t));
        // apply updates
        char *update = node->updates->buffer;
        char *end_p = update+node->updates_length;
        while (update < end_p) {
          switch (*(TAG *)update) {
            case SET_VALUE:;
              UPDATE_UINT64_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
              data->items[set_value->offset] = set_value->value;
              update += sizeof(UPDATE_UINT64_ARRAY_DATA_SET_VALUE);
              break;
          }
        }
        data->info = info;
        data->size = size;
        node->updates_length = 0;
        node->data = data;
        node->view = view;
        node->updates = NULL;
      }
      return data;
    }

METHOD std_types::uint64_array/_type
  {
    UINT64_ARRAY_DATA *data = MYSELF->uint64_array.data;
    ARRAY_INFO *info = data->info;
    ARRAY_VIEW *view = MYSELF->uint64_array.view;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, info, view);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_uint64_array_updates((UINT64_ARRAY *)MYSELF);
      uint64_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_uint64(value));
    } else {
      // set item
      uint64_t value;
      CHECK(to_uint64(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->uint64_array.updates_length;
      MYSELF =
        add_update(
          (ARRAY *)MYSELF, sizeof(UPDATE_UINT64_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT64_ARRAY_DATA_SET_VALUE *update =
        (UPDATE_UINT64_ARRAY_DATA_SET_VALUE *)
        (MYSELF->uint64_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::uint64_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint64_array.data->info, node->uint64_array.view,
      indent, buf, "uint64");
  }

METHOD std_types::uint64_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->uint64_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
        invalid_dimension(ARGUMENTS(0));
        return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::uint64_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT64_ARRAY_DATA *data = ARGUMENTS(0)->uint64_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::uint64_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(0));
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
        left->items, right->items,sizeof(uint64_t)*left->size) == 0)
  }
METHOD std_types::uint64_array/bit_and
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(0));
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT64_ARRAY_DATA *data =
      allocate_large(
        ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0, data,
      ARGUMENTS(0)->uint64_array.view, NULL))
  }

METHOD std_types::uint64_array/bit_or
  #
    implements the *or* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(0));
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT64_ARRAY_DATA *data =
      allocate_large(
        ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0, data,
      ARGUMENTS(0)->uint64_array.view, NULL))
  }

METHOD std_types::uint64_array/bit_xor
  #
    implements the *xor* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(0));
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT64_ARRAY_DATA *data =
      allocate_large(
        ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0, data,
      ARGUMENTS(0)->uint64_array.view, NULL))
  }

FUNCTION std::uint64_array
  #
    constructs an empty array

    See also: std_types::uint64_array/new, std::initialized_uint64_array
  {
    MIN_ARGUMENTS(1)
    UINT64_ARRAY_DATA *data = (UINT64_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(uint64_t));
    if (!data) return;
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0, data, view, NULL))
  }

FUNCTION std::initialized_uint64_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::uint64_array, std_types::uint64_array/new
  {
    MIN_ARGUMENTS(2)
    UINT64_ARRAY_DATA *data = (UINT64_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(uint64_t));
    if (!data) return;
    uint64_t initial_value;
    CHECK(to_uint64(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0, data, view, NULL))
  }

METHOD std_types::uint64_array/new
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT64_ARRAY_DATA *data = (UINT64_ARRAY_DATA *)
      new_array_data(ARGUMENTS(0)->uint64_array.data->info, sizeof(uint64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0, data,
      ARGUMENTS(0)->uint64_array.view, NULL))
  }
METHOD std_types::uint64_array/range
  #
    creates a new array with the elements in the given ranges
  {
    UINT64_ARRAY *array = (UINT64_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    UINT64_ARRAY_DATA *data = apply_uint64_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0, data, view, NULL))
  }

#######
# ARRAY OF 32-BIT FLOATING POINT NUMBERS
#

RECORD FLOAT32_ARRAY_DATA
  ARRAY_INFO *info
  long size
  float items[]

UNION UPDATE_FLOAT32_ARRAY_DATA/SET_VALUE
  long offset
  float value

TYPE std_types::float32_array -> std_types::generic_array
  # an array of 32-bit floating point numbers
  long updates_length
  FLOAT32_ARRAY_DATA *data
  ARRAY_VIEW *view
  ARRAY_UPDATES *updates

CODE
  static FLOAT32_ARRAY_DATA *apply_float32_array_updates(FLOAT32_ARRAY *node)
    {
      FLOAT32_ARRAY_DATA *data = node->data;
      ARRAY_INFO *info = data->info;
      ARRAY_VIEW *view = node->view;
      long size = data->size;
      if (node->updates_length > 0) {
        // copy items
        data = allocate_large(
          ALLOCATION_SIZE(sizeof(FLOAT32_ARRAY_DATA)+size*sizeof(float)));
        memcpy(
          data->items,
          node->data->items,
          size*sizeof(float));
        // apply updates
        char *update = node->updates->buffer;
        char *end_p = update+node->updates_length;
        while (update < end_p) {
          switch (*(TAG *)update) {
            case SET_VALUE:;
              UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
              data->items[set_value->offset] = set_value->value;
              update += sizeof(UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE);
              break;
          }
        }
        data->info = info;
        data->size = size;
        node->updates_length = 0;
        node->data = data;
        node->view = view;
        node->updates = NULL;
      }
      return data;
    }

METHOD std_types::float32_array/_type
  {
    FLOAT32_ARRAY_DATA *data = MYSELF->float32_array.data;
    ARRAY_INFO *info = data->info;
    ARRAY_VIEW *view = MYSELF->float32_array.view;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, info, view);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_float32_array_updates((FLOAT32_ARRAY *)MYSELF);
      float value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_float(value));
    } else {
      // set item
      float value;
      CHECK(to_float(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->float32_array.updates_length;
      MYSELF =
        add_update(
          (ARRAY *)MYSELF, sizeof(UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE));
      UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE *update =
        (UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE *)
        (MYSELF->float32_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::float32_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->float32_array.data->info, node->float32_array.view,
      indent, buf, "float32");
  }

METHOD std_types::float32_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->float32_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
        invalid_dimension(ARGUMENTS(0));
        return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::float32_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    FLOAT32_ARRAY_DATA *data = ARGUMENTS(0)->float32_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::float32_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    FLOAT32_ARRAY_DATA *left = apply_float32_array_updates((FLOAT32_ARRAY *)ARGUMENTS(0));
    FLOAT32_ARRAY_DATA *right = apply_float32_array_updates((FLOAT32_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
        left->items, right->items,sizeof(float)*left->size) == 0)
  }

FUNCTION std::float32_array
  #
    constructs an empty array

    See also: std_types::float32_array/new, std::initialized_float32_array
  {
    MIN_ARGUMENTS(1)
    FLOAT32_ARRAY_DATA *data = (FLOAT32_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(float));
    if (!data) return;
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::float32_array, 0, data, view, NULL))
  }

FUNCTION std::initialized_float32_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::float32_array, std_types::float32_array/new
  {
    MIN_ARGUMENTS(2)
    FLOAT32_ARRAY_DATA *data = (FLOAT32_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(float));
    if (!data) return;
    float initial_value;
    CHECK(to_float(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::float32_array, 0, data, view, NULL))
  }

METHOD std_types::float32_array/new
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    FLOAT32_ARRAY_DATA *data = (FLOAT32_ARRAY_DATA *)
      new_array_data(ARGUMENTS(0)->float32_array.data->info, sizeof(float));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::float32_array, 0, data,
      ARGUMENTS(0)->float32_array.view, NULL))
  }
METHOD std_types::float32_array/range
  #
    creates a new array with the elements in the given ranges
  {
    FLOAT32_ARRAY *array = (FLOAT32_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    FLOAT32_ARRAY_DATA *data = apply_float32_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::float32_array, 0, data, view, NULL))
  }

#######
# ARRAY OF 64-BIT FLOATING POINT NUMBERS
#

RECORD FLOAT64_ARRAY_DATA
  ARRAY_INFO *info
  long size
  double items[]

UNION UPDATE_FLOAT64_ARRAY_DATA/SET_VALUE
  long offset
  double value

TYPE std_types::float64_array -> std_types::generic_array
  # an array of 64-bit floating point numbers
  long updates_length
  FLOAT64_ARRAY_DATA *data
  ARRAY_VIEW *view
  ARRAY_UPDATES *updates

CODE
  static FLOAT64_ARRAY_DATA *apply_float64_array_updates(FLOAT64_ARRAY *node)
    {
      FLOAT64_ARRAY_DATA *data = node->data;
      ARRAY_INFO *info = data->info;
      ARRAY_VIEW *view = node->view;
      long size = data->size;
      if (node->updates_length > 0) {
        // copy items
        data = allocate_large(
          ALLOCATION_SIZE(sizeof(FLOAT64_ARRAY_DATA)+size*sizeof(double)));
        memcpy(
          data->items,
          node->data->items,
          size*sizeof(double));
        // apply updates
        char *update = node->updates->buffer;
        char *end_p = update+node->updates_length;
        while (update < end_p) {
          switch (*(TAG *)update) {
            case SET_VALUE:;
              UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
              data->items[set_value->offset] = set_value->value;
              update += sizeof(UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE);
              break;
          }
        }
        data->info = info;
        data->size = size;
        node->updates_length = 0;
        node->data = data;
        node->view = view;
        node->updates = NULL;
      }
      return data;
    }

METHOD std_types::float64_array/_type
  {
    FLOAT64_ARRAY_DATA *data = MYSELF->float64_array.data;
    ARRAY_INFO *info = data->info;
    ARRAY_VIEW *view = MYSELF->float64_array.view;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, info, view);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_float64_array_updates((FLOAT64_ARRAY *)MYSELF);
      double value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_double(value));
    } else {
      // set item
      double value;
      CHECK(to_double(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->float64_array.updates_length;
      MYSELF =
        add_update(
          (ARRAY *)MYSELF, sizeof(UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE));
      UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE *update =
        (UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE *)
        (MYSELF->float64_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::float64_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->float64_array.data->info, node->float64_array.view,
      indent, buf, "float64");
  }

METHOD std_types::float64_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->float64_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
        invalid_dimension(ARGUMENTS(0));
        return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::float64_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    FLOAT64_ARRAY_DATA *data = ARGUMENTS(0)->float64_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::float64_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    FLOAT64_ARRAY_DATA *left = apply_float64_array_updates((FLOAT64_ARRAY *)ARGUMENTS(0));
    FLOAT64_ARRAY_DATA *right = apply_float64_array_updates((FLOAT64_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
        left->items, right->items,sizeof(double)*left->size) == 0)
  }

FUNCTION std::float64_array
  #
    constructs an empty array

    See also: std_types::float64_array/new, std::initialized_float64_array
  {
    MIN_ARGUMENTS(1)
    FLOAT64_ARRAY_DATA *data = (FLOAT64_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(double));
    if (!data) return;
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::float64_array, 0, data, view, NULL))
  }

FUNCTION std::initialized_float64_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::float64_array, std_types::float64_array/new
  {
    MIN_ARGUMENTS(2)
    FLOAT64_ARRAY_DATA *data = (FLOAT64_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(double));
    if (!data) return;
    double initial_value;
    CHECK(to_double(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    ARRAY_VIEW *view = create_array_view(data->info);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::float64_array, 0, data, view, NULL))
  }

METHOD std_types::float64_array/new
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    FLOAT64_ARRAY_DATA *data = (FLOAT64_ARRAY_DATA *)
      new_array_data(ARGUMENTS(0)->float64_array.data->info, sizeof(double));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::float64_array, 0, data,
      ARGUMENTS(0)->float64_array.view, NULL))
  }
METHOD std_types::float64_array/range
  #
    creates a new array with the elements in the given ranges
  {
    FLOAT64_ARRAY *array = (FLOAT64_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    FLOAT64_ARRAY_DATA *data = apply_float64_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::float64_array, 0, data, view, NULL))
  }
