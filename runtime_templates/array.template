#
  This file was automatically generated by the script
  "array_autogen.fky" - do not edit!

#
  Copyright (C) 2022 by
  Dipl.-Ing. Michael Niederle

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License, version 2, or
  (at your option) version 3.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  For details of the GNU General Public License see the accompanying
  files GPLv2.txt and GLPv3.txt or
  http://www.gnu.org/licenses/gpl-2.0.html
  http://www.gnu.org/licenses/gpl-3.0.html
  or write to the
  Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

TYPE std_types::generic_array -> std_types::object
  #
    the prototype object for all kind of arrays

    An can have any number of dimensions.

    The size of each dimension is specified on creation.

    Updates to array elements are delayed until the next read access.

    There are methods to operate on the array as a whole.

    Topic: Collections

    See also: std_types::array, std_types::boolean_array,
	      std_types::character_array, std_types::int8_array,
	      std_types::uint8_array, std_types::int16_array,
	      std_types::uint16_array, std_types::int32_array,
	      std_types::uint32_array, std_types::int64_array,
	      std_types::uint64_array

METHOD std_types::generic_array/_type
  {
    RUNTIME_ERROR(
      "Attempt to call the generic array prototype object as a function!")
  }

RECORD ARRAY_INFO
  int dimension_count
  int dimensions[]

RECORD ARRAY_UPDATES
  long size
  long length
  char buffer[]

CODE
  static ARRAY_DATA *allocate_array_data
    (
      int dimension_count,
      int item_size
    )
    {
      ARRAY_INFO *info =
	allocate(
	  ALLOCATION_SIZE(sizeof(ARRAY_INFO)+dimension_count*sizeof(int)));
      info->dimension_count = dimension_count;
      int i;
      for (i = 0; i < dimension_count; ++i) {
	int dimension;
	if (!to_int(ARGUMENTS(i), &dimension)) return NULL;
	if (dimension < 1) {
	  invalid_arguments();
	  return NULL;
	}
	info->dimensions[i] = dimension;
      }
      long size = info->dimensions[0];
      for (i = 1; i < dimension_count; ++i) {
	size *= info->dimensions[i];
      }
      ARRAY_DATA *data =
	allocate_large(ALLOCATION_SIZE(sizeof(ARRAY_DATA)+size*item_size));
      data->info = info;
      data->size = size;
      return data;
    }

  static void *add_update
    (
      ARRAY *node,
      long item_size
    )
    {
      long length = node->updates_length;
      ARRAY_UPDATES *updates = node->updates;
      if (length == 0) {
	long size = ALLOCATION_SIZE(item_size);
	updates = allocate_large(sizeof(ARRAY_UPDATES)+size);
	updates->size = size;
	updates->length = length+item_size;
      } else if (
	length != node->updates->length ||
	length+item_size > node->updates->size
      ) {
	long size = ALLOCATION_SIZE(sizeof(ARRAY_UPDATES)+2*length+item_size);
	updates = allocate_large(size);
	updates->size = size;
	memcpy(updates->buffer, node->updates->buffer, length);
      }
      updates->length = length+item_size;
      ARRAY *new_node = allocate(sizeof(ARRAY));
      new_node->type = node->type;
      new_node->attributes = node->attributes;
      new_node->updates_length = length+item_size;
      new_node->data = node->data;
      new_node->updates = updates;
      return new_node;
    }

  static long compute_array_offset
    (
      NODE *array,
      ARRAY_INFO *info
    )
    {
      int i;
      long offset = 0;
      i = info->dimension_count-1;
      int idx;
      next:
      if (!to_int(ARGUMENTS(i), &idx)) return -1;
      if (idx < 0) {
	idx += info->dimensions[i];
      } else {
	--idx;
      }
      if (idx < 0 || idx >= info->dimensions[i]) {
	invalid_index(array);
	return -1;
      }
      offset += idx;
      if (--i < 0) return offset;
      offset *= info->dimensions[i];
      goto next;
    }

  static long array_debug_string
    (
      ARRAY_INFO *info,
      int indent,
      char *buf,
      const char *typename
    )
    {
      char type[1024];
      char *p = type;
      print(&p, "<%s_array(", typename);
      int i;
      for (i = 0; i < info->dimension_count; ++i) {
	if (i) *p++ = ' ';
	print(&p, "%d", info->dimensions[i]);
      }
      *p++ = ')';
      *p++ = '>';
      *p = 0;
      return debug_print(indent, buf, type);
    }

  static int equal_array_type
    (
      NODE *left,
      NODE *right
    )
    {
      if (TYPEOF(left) != TYPEOF(right)) {
	error:
	invalid_arguments();
	return false;
      }
      ARRAY_INFO *left_info = left->array.data->info;
      ARRAY_INFO *right_info = right->array.data->info;
      if (left_info->dimension_count != right_info->dimension_count) goto error;
      int i;
      for (i = 0; i < left_info->dimension_count; ++i) {
	if (left_info->dimensions[i] != right_info->dimensions[i]) goto error;
      }
      return true;
    }

#######
# ARRAY OF OBJECTS
#

RECORD ARRAY_DATA
  ARRAY_INFO *info
  long size
  NODE *items[]

UNION UPDATE_ARRAY_DATA/SET_VALUE
  long offset
  NODE *value

TYPE std_types::array -> std_types::generic_array
  #
    an array of objects

    Topic: Collections

    See also: std_types::boolean_array, std_types::character_array,
	      std_types::int8_array, std_types::uint8_array,
	      std_types::int16_array, std_types::uint16_array,
	      std_types::int32_array, std_types::uint32_array,
	      std_types::int64_array, std_types::uint64_array

  long updates_length
  ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static ARRAY_DATA *apply_array_updates(NODE *node)
    {
      ARRAY_DATA *data = node->array.data;
      ARRAY_INFO *info = data->info;
      long size = data->size;
      if (node->array.updates_length > 0) {
	// copy items
	data = allocate_large(
	  ALLOCATION_SIZE(sizeof(ARRAY_DATA)+size*sizeof(NODE *)));
	memcpy(
	  data->items,
	  node->array.data->items,
	  size*sizeof(NODE *));
	// apply updates
	char *update = node->array.updates->buffer;
	char *end_p = update+node->array.updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	data->info = info;
	data->size = size;
	node->array.updates_length = 0;
	node->array.data = data;
	node->array.updates = NULL;
      }
      return data;
    }

METHOD std_types::array/_type
  {
    ARRAY_DATA *data = MYSELF->array.data;
    ARRAY_INFO *info = data->info;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, data->info);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_array_updates(MYSELF);
      NODE *value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(value);
    } else {
      // set item
      NODE *value;
      value = ARGUMENTS(dimension_count);
      long length = MYSELF->array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_ARRAY_DATA_SET_VALUE));
      UPDATE_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_ARRAY_DATA_SET_VALUE *)
	(MYSELF->array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->array.data->info, indent, buf, "");
  }

METHOD long std_types::array/length_of
  #
    implements the *length_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    ARRAY_DATA *data = ARGUMENTS(0)->array.data;
    ARRAY_INFO *info = data->info;
    if (info->dimension_count == 1) {
      RETURN_SINGLE_RESULT(from_long(info->dimensions[0]))
    } else {
      RETURN_UNDEFINED
    }
  }

FUNCTION std::array
  #
    constructs an empty array

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(1)
    ARRAY_DATA *data = (ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(NODE *));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = (NODE *)&std_types::undefined;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::array, 0, data, NULL))
  }

FUNCTION std::initialized_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(2)
    ARRAY_DATA *data = (ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(NODE *));
    if (!data) return;
    NODE *initial_value;
    initial_value = ARGUMENTS(ARGUMENT_COUNT-1);
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::array, 0, data, NULL))
  }

#######
# ARRAY OF BOOLEAN VALUES
#

RECORD BOOLEAN_ARRAY_DATA
  ARRAY_INFO *info
  long size
  int items[]

UNION UPDATE_BOOLEAN_ARRAY_DATA/SET_VALUE
  long offset
  int value

TYPE std_types::boolean_array -> std_types::generic_array
  # an array of boolean values
  long updates_length
  BOOLEAN_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static BOOLEAN_ARRAY_DATA *apply_boolean_array_updates(NODE *node)
    {
      BOOLEAN_ARRAY_DATA *data = node->boolean_array.data;
      ARRAY_INFO *info = data->info;
      long size = data->size;
      if (node->boolean_array.updates_length > 0) {
	// copy items
	data = allocate_large(
	  ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
	memcpy(
	  data->items,
	  node->boolean_array.data->items,
	  size*sizeof(int));
	// apply updates
	char *update = node->boolean_array.updates->buffer;
	char *end_p = update+node->boolean_array.updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	data->info = info;
	data->size = size;
	node->boolean_array.updates_length = 0;
	node->boolean_array.data = data;
	node->boolean_array.updates = NULL;
      }
      return data;
    }

METHOD std_types::boolean_array/_type
  {
    BOOLEAN_ARRAY_DATA *data = MYSELF->boolean_array.data;
    ARRAY_INFO *info = data->info;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, data->info);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_boolean_array_updates(MYSELF);
      int value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_bool(value));
    } else {
      // set item
      int value;
      CHECK(to_bool(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->boolean_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE));
      UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE *)
	(MYSELF->boolean_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::boolean_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->boolean_array.data->info, indent, buf, "boolean");
  }

METHOD long std_types::boolean_array/length_of
  #
    implements the *length_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    BOOLEAN_ARRAY_DATA *data = ARGUMENTS(0)->boolean_array.data;
    ARRAY_INFO *info = data->info;
    if (info->dimension_count == 1) {
      RETURN_SINGLE_RESULT(from_long(info->dimensions[0]))
    } else {
      RETURN_UNDEFINED
    }
  }

METHOD std_types::boolean_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    BOOLEAN_ARRAY_DATA *left = apply_boolean_array_updates(ARGUMENTS(0));
    BOOLEAN_ARRAY_DATA *right = apply_boolean_array_updates(ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(int)*left->size) == 0)
  }
METHOD std_types::boolean_array/bit_and
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    BOOLEAN_ARRAY_DATA *left = apply_boolean_array_updates(ARGUMENTS(0));
    BOOLEAN_ARRAY_DATA *right = apply_boolean_array_updates(ARGUMENTS(1));
    long size = left->size;
    BOOLEAN_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0, data, NULL))
  }

METHOD std_types::boolean_array/bit_or
  #
    implements the *or* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    BOOLEAN_ARRAY_DATA *left = apply_boolean_array_updates(ARGUMENTS(0));
    BOOLEAN_ARRAY_DATA *right = apply_boolean_array_updates(ARGUMENTS(1));
    long size = left->size;
    BOOLEAN_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0, data, NULL))
  }

METHOD std_types::boolean_array/bit_xor
  #
    implements the *xor* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    BOOLEAN_ARRAY_DATA *left = apply_boolean_array_updates(ARGUMENTS(0));
    BOOLEAN_ARRAY_DATA *right = apply_boolean_array_updates(ARGUMENTS(1));
    long size = left->size;
    BOOLEAN_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0, data, NULL))
  }

FUNCTION std::boolean_array
  #
    constructs an empty array

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(1)
    BOOLEAN_ARRAY_DATA *data = (BOOLEAN_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(int));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = false;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0, data, NULL))
  }

FUNCTION std::initialized_boolean_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(2)
    BOOLEAN_ARRAY_DATA *data = (BOOLEAN_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(int));
    if (!data) return;
    int initial_value;
    CHECK(to_bool(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0, data, NULL))
  }

#######
# ARRAY OF CHARACTERS
#

RECORD CHARACTER_ARRAY_DATA
  ARRAY_INFO *info
  long size
  uint32_t items[]

UNION UPDATE_CHARACTER_ARRAY_DATA/SET_VALUE
  long offset
  uint32_t value

TYPE std_types::character_array -> std_types::generic_array
  # an array of characters
  long updates_length
  CHARACTER_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static CHARACTER_ARRAY_DATA *apply_character_array_updates(NODE *node)
    {
      CHARACTER_ARRAY_DATA *data = node->character_array.data;
      ARRAY_INFO *info = data->info;
      long size = data->size;
      if (node->character_array.updates_length > 0) {
	// copy items
	data = allocate_large(
	  ALLOCATION_SIZE(sizeof(CHARACTER_ARRAY_DATA)+size*sizeof(uint32_t)));
	memcpy(
	  data->items,
	  node->character_array.data->items,
	  size*sizeof(uint32_t));
	// apply updates
	char *update = node->character_array.updates->buffer;
	char *end_p = update+node->character_array.updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	data->info = info;
	data->size = size;
	node->character_array.updates_length = 0;
	node->character_array.data = data;
	node->character_array.updates = NULL;
      }
      return data;
    }

METHOD std_types::character_array/_type
  {
    CHARACTER_ARRAY_DATA *data = MYSELF->character_array.data;
    ARRAY_INFO *info = data->info;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, data->info);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_character_array_updates(MYSELF);
      uint32_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_uchar32(value));
    } else {
      // set item
      uint32_t value;
      CHECK(to_uchar32(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->character_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE));
      UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE *)
	(MYSELF->character_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::character_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->character_array.data->info, indent, buf, "uchar32");
  }

METHOD long std_types::character_array/length_of
  #
    implements the *length_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    CHARACTER_ARRAY_DATA *data = ARGUMENTS(0)->character_array.data;
    ARRAY_INFO *info = data->info;
    if (info->dimension_count == 1) {
      RETURN_SINGLE_RESULT(from_long(info->dimensions[0]))
    } else {
      RETURN_UNDEFINED
    }
  }

METHOD std_types::character_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    CHARACTER_ARRAY_DATA *left = apply_character_array_updates(ARGUMENTS(0));
    CHARACTER_ARRAY_DATA *right = apply_character_array_updates(ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(uint32_t)*left->size) == 0)
  }

FUNCTION std::character_array
  #
    constructs an empty array

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(1)
    CHARACTER_ARRAY_DATA *data = (CHARACTER_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::character_array, 0, data, NULL))
  }

FUNCTION std::initialized_character_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(2)
    CHARACTER_ARRAY_DATA *data = (CHARACTER_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(uint32_t));
    if (!data) return;
    uint32_t initial_value;
    CHECK(to_uchar32(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::character_array, 0, data, NULL))
  }

#######
# ARRAY OF SIGNED 8-BIT NUMBERS
#

RECORD INT8_ARRAY_DATA
  ARRAY_INFO *info
  long size
  int8_t items[]

UNION UPDATE_INT8_ARRAY_DATA/SET_VALUE
  long offset
  int8_t value

TYPE std_types::int8_array -> std_types::generic_array
  # an array of signed 8-bit numbers
  long updates_length
  INT8_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static INT8_ARRAY_DATA *apply_int8_array_updates(NODE *node)
    {
      INT8_ARRAY_DATA *data = node->int8_array.data;
      ARRAY_INFO *info = data->info;
      long size = data->size;
      if (node->int8_array.updates_length > 0) {
	// copy items
	data = allocate_large(
	  ALLOCATION_SIZE(sizeof(INT8_ARRAY_DATA)+size*sizeof(int8_t)));
	memcpy(
	  data->items,
	  node->int8_array.data->items,
	  size*sizeof(int8_t));
	// apply updates
	char *update = node->int8_array.updates->buffer;
	char *end_p = update+node->int8_array.updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_INT8_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_INT8_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	data->info = info;
	data->size = size;
	node->int8_array.updates_length = 0;
	node->int8_array.data = data;
	node->int8_array.updates = NULL;
      }
      return data;
    }

METHOD std_types::int8_array/_type
  {
    INT8_ARRAY_DATA *data = MYSELF->int8_array.data;
    ARRAY_INFO *info = data->info;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, data->info);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_int8_array_updates(MYSELF);
      int8_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_int8(value));
    } else {
      // set item
      int8_t value;
      CHECK(to_int8(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->int8_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_INT8_ARRAY_DATA_SET_VALUE));
      UPDATE_INT8_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_INT8_ARRAY_DATA_SET_VALUE *)
	(MYSELF->int8_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::int8_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int8_array.data->info, indent, buf, "int8");
  }

METHOD long std_types::int8_array/length_of
  #
    implements the *length_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT8_ARRAY_DATA *data = ARGUMENTS(0)->int8_array.data;
    ARRAY_INFO *info = data->info;
    if (info->dimension_count == 1) {
      RETURN_SINGLE_RESULT(from_long(info->dimensions[0]))
    } else {
      RETURN_UNDEFINED
    }
  }

METHOD std_types::int8_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    INT8_ARRAY_DATA *left = apply_int8_array_updates(ARGUMENTS(0));
    INT8_ARRAY_DATA *right = apply_int8_array_updates(ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(int8_t)*left->size) == 0)
  }

FUNCTION std::int8_array
  #
    constructs an empty array

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(1)
    INT8_ARRAY_DATA *data = (INT8_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(int8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int8_array, 0, data, NULL))
  }

FUNCTION std::initialized_int8_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(2)
    INT8_ARRAY_DATA *data = (INT8_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(int8_t));
    if (!data) return;
    int8_t initial_value;
    CHECK(to_int8(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int8_array, 0, data, NULL))
  }

#######
# ARRAY OF UNSIGNED 8-BIT NUMBERS
#

RECORD UINT8_ARRAY_DATA
  ARRAY_INFO *info
  long size
  uint8_t items[]

UNION UPDATE_UINT8_ARRAY_DATA/SET_VALUE
  long offset
  uint8_t value

TYPE std_types::uint8_array -> std_types::generic_array
  # an array of unsigned 8-bit numbers
  long updates_length
  UINT8_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static UINT8_ARRAY_DATA *apply_uint8_array_updates(NODE *node)
    {
      UINT8_ARRAY_DATA *data = node->uint8_array.data;
      ARRAY_INFO *info = data->info;
      long size = data->size;
      if (node->uint8_array.updates_length > 0) {
	// copy items
	data = allocate_large(
	  ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
	memcpy(
	  data->items,
	  node->uint8_array.data->items,
	  size*sizeof(uint8_t));
	// apply updates
	char *update = node->uint8_array.updates->buffer;
	char *end_p = update+node->uint8_array.updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_UINT8_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_UINT8_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	data->info = info;
	data->size = size;
	node->uint8_array.updates_length = 0;
	node->uint8_array.data = data;
	node->uint8_array.updates = NULL;
      }
      return data;
    }

METHOD std_types::uint8_array/_type
  {
    UINT8_ARRAY_DATA *data = MYSELF->uint8_array.data;
    ARRAY_INFO *info = data->info;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, data->info);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_uint8_array_updates(MYSELF);
      uint8_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_uint8(value));
    } else {
      // set item
      uint8_t value;
      CHECK(to_uint8(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->uint8_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_UINT8_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT8_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_UINT8_ARRAY_DATA_SET_VALUE *)
	(MYSELF->uint8_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::uint8_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint8_array.data->info, indent, buf, "uint8");
  }

METHOD long std_types::uint8_array/length_of
  #
    implements the *length_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT8_ARRAY_DATA *data = ARGUMENTS(0)->uint8_array.data;
    ARRAY_INFO *info = data->info;
    if (info->dimension_count == 1) {
      RETURN_SINGLE_RESULT(from_long(info->dimensions[0]))
    } else {
      RETURN_UNDEFINED
    }
  }

METHOD std_types::uint8_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates(ARGUMENTS(0));
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates(ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(uint8_t)*left->size) == 0)
  }
METHOD std_types::uint8_array/bit_and
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates(ARGUMENTS(0));
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates(ARGUMENTS(1));
    long size = left->size;
    UINT8_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0, data, NULL))
  }

METHOD std_types::uint8_array/bit_or
  #
    implements the *or* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates(ARGUMENTS(0));
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates(ARGUMENTS(1));
    long size = left->size;
    UINT8_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0, data, NULL))
  }

METHOD std_types::uint8_array/bit_xor
  #
    implements the *xor* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates(ARGUMENTS(0));
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates(ARGUMENTS(1));
    long size = left->size;
    UINT8_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0, data, NULL))
  }

FUNCTION std::uint8_array
  #
    constructs an empty array

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(1)
    UINT8_ARRAY_DATA *data = (UINT8_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(uint8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0, data, NULL))
  }

FUNCTION std::initialized_uint8_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(2)
    UINT8_ARRAY_DATA *data = (UINT8_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(uint8_t));
    if (!data) return;
    uint8_t initial_value;
    CHECK(to_uint8(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0, data, NULL))
  }

#######
# ARRAY OF SIGNED 16-BIT NUMBERS
#

RECORD INT16_ARRAY_DATA
  ARRAY_INFO *info
  long size
  int16_t items[]

UNION UPDATE_INT16_ARRAY_DATA/SET_VALUE
  long offset
  int16_t value

TYPE std_types::int16_array -> std_types::generic_array
  # an array of signed 16-bit numbers
  long updates_length
  INT16_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static INT16_ARRAY_DATA *apply_int16_array_updates(NODE *node)
    {
      INT16_ARRAY_DATA *data = node->int16_array.data;
      ARRAY_INFO *info = data->info;
      long size = data->size;
      if (node->int16_array.updates_length > 0) {
	// copy items
	data = allocate_large(
	  ALLOCATION_SIZE(sizeof(INT16_ARRAY_DATA)+size*sizeof(int16_t)));
	memcpy(
	  data->items,
	  node->int16_array.data->items,
	  size*sizeof(int16_t));
	// apply updates
	char *update = node->int16_array.updates->buffer;
	char *end_p = update+node->int16_array.updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_INT16_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_INT16_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	data->info = info;
	data->size = size;
	node->int16_array.updates_length = 0;
	node->int16_array.data = data;
	node->int16_array.updates = NULL;
      }
      return data;
    }

METHOD std_types::int16_array/_type
  {
    INT16_ARRAY_DATA *data = MYSELF->int16_array.data;
    ARRAY_INFO *info = data->info;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, data->info);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_int16_array_updates(MYSELF);
      int16_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_int16(value));
    } else {
      // set item
      int16_t value;
      CHECK(to_int16(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->int16_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_INT16_ARRAY_DATA_SET_VALUE));
      UPDATE_INT16_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_INT16_ARRAY_DATA_SET_VALUE *)
	(MYSELF->int16_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::int16_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int16_array.data->info, indent, buf, "int16");
  }

METHOD long std_types::int16_array/length_of
  #
    implements the *length_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT16_ARRAY_DATA *data = ARGUMENTS(0)->int16_array.data;
    ARRAY_INFO *info = data->info;
    if (info->dimension_count == 1) {
      RETURN_SINGLE_RESULT(from_long(info->dimensions[0]))
    } else {
      RETURN_UNDEFINED
    }
  }

METHOD std_types::int16_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    INT16_ARRAY_DATA *left = apply_int16_array_updates(ARGUMENTS(0));
    INT16_ARRAY_DATA *right = apply_int16_array_updates(ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(int16_t)*left->size) == 0)
  }

FUNCTION std::int16_array
  #
    constructs an empty array

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(1)
    INT16_ARRAY_DATA *data = (INT16_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(int16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int16_array, 0, data, NULL))
  }

FUNCTION std::initialized_int16_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(2)
    INT16_ARRAY_DATA *data = (INT16_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(int16_t));
    if (!data) return;
    int16_t initial_value;
    CHECK(to_int16(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int16_array, 0, data, NULL))
  }

#######
# ARRAY OF UNSIGNED 16-BIT NUMBERS
#

RECORD UINT16_ARRAY_DATA
  ARRAY_INFO *info
  long size
  uint16_t items[]

UNION UPDATE_UINT16_ARRAY_DATA/SET_VALUE
  long offset
  uint16_t value

TYPE std_types::uint16_array -> std_types::generic_array
  # an array of unsigned 16-bit numbers
  long updates_length
  UINT16_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static UINT16_ARRAY_DATA *apply_uint16_array_updates(NODE *node)
    {
      UINT16_ARRAY_DATA *data = node->uint16_array.data;
      ARRAY_INFO *info = data->info;
      long size = data->size;
      if (node->uint16_array.updates_length > 0) {
	// copy items
	data = allocate_large(
	  ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
	memcpy(
	  data->items,
	  node->uint16_array.data->items,
	  size*sizeof(uint16_t));
	// apply updates
	char *update = node->uint16_array.updates->buffer;
	char *end_p = update+node->uint16_array.updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_UINT16_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_UINT16_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	data->info = info;
	data->size = size;
	node->uint16_array.updates_length = 0;
	node->uint16_array.data = data;
	node->uint16_array.updates = NULL;
      }
      return data;
    }

METHOD std_types::uint16_array/_type
  {
    UINT16_ARRAY_DATA *data = MYSELF->uint16_array.data;
    ARRAY_INFO *info = data->info;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, data->info);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_uint16_array_updates(MYSELF);
      uint16_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_uint16(value));
    } else {
      // set item
      uint16_t value;
      CHECK(to_uint16(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->uint16_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_UINT16_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT16_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_UINT16_ARRAY_DATA_SET_VALUE *)
	(MYSELF->uint16_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::uint16_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint16_array.data->info, indent, buf, "uint16");
  }

METHOD long std_types::uint16_array/length_of
  #
    implements the *length_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT16_ARRAY_DATA *data = ARGUMENTS(0)->uint16_array.data;
    ARRAY_INFO *info = data->info;
    if (info->dimension_count == 1) {
      RETURN_SINGLE_RESULT(from_long(info->dimensions[0]))
    } else {
      RETURN_UNDEFINED
    }
  }

METHOD std_types::uint16_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates(ARGUMENTS(0));
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates(ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(uint16_t)*left->size) == 0)
  }
METHOD std_types::uint16_array/bit_and
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates(ARGUMENTS(0));
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates(ARGUMENTS(1));
    long size = left->size;
    UINT16_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0, data, NULL))
  }

METHOD std_types::uint16_array/bit_or
  #
    implements the *or* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates(ARGUMENTS(0));
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates(ARGUMENTS(1));
    long size = left->size;
    UINT16_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0, data, NULL))
  }

METHOD std_types::uint16_array/bit_xor
  #
    implements the *xor* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates(ARGUMENTS(0));
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates(ARGUMENTS(1));
    long size = left->size;
    UINT16_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0, data, NULL))
  }

FUNCTION std::uint16_array
  #
    constructs an empty array

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(1)
    UINT16_ARRAY_DATA *data = (UINT16_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(uint16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0, data, NULL))
  }

FUNCTION std::initialized_uint16_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(2)
    UINT16_ARRAY_DATA *data = (UINT16_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(uint16_t));
    if (!data) return;
    uint16_t initial_value;
    CHECK(to_uint16(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0, data, NULL))
  }

#######
# ARRAY OF SIGNED 32-BIT NUMBERS
#

RECORD INT32_ARRAY_DATA
  ARRAY_INFO *info
  long size
  int32_t items[]

UNION UPDATE_INT32_ARRAY_DATA/SET_VALUE
  long offset
  int32_t value

TYPE std_types::int32_array -> std_types::generic_array
  # an array of signed 32-bit numbers
  long updates_length
  INT32_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static INT32_ARRAY_DATA *apply_int32_array_updates(NODE *node)
    {
      INT32_ARRAY_DATA *data = node->int32_array.data;
      ARRAY_INFO *info = data->info;
      long size = data->size;
      if (node->int32_array.updates_length > 0) {
	// copy items
	data = allocate_large(
	  ALLOCATION_SIZE(sizeof(INT32_ARRAY_DATA)+size*sizeof(int32_t)));
	memcpy(
	  data->items,
	  node->int32_array.data->items,
	  size*sizeof(int32_t));
	// apply updates
	char *update = node->int32_array.updates->buffer;
	char *end_p = update+node->int32_array.updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_INT32_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_INT32_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	data->info = info;
	data->size = size;
	node->int32_array.updates_length = 0;
	node->int32_array.data = data;
	node->int32_array.updates = NULL;
      }
      return data;
    }

METHOD std_types::int32_array/_type
  {
    INT32_ARRAY_DATA *data = MYSELF->int32_array.data;
    ARRAY_INFO *info = data->info;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, data->info);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_int32_array_updates(MYSELF);
      int32_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_int32(value));
    } else {
      // set item
      int32_t value;
      CHECK(to_int32(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->int32_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_INT32_ARRAY_DATA_SET_VALUE));
      UPDATE_INT32_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_INT32_ARRAY_DATA_SET_VALUE *)
	(MYSELF->int32_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::int32_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int32_array.data->info, indent, buf, "int32");
  }

METHOD long std_types::int32_array/length_of
  #
    implements the *length_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT32_ARRAY_DATA *data = ARGUMENTS(0)->int32_array.data;
    ARRAY_INFO *info = data->info;
    if (info->dimension_count == 1) {
      RETURN_SINGLE_RESULT(from_long(info->dimensions[0]))
    } else {
      RETURN_UNDEFINED
    }
  }

METHOD std_types::int32_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    INT32_ARRAY_DATA *left = apply_int32_array_updates(ARGUMENTS(0));
    INT32_ARRAY_DATA *right = apply_int32_array_updates(ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(int32_t)*left->size) == 0)
  }

FUNCTION std::int32_array
  #
    constructs an empty array

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(1)
    INT32_ARRAY_DATA *data = (INT32_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(int32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int32_array, 0, data, NULL))
  }

FUNCTION std::initialized_int32_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(2)
    INT32_ARRAY_DATA *data = (INT32_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(int32_t));
    if (!data) return;
    int32_t initial_value;
    CHECK(to_int32(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int32_array, 0, data, NULL))
  }

#######
# ARRAY OF UNSIGNED 32-BIT NUMBERS
#

RECORD UINT32_ARRAY_DATA
  ARRAY_INFO *info
  long size
  uint32_t items[]

UNION UPDATE_UINT32_ARRAY_DATA/SET_VALUE
  long offset
  uint32_t value

TYPE std_types::uint32_array -> std_types::generic_array
  # an array of unsigned 32-bit numbers
  long updates_length
  UINT32_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static UINT32_ARRAY_DATA *apply_uint32_array_updates(NODE *node)
    {
      UINT32_ARRAY_DATA *data = node->uint32_array.data;
      ARRAY_INFO *info = data->info;
      long size = data->size;
      if (node->uint32_array.updates_length > 0) {
	// copy items
	data = allocate_large(
	  ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
	memcpy(
	  data->items,
	  node->uint32_array.data->items,
	  size*sizeof(uint32_t));
	// apply updates
	char *update = node->uint32_array.updates->buffer;
	char *end_p = update+node->uint32_array.updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_UINT32_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_UINT32_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	data->info = info;
	data->size = size;
	node->uint32_array.updates_length = 0;
	node->uint32_array.data = data;
	node->uint32_array.updates = NULL;
      }
      return data;
    }

METHOD std_types::uint32_array/_type
  {
    UINT32_ARRAY_DATA *data = MYSELF->uint32_array.data;
    ARRAY_INFO *info = data->info;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, data->info);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_uint32_array_updates(MYSELF);
      uint32_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_uint32(value));
    } else {
      // set item
      uint32_t value;
      CHECK(to_uint32(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->uint32_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_UINT32_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT32_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_UINT32_ARRAY_DATA_SET_VALUE *)
	(MYSELF->uint32_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::uint32_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint32_array.data->info, indent, buf, "uint32");
  }

METHOD long std_types::uint32_array/length_of
  #
    implements the *length_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT32_ARRAY_DATA *data = ARGUMENTS(0)->uint32_array.data;
    ARRAY_INFO *info = data->info;
    if (info->dimension_count == 1) {
      RETURN_SINGLE_RESULT(from_long(info->dimensions[0]))
    } else {
      RETURN_UNDEFINED
    }
  }

METHOD std_types::uint32_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates(ARGUMENTS(0));
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates(ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(uint32_t)*left->size) == 0)
  }
METHOD std_types::uint32_array/bit_and
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates(ARGUMENTS(0));
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates(ARGUMENTS(1));
    long size = left->size;
    UINT32_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0, data, NULL))
  }

METHOD std_types::uint32_array/bit_or
  #
    implements the *or* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates(ARGUMENTS(0));
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates(ARGUMENTS(1));
    long size = left->size;
    UINT32_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0, data, NULL))
  }

METHOD std_types::uint32_array/bit_xor
  #
    implements the *xor* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates(ARGUMENTS(0));
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates(ARGUMENTS(1));
    long size = left->size;
    UINT32_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0, data, NULL))
  }

FUNCTION std::uint32_array
  #
    constructs an empty array

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(1)
    UINT32_ARRAY_DATA *data = (UINT32_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0, data, NULL))
  }

FUNCTION std::initialized_uint32_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(2)
    UINT32_ARRAY_DATA *data = (UINT32_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(uint32_t));
    if (!data) return;
    uint32_t initial_value;
    CHECK(to_uint32(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0, data, NULL))
  }

#######
# ARRAY OF SIGNED 64-BIT NUMBERS
#

RECORD INT64_ARRAY_DATA
  ARRAY_INFO *info
  long size
  int64_t items[]

UNION UPDATE_INT64_ARRAY_DATA/SET_VALUE
  long offset
  int64_t value

TYPE std_types::int64_array -> std_types::generic_array
  # an array of signed 64-bit numbers
  long updates_length
  INT64_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static INT64_ARRAY_DATA *apply_int64_array_updates(NODE *node)
    {
      INT64_ARRAY_DATA *data = node->int64_array.data;
      ARRAY_INFO *info = data->info;
      long size = data->size;
      if (node->int64_array.updates_length > 0) {
	// copy items
	data = allocate_large(
	  ALLOCATION_SIZE(sizeof(INT64_ARRAY_DATA)+size*sizeof(int64_t)));
	memcpy(
	  data->items,
	  node->int64_array.data->items,
	  size*sizeof(int64_t));
	// apply updates
	char *update = node->int64_array.updates->buffer;
	char *end_p = update+node->int64_array.updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_INT64_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_INT64_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	data->info = info;
	data->size = size;
	node->int64_array.updates_length = 0;
	node->int64_array.data = data;
	node->int64_array.updates = NULL;
      }
      return data;
    }

METHOD std_types::int64_array/_type
  {
    INT64_ARRAY_DATA *data = MYSELF->int64_array.data;
    ARRAY_INFO *info = data->info;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, data->info);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_int64_array_updates(MYSELF);
      int64_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_int64(value));
    } else {
      // set item
      int64_t value;
      CHECK(to_int64(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->int64_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_INT64_ARRAY_DATA_SET_VALUE));
      UPDATE_INT64_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_INT64_ARRAY_DATA_SET_VALUE *)
	(MYSELF->int64_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::int64_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int64_array.data->info, indent, buf, "int64");
  }

METHOD long std_types::int64_array/length_of
  #
    implements the *length_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT64_ARRAY_DATA *data = ARGUMENTS(0)->int64_array.data;
    ARRAY_INFO *info = data->info;
    if (info->dimension_count == 1) {
      RETURN_SINGLE_RESULT(from_long(info->dimensions[0]))
    } else {
      RETURN_UNDEFINED
    }
  }

METHOD std_types::int64_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    INT64_ARRAY_DATA *left = apply_int64_array_updates(ARGUMENTS(0));
    INT64_ARRAY_DATA *right = apply_int64_array_updates(ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(int64_t)*left->size) == 0)
  }

FUNCTION std::int64_array
  #
    constructs an empty array

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(1)
    INT64_ARRAY_DATA *data = (INT64_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(int64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int64_array, 0, data, NULL))
  }

FUNCTION std::initialized_int64_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(2)
    INT64_ARRAY_DATA *data = (INT64_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(int64_t));
    if (!data) return;
    int64_t initial_value;
    CHECK(to_int64(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int64_array, 0, data, NULL))
  }

#######
# ARRAY OF UNSIGNED 64-BIT NUMBERS
#

RECORD UINT64_ARRAY_DATA
  ARRAY_INFO *info
  long size
  uint64_t items[]

UNION UPDATE_UINT64_ARRAY_DATA/SET_VALUE
  long offset
  uint64_t value

TYPE std_types::uint64_array -> std_types::generic_array
  # an array of unsigned 64-bit numbers
  long updates_length
  UINT64_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static UINT64_ARRAY_DATA *apply_uint64_array_updates(NODE *node)
    {
      UINT64_ARRAY_DATA *data = node->uint64_array.data;
      ARRAY_INFO *info = data->info;
      long size = data->size;
      if (node->uint64_array.updates_length > 0) {
	// copy items
	data = allocate_large(
	  ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
	memcpy(
	  data->items,
	  node->uint64_array.data->items,
	  size*sizeof(uint64_t));
	// apply updates
	char *update = node->uint64_array.updates->buffer;
	char *end_p = update+node->uint64_array.updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_UINT64_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_UINT64_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	data->info = info;
	data->size = size;
	node->uint64_array.updates_length = 0;
	node->uint64_array.data = data;
	node->uint64_array.updates = NULL;
      }
      return data;
    }

METHOD std_types::uint64_array/_type
  {
    UINT64_ARRAY_DATA *data = MYSELF->uint64_array.data;
    ARRAY_INFO *info = data->info;
    int dimension_count = info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    long offset = compute_array_offset(MYSELF, data->info);
    if (offset < 0) return;
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_uint64_array_updates(MYSELF);
      uint64_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_uint64(value));
    } else {
      // set item
      uint64_t value;
      CHECK(to_uint64(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->uint64_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_UINT64_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT64_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_UINT64_ARRAY_DATA_SET_VALUE *)
	(MYSELF->uint64_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::uint64_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint64_array.data->info, indent, buf, "uint64");
  }

METHOD long std_types::uint64_array/length_of
  #
    implements the *length_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT64_ARRAY_DATA *data = ARGUMENTS(0)->uint64_array.data;
    ARRAY_INFO *info = data->info;
    if (info->dimension_count == 1) {
      RETURN_SINGLE_RESULT(from_long(info->dimensions[0]))
    } else {
      RETURN_UNDEFINED
    }
  }

METHOD std_types::uint64_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates(ARGUMENTS(0));
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates(ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(uint64_t)*left->size) == 0)
  }
METHOD std_types::uint64_array/bit_and
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates(ARGUMENTS(0));
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates(ARGUMENTS(1));
    long size = left->size;
    UINT64_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0, data, NULL))
  }

METHOD std_types::uint64_array/bit_or
  #
    implements the *or* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates(ARGUMENTS(0));
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates(ARGUMENTS(1));
    long size = left->size;
    UINT64_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0, data, NULL))
  }

METHOD std_types::uint64_array/bit_xor
  #
    implements the *xor* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates(ARGUMENTS(0));
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates(ARGUMENTS(1));
    long size = left->size;
    UINT64_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0, data, NULL))
  }

FUNCTION std::uint64_array
  #
    constructs an empty array

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(1)
    UINT64_ARRAY_DATA *data = (UINT64_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT, sizeof(uint64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0, data, NULL))
  }

FUNCTION std::initialized_uint64_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std_types::list/new
  {
    MIN_ARGUMENTS(2)
    UINT64_ARRAY_DATA *data = (UINT64_ARRAY_DATA *)
      allocate_array_data(ARGUMENT_COUNT-1, sizeof(uint64_t));
    if (!data) return;
    uint64_t initial_value;
    CHECK(to_uint64(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0, data, NULL))
  }
