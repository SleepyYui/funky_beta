#
  Copyright (C) 2024 by
  Dipl.-Ing. Michael Niederle

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License, version 2, or
  (at your option) version 3.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  For details of the GNU General Public License see the accompanying
  files GPLv2.txt and GLPv3.txt or
  http://www.gnu.org/licenses/gpl-2.0.html
  http://www.gnu.org/licenses/gpl-3.0.html
  or write to the
  Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

<namespace terminal_private>

<require ./keys>

#
  Topic: Terminal

  The terminal library offers an interface for using text-terminals in a
  comfortable way.

  The base data type is the <std_types::screen>, a rectangular array of
  characters and associated fore- and background colors.

  All coordinates are one-based.

  Each colour supports 256 shades of red, green and blue.

  To update the state of a <std_types::screen> or <std_types::terminal) no
  I/O-acccess rights are necessary.

  There are methods to set fore- and background colors, to draw text, lines
  or more complex shapes, to clear the screen or parts of it, to scroll the
  screen or copy arbitrary rectangular areas between screens ("blitting").

  Horizontal and vertical lines are drawn using the appropriate unicode graphics
  characters.

  Screens and terminals also support Unicode Emojis.

  The terminal library is somewhat similar to the curses library. It tries to
  update the contents of a terminal in a smart way.

  To start using the functions of this library one must first create a
  <std_types::terminal> object (see <create_terminal>) supplying the
  terminal's width and height. The current terminal size can be retrieved via
  the I/O-function <get_terminal_size>.

  As an alternative one can use the high-level function <initialize_terminal>.
  When using this function one gets automatic cleanup "for free".

  For more details about colour handling see <@Colours>.

  Topic: Terminal

  See also: @Input-Output, @Colours

  Example:

      <require basic/stdlib>
      <require terminal/terminal>

      get_terminal_size! STDIN_FILENO $width $height
      create_terminal $terminal width height
      draw_text &terminal 10 5 "Hello, world!"
      update_terminal &terminal $output # create output character stream
      print! output # print the generated character stream

  Example:

    <require basic/stdlib>
    <require terminal/terminal>

    initialize_terminal!: (terminal)
      draw_text &terminal 10 5 "Hello, world!"
      update_terminal &terminal $output # create output character stream
      print! output # print the generated character stream

#
  Topic: Colours

  The <@Terminal> library uses <std_types::character>s for text and background
  colours.

  See also: @Terminal

$std::resize ()
  #
    resizes a screen or terminal

    Parameters:
      screen # some kind of screen
      new_width # new width of the screen
      new_height # new height of the screen

    Result:
      screen # the resized screen

    Topic: Terminal

    See also: clear, copy, scroll_up, scroll_down, scroll_left, scroll_right

$std::define_window ()
  #
    defines a rectangular area as the current drawing area

    Parameters:
      screen # some kind of screen
      left_x # left border of the window
      top_y # top border of the window
      right_x # right border of the window
      bottom_y # bottom border of the window

    Result:
      screen # the screen with the defined window

    All coordinates are "inclusive".

    Topic: Terminal

    See also: draw_text, draw_character

$std::set_cursor ()
  #
    sets the current cursor position

    Parameters:
      screen # some kind of screen
      x # x-coordinate of the cursor
      y # y-coordinate of the cursor

    Result:
      screen # the screen with the updated cursor position


$std::set_character_at ()
  #
    sets the character at the given position

    Parameters:
      screen # some kind of screen
      x # x-coordinate of the character
      y # y-coordinate of the character
      chr # the character to set

    Result:
      screen # the screen with the updated character

    This is a low-level method. It ignores the current window and does not
    change the fore- and background color.

    Topic: Terminal

    See also: set_text_colour_at, set_background_colour_at, draw_character

    Example:

      set_character_at &screen x y '+'

$std::set_text_colour_at ()
  #
    sets the foreground color at the given position

    Parameters:
      screen # some kind of screen
      x # x-coordinate of the character
      y # y-coordinate of the character
      colour # the colour to use as the new foreground colour

    Result:
      screen # the updated screen

    This is a low-level method. It ignores the current window and does not
    change the character and the background colour.

    Topic: Terminal

    See also: set_character_at, set_background_colour_at, draw_character

    Example:

      set_text_colour_at &screen x y RED

$std::set_background_colour_at ()
  #
    sets the background colour at the given position

    Parameters:
      screen # some kind of screen
      x # x-coordinate of the character
      y # y-coordinate of the character
      colour # the colour to use as the new background colour

    Result:
      screen # the updated screen

    This is a low-level method. It ignores the current window and does not
    change the character and the foreground colour.

    Topic: Terminal

    See also: set_character_at, set_text_colour_at, draw_character

    Example:

      set_background_colour_at &screen x y YELLOW

$std::draw_character ()
  #
    draws a character at the given position

    Parameters:
      screen # some kind of screen
      x # x-coordinate of the character
      y # y-coordinate of the character
      chr # the character to draw

    Result:
      screen # the updated screen

    This method uses the current foreground and background colour and obeyes
    the current window.

    Topic: Terminal

    See also: draw_text, set_character_at, set_text_colour_at,
	      set_background_colour_at

    Example:

      draw_character &screen x y '+'

$std::draw_text ()
  #
    draws text at the given position

    Parameters:
      screen # some kind of screen
      x # x-coordinate of the first character
      y # y-coordinate of the first character
      args* # the text to draw

    Result:
      screen # the updated screen

    All *args* are converted to strings and concatenated.

    This method uses the current foreground and background colour and obeyes
    the current window.

    If the text consists of multiple lines, the cursor is moved back to *x*
    after each line.

    Topic: Terminal

    See also: draw_character, set_text_colour_at, set_background_colour_at

    Example:

      draw_text &screen x y "Hello World!"

$std::draw_attributed_text ()
  #
    draws text with given fore- and background colours

    Parameters:
      screen # some kind of screen
      x # x-coordinate of the first character
      y # y-coordinate of the first character
      attributed_text # the text to draw

    Result:
      screen # the updated screen

    The *attributed_text* must not contain newline characters. Each character is
    a triple consisting of *character*, *text colour* and *background colour*.

    The text and background colours are themself character values.

    Topic: Terminal

    See also: draw_text, set_character_at, set_text_colour_at,
	      set_background_colour_at

$std::draw_line ()
  #
    draws a horizontal or vertical line

    Parameters:
      screen # some kind of screen
      x1 # x-coordinate of the start of the line
      y1 # y-coordinate of the start of the line
      x2 # x-coordinate of the end of the line
      y2 # y-coordinate of the end of the line

    Result:
      screen # the updated screen

    The line is drawn using the appropriate unicode graphics characters and uses
    the current text colour.

    Either *x1* and *x2* or *y1* and *y2* must be equal.

    Topic: Terminal

    Example:

      draw_line &screen 1 1 10 1

$std::draw_rectangle ()
  #
    draws a rectangle

    Parameters:
      screen # some kind of screen
      x1 # x-coordinate of one corner of the rectangle
      y1 # y-coordinate of one corner of the rectangle
      x2 # x-coordinate of the opposite corner of the rectangle
      y2 # y-coordinate of the opposite corner of the rectangle

    Result:
      screen # the updated screen

    The rectangle is drawn using the appropriate unicode graphics characters and
    uses the current text colour.

    Topic: Terminal

    Example:

      draw_rectangle &screen 1 1 10 10

$std::plot ()

$std::plot_line ()

$std::fill_trapezoid ()

$std::set_text_colour ()

$std::set_background_colour ()

$std::clear ()

$std::copy ()

$std::scroll_left ()

$std::scroll_right ()

$std::scroll_up ()

$std::scroll_down ()

$std::left_x_of ()

$std::right_x_of ()

$std::top_y_of ()

$std::bottom_y_of ()

$std::cursor_x_of (!)

$std::cursor_y_of (!)

$std::height_of (!)

$std::text_colour_of (!)

$std::background_colour_of (!)

$rows_of (!)
$line_height_of (!)

$has_a_visible_cursor (!)
  #
    returns true if the terminal has a visible cursor

    Topic: Terminal

$current_buffer_of (!)

$std::red_component_of (!)
  #
    the red component of a colour

    Topic: Colours

    See also: green_component_of, blue_component_of

    Parameters:
      colour # the colour (character)

$std::green_component_of (!)
  #
    the green component of a colour

    Topic: Colours

    See also: red_component_of, blue_component_of

    Parameters:
      colour # the colour (character)

$std::blue_component_of (!)
  #
    the blue component of a colour

    Topic: Colours

    See also: red_component_of, green_component_of

    Parameters:
      colour # the colour (character)

$std::TEXT_COLOUR .
  #
    the text colour option used in <create_screen> and <create_terminal>

    Topic: Terminal

    See also: create_terminal

$std::BACKGROUND_COLOUR .
  #
    the background colour option used in <create_screen> and <create_terminal>

    Topic: Terminal

$std::LINE_HEIGHT .
  #
    the line height option used in <create_screen> and <create_terminal>

    Topic: Terminal

    See also: create_terminal

$std::VISIBLE_CURSOR .
  #
    the option to make the cursor visible in <create_terminal>

    Topic: Terminal

    See also: create_terminal

$std::BLACK '@0x000000;'
  #
    the colour black as used by the terminal library

    Topic: Colours

    See also: WHITE, RED, GREEN, BLUE, CYAN, MAGENTA, YELLOW, GREY

$std::WHITE '@0xffffff;'
  #
    the colour white as used by the terminal library

    Topic: Colours

    See also: BLACK, RED, GREEN, BLUE, CYAN, MAGENTA, YELLOW, GREY

$std::RED '@0xff0000;'
  #
    the colour red as used by the terminal library

    Topic: Colours

    See also: BLACK, WHITE, GREEN, BLUE, CYAN, MAGENTA, YELLOW, GREY

$std::GREEN '@0x00ff00;'
  #
    the colour green as used by the terminal library

    Topic: Colours

    See also: BLACK, WHITE, RED, BLUE, CYAN, MAGENTA, YELLOW, GREY

$std::BLUE '@0x0000ff;'
  #
    the colour blue as used by the terminal library

    Topic: Colours

    See also: BLACK, WHITE, RED, GREEN, CYAN, MAGENTA, YELLOW, GREY

$std::CYAN '@0x00ffff;'
  #
    the colour cyan as used by the terminal library

    Topic: Colours

    See also: BLACK, WHITE, RED, GREEN, BLUE, MAGENTA, YELLOW, GREY

$std::MAGENTA '@0xff00ff;'
  #
    the colour magenta as used by the terminal library

    Topic: Colours

    See also: BLACK, WHITE, RED, GREEN, BLUE, CYAN, YELLOW, GREY

$std::YELLOW '@0xffff00;'
  #
    the colour yellow as used by the terminal library

    Topic: Colours

    See also: BLACK, WHITE, RED, GREEN, BLUE, CYAN, MAGENTA, GREY

$std::GREY '@0x808080;'
  #
    the colour grey as used by the terminal library

    Topic: Colours

    See also: BLACK, WHITE, RED, GREEN, BLUE, CYAN, MAGENTA, YELLOW

$INVALID_COLOUR '@0xffffffff;'

$std_types::screen std_types::object
  #
    the prototype objects for all screens

    Topic: Terminal

    See also: create_screen

$std_types::screen.serialization_tag_of "screen"
  #
    the tag used to serialize a <std_types::screen> object

    Topic: Terminal

    See also:
      std_types::screen/serialization_fields_of,
      std_types::terminal/serialization_tag_of

$std_types::screen.serialization_fields_of
  #
    the serialized fields of a <std_types::screen> object

    Topic: Terminal

    See also:
      std_types::screen/serialization_tag_of,
      std_types::terminal/serialization_fields_of
  list
    `rows_of
    `cursor_x_of
    `cursor_y_of
    `std::width_of
    `std::height_of
    `text_colour_of
    `background_colour_of
    `line_height_of

$std_types::terminal std_types::screen
  #
    the prototype objects for all terminals

    To create a terminal object call <create_terminal>.

    Topic: Terminal

    See also: create_terminal

$std_types::terminal.serialization_tag_of "terminal"
  #
    the tag used to serialize a <std_types::terminal> object

    Topic: Terminal

    See also:
      std_types::terminal/serialization_fields_of,
      std_types::screen/serialization_tag_of

$std_types::terminal.serialization_fields_of
  #
    the serialized fields of a <std_types::terminal> object

    Topic: Terminal

    See also:
      std_types::terminal/serialization_tag_of,
      std_types::screen/serialization_fields_of
  list
    `rows_of
    `cursor_x_of
    `cursor_y_of
    `std::width_of
    `std::height_of
    `text_colour_of
    `background_colour_of
    `line_height_of
    `has_a_visible_cursor
    `current_buffer_of

$std::create_screen:
  #
    creates a logical screen

    A screen contains the character codes, text and background colours for all
    characters.

    Column and row numbers start with 1!

    Available options are:

    * <TEXT_COLOUR> (default: <BLACK>)

    * <BACKGROUND_COLOUR> (default: <WHITE>)

    * <LINE_HEIGHT> (default: 1)

    Topic: Terminal

    See also: create_terminal, std_types::screen
  (
    width # the number of columns
    height # the number of rows
    options* # optional screen attributes
  )
  extract_options options
    TEXT_COLOUR = BLACK $text_colour
    BACKGROUND_COLOUR = WHITE $background_colour
    LINE_HEIGHT = 1 $line_height
  $row dup(string(' ' text_colour background_colour) width)
  $rows dup(list(row) height)
  ->
    std_types::screen
      .cursor_x_of 1
      .cursor_y_of 1
      .width_of width
      .height_of height
      .left_x_of 1
      .top_y_of 1
      .right_x_of width
      .bottom_y_of height
      .text_colour_of text_colour
      .background_colour_of background_colour
      .line_height_of line_height
      .rows_of rows

$std_types::screen/resize:
  #
    resizes a screen

    Topic: Terminal

    See also: create_screen
  (
    screen
    new_width # the new number of columns
    new_height # the new number of rows
  )
  resize_rows &screen
    new_width new_height
    text_colour_of(screen) background_colour_of(screen)
  -> screen

$resize_rows: (screen new_width new_height text_colour background_colour)
  $width width_of(screen)
  $height height_of(screen)
  $rows rows_of(screen)
  update_if new_height < height &rows -> range(rows 1 new_height)
  update_if new_width != width &rows:
    if
      new_width < width: map rows: (row) range row 1 3*new_width
      :
	$empty dup(string(' ' text_colour background_colour) new_width-width)
	map rows: (row) append row empty
  update_if new_height > height &rows:
    $empty dup(string(' ' text_colour background_colour) width)
    append rows dup(list(empty) new_height-height)
  ->
    screen
      .width_of new_width
      .height_of new_height
      .rows_of rows

$std::character_at:
  #
    returns the character at the specified position of the screen

    The x- and y-coordinates are both one-based.

    Attention: This is a low-level function. The arguments are not checked for
    validity!

    Topic: Terminal

    See also: text_colour_at, background_colour_at, set_character_at

    Example:

      character_at(terminal column row)
  (
    screen
    x
    y
  )
  -> rows_of(screen)(y)(3*x-2)

$std::text_colour_at:
  #
    returns the text colour at the specified position of the screen

    The x- and y-coordinates are both one-based.

    Attention: This is a low-level function. The arguments are not checked for
    validity!

    Topic: Terminal

    See also: background_colour_at, character_at, set_text_colour_at

    Example:

      text_colour_at(terminal column row)
  (
    screen
    x
    y
  )
  -> rows_of(screen)(y)(3*x-1)

$std::background_colour_at:
  #
    returns the background colour at the specified position of the screen

    The x- and y-coordinates are both one-based.

    Attention: This is a low-level function. The arguments are not checked for
    validity!

    Topic: Terminal

    See also: text_colour_at, character_at, set_background_colour_at

    Example:

      background_colour_at(terminal column row)
  (
    screen
    x
    y
  )
  -> rows_of(screen)(y)(3*x)

$std_types::screen/scroll_up:
  #
    scrolls the contents of the *screen* upwards

    Topic: Terminal

    See also: scroll_down, scroll_left, scroll_right
  (
    screen
    delta = 1 # the amount of rows to scroll
  )
  min &delta height_of(screen)
  $empty_line
    dup
      string
	' '
	text_colour_of(screen)
	background_colour_of(screen)
      width_of(screen)
  $empty_lines dup(list(empty_line) delta)
  ->
    screen
      .rows_of
	append
	  range(rows_of(screen) delta+1 -1)
	  empty_lines

$std_types::screen/scroll_down:
  #
    scrolls the contents of the *screen* downwards

    Topic: Terminal

    See also: scroll_up, scroll_left, scroll_right
  (
    screen
    delta = 1 # the amount of rows to scroll
  )
  min &delta height_of(screen)
  $empty_line
    dup
      string
	' '
	text_colour_of(screen)
	background_colour_of(screen)
      width_of(screen)
  $empty_lines dup(list(empty_line) delta)
  ->
    screen
      .rows_of
	append
	  empty_lines
	  range(rows_of(screen) 1 -(delta+1))

$std_types::screen/scroll_left:
  #
    scrolls the contents of the *screen* leftwards

    Topic: Terminal

    See also: scroll_up, scroll_down, scroll_right
  (
    screen
    delta = 1 # the amount of columns to scroll
  )
  $pad
    dup
      string
	' '
	text_colour_of(screen)
	background_colour_of(screen)
      delta
  map &screen.rows_of: (row) append range(row 3*delta+1 -1) pad
  -> screen

$std_types::screen/scroll_right:
  #
    scrolls the contents of the *screen* rightwards

    Topic: Terminal

    See also: scroll_up, scroll_down, scroll_left
  (
    screen
    delta = 1 # the amount of columns to scroll
  )
  $pad
    dup
      string
	' '
	text_colour_of(screen)
	background_colour_of(screen)
      delta
  map &screen.rows_of: (row) append pad range(row 1 -(3*delta+1))
  -> screen

$get_left_x_of: (screen)
  $x left_x_of(screen)
  if
    x < 0
    -> width_of(screen)+x+1
    -> x

$get_right_x_of: (screen)
  $x right_x_of(screen)
  if
    x < 0
    -> width_of(screen)+x+1
    -> x

$get_top_y_of: (screen)
  $y top_y_of(screen)
  if
    y < 0
    -> height_of(screen)+y+1
    -> y

$get_bottom_y_of: (screen)
  $y bottom_y_of(screen)
  if
    y < 0
    -> height_of(screen)+y+1
    -> y

$adapt_to_window: (screen x y width height)
  $left_x get_left_x_of(screen)
  $top_y get_top_y_of(screen)
  $right_x get_right_x_of(screen)
  $bottom_y get_bottom_y_of(screen)
  plus &x left_x-1
  plus &y top_y-1
  if
    x < left_x:
      minus &width left_x-x
      !x left_x
      check_y
    check_y

  $check_y:
    if
      y < top_y:
	minus &height top_y-y
	!y top_y
	check_width
      check_width

  $check_width:
    if
      width.is_undefined || x+width-1 > right_x:
	!width right_x+1-x
	check_height
      check_height

  $check_height:
    if
      height.is_undefined || y+height-1 > bottom_y:
	!height bottom_y+1-y
	return
      return

  $return -> x y width height

$std_types::screen/define_window:
  #
    defines a rectangular drawing area

    x- and y-coordinates are one-based

    Topic: Terminal

    See also: create_terminal
  (
    self # the screen or terminal
    left_x # the left border of the draw area
    top_y # the top border of the draw area
    right_x # the right border of the draw area (inclusive!)
    bottom_y # the bottom border of the draw area (inclusive!)
  )
  ->
    self
      .left_x_of left_x
      .top_y_of top_y
      .right_x_of right_x
      .bottom_y_of bottom_y

$std_types::screen/clear:
  #
    clears the specified rectangular area

    The specified area is filled with spaces using the the current colours.

    This function also works for "graphical screens" (line_height != 1).

    Topic: Terminal

    See also: std_types::screen/copy

  (
    self
    x = 1 # the first column to fill
    y = 1 # the first row to fill
    width = undefined # the number of columns to fill
    height = undefined # the number of rows to fill
  )
  $line_height line_height_of(self)
  if
    line_height == 1:
      adapt_to_window self &x &y &width &height
      if
	width < 1 || height < 1
	-> self
	:
	  $rows rows_of(self)
	  $insertion
	    dup
	      string
		' '
		text_colour_of(self)
		background_colour_of(self)
	      width
	  map $updated_rows range(rows y y+height-1): (row)
	    ->
	      append
		range(row 1 3*(x-1))
		append
		  insertion
		  range(row 3*(x+width)-2 -1)
	  ->
	    self
	      .rows_of
		append
		  range(rows 1 y-1)
		  append
		    updated_rows
		    range(rows y+height -1)
    :
      debug::print "
	screen/clear is currently only implemented for line_height 1!
      debug::exit

$std_types::screen/copy:
  #
    copies a rectangular area from one screen to another

    This function can also copy a rectangular area within a single screen.

    Topic: Terminal

    See also: std_types::screen/clear

  (
    destination
    x
    y
    source = destination
    sx
    sy
    width
    height
  )
  $source_width width_of(source)
  $source_height height_of(source)
  if
    ||
      sx < 1
      width < 0
      (sx+width-1) > source_width
      sy < 1
      height < 0
      sy+height-1 > source_height
    :
      error
	"
	  INVALID ARGUMENTS FOR "std_types::screen/copy"@
    :
      $destination_width width_of(destination)
      $destination_height height_of(destination)
      if
	x < 1:
	  $dx 1-x
	  plus &sx dx
	  minus &width dx
	  check_y
	check_y

      $check_y:
	if
	  y < 1:
	    $dy 1-y
	    plus &sy dy
	    minus height dy
	    check_width
	  check_width

      $check_width:
	if
	  x+width-1 > destination_width:
	    !width destination_width+1-x
	    check_height
	  check_height

      $check_height:
	if
	  y+height-1 > destination_height:
	    !height destination_height+1-y
	    copy_rows
	  copy_rows

      $copy_rows:
	if
	  width <= 0 || height <= 0
	  -> destination
	  :
	    $dx 3*(sx-x)
	    $dy sy-y
	    !x 3*x-2
	    !width 3*width
	    $rows rows_of(destination)
	    $source_rows rows_of(source)
	    ->
	      destination
		.rows_of
		  append
		    append
		      range(rows 1 y-1)
		      map(range(rows y y+height-1) copy_row)
		    range(rows y+height -1)

	    $copy_row: (cy row)
	      append
		append
		  range(row 1 x-1)
		  range(source_rows(y+cy+dy-1) x+dx width)
		range(row x+width -1)

$std::blit:
  #
    copies a source screen into the destination screen
  (
    destination
    x
    y
    source
  )
  $source_rows rows_of(source)
  $source_width length_of(source_rows(1))
  $source_height length_of(source_rows)

  $destination_rows rows_of(destination)
  $destination_width length_of(destination_rows(1))
  $destination_height length_of(destination_rows)

  $min_y max(1 y)
  $max_y min(source_height destination_height+y-1)
  $min_x max(1 2-x)
  $max_x min((source_width .div. 3) (destination_width .div. 3)+1-x)
  if
    min_y <= max_y && min_x <= max_x:
      $ex1 x-1
      $sx2 x+(source_width .div. 3)
      $copy undefined

      $copy_lines:
	from_to min_y max_y
	  : (cy)
	    !destination_rows(cy+1-y)
	      copy(destination_rows(cy+1-y) source_rows(cy))
	    next
	  -> destination(.rows_of destination_rows)

      if
	sx2 <= (destination_width .div. 3):
	  if
	    ex1 >= 1:
	      !copy: (dest src)
		append
		  range(dest 1 3*ex1)
		  range(src 3*min_x-2 3*max_x)
		  range(dest 3*sx2-2 destination_width)
	      copy_lines
	    :
	      !copy: (dest src)
		append
		  range(src 3*min_x-2 3*max_x)
		  range(dest 3*sx2-2 destination_width)
	      copy_lines
	:
	  if
	    ex1 >= 1:
	      !copy: (dest src)
		append range(dest 1 3*ex1) range(src 3*min_x-2 3*max_x)
	      copy_lines
	    :
	      !copy: (_dest src)
		range src 3*min_x-2 3*max_x
	      copy_lines
    -> destination

$std::FILE_DESCRIPTOR .
  #
    specify file descriptor in call to *initialize_terminal*

$std::RECEIVE_CTRL_C_AND_CTRL_Z .
  #
    specify that the terminal should receive ctrl-c and ctrl-z

$std::RECEIVE_CTRL_Q_AND_CTRL_S .
  #
    specify that the terminal should receive ctrl-q and ctrl-s

$std::MAP_CR .
  #
    specify that the terminal should map carriage return to line feed

$std::RECEIVE_SIGWINCH .
  #
    specify that the terminal should receive SIGWINCH

$std::CURSOR_OFF .
  #
    specify that the cursor should be turned off

$std::TITLE .
  #
    the title to use for the terminal window

$terminal_private::backspace_character '@del;'

$std::initialize_terminal:
  #
    creates a terminal object for the given input file descriptor

    If no file descriptor is given, the function uses the standard input.

    The supplied options are used to configure the terminal.

    Possible options are:

      * TEXT_COLOUR: specify the initial text colour

      * BACKGROUND_COLOUR: specify the initial background colour

      * FILE_DESCRIPTOR: explicitly specify the file descriptor

      * RECEIVE_CTRL_C_AND_CTRL_Z: specify that the terminal should receive
	ctrl-c and ctrl-z

      * RECEIVE_CTRL_Q_AND_CTRL_S: specify that the terminal should receive
	ctrl-q and ctrl-s

      * MAP_CR: specify that the terminal should map carriage returns to line
	feeds

      * RECEIVE_SIGWINCH: specify that the terminal should receive window
	resize events

      * CURSOR_OFF: specify that the cursor should be initially turned off

      * TITLE: specify the title to use for the terminal window

    After successfull initialization the function calls *body* with the
    <std_types::terminal> object as its sole argument.

    When *body* returns, the function undoes all changes made to the terminal
    window.

    Topic: Terminal

    See also: create_terminal

    Example:

      initialize_terminal!
	TEXT_COLOUR = RED
	BACKGROUND_COLOUR = BLACK
	TITLE = "My Terminal"
	: (terminal)
	  draw_text &terminal 10 5 "Hello, world!"
	  update_terminal &terminal $output # create output character stream
	  print! output # print the generated character stream
  (
    options* # the options to use
    body # the function to call
  )
  extract_options options
    TEXT_COLOUR = BLACK $text_colour
    BACKGROUND_COLOUR = WHITE $background_colour
    FILE_DESCRIPTOR = STDIN_FILENO $fd
    RECEIVE_CTRL_C_AND_CTRL_Z = false $do_receive_ctrl_c_and_ctrl_z
    RECEIVE_CTRL_Q_AND_CTRL_S = false $do_receive_ctrl_q_and_ctrl_s
    MAP_CR = false $do_map_cr
    RECEIVE_SIGWINCH = false $_do_receive_sigwinch
    CURSOR_OFF = false $do_switch_cursor_off
    TITLE = undefined $title

  get_terminal_attributes! fd $original_attributes
  $attributes original_attributes
  use_canonical_mode &attributes false #  no line-buffering ...
  echo_characters &attributes false # ... and no echoing of typed in characters
  update_if do_receive_ctrl_c_and_ctrl_z &attributes:
    generate_signals attributes false
  update_if do_receive_ctrl_q_and_ctrl_s &attributes:
    enable_xon_xoff_for_output attributes false
  update_if do_map_cr &attributes:
    map_cr_to_lf_on_input attributes false
  set_terminal_attributes! $success STDIN_FILENO attributes

  on success.is_an_error success

  !terminal_private::backspace_character backspace_character_of(attributes)

  print! "@esc;[?47h" # switch to alternate screen
  print! "@esc;[33s" # store cursor position
  on do_switch_cursor_off: cursor_off!
  on title.is_defined: print! "@esc;]0;@(title)@7;"

  get_terminal_size! fd $width $height
  create_terminal $terminal width height
    TEXT_COLOUR = text_colour
    BACKGROUND_COLOUR = background_colour
  debug::dump `terminal

  terminal_private::initialize_keys:
    try $err: body! terminal

    set_terminal_attributes! $_success fd original_attributes
    print! "@esc;[u" # restore cursor position
    print! "@esc;[?47l" # switch to default screen
    print! "@esc;[0m" # set default colours
    on do_switch_cursor_off: cursor_on!

    on err.is_an_error: debug::dump_object 50 err

$std::update_terminal:
  #
    create a command sequence to update the terminal

    This functions updates the terminal object **and** returns an ANSI-command
    sequence that can be used to update the terminal.

    Topic: Terminal

    Example:

      get_terminal_size! STDIN_FILENO $width $height
      create_terminal $terminal width height
      draw_text &terminal 10 5 "Hello, world!"
      update_terminal &terminal $output
      print! output
  (
    terminal # the terminal to be updated
    do_log = false # log updates to <stderr>
  )
  $output ""
  $current_buffer current_buffer_of(terminal)
  $current_y cursor_y_of(current_buffer)
  $current_x cursor_x_of(current_buffer)
  $current_text_colour text_colour_of(current_buffer)
  $current_background_colour background_colour_of(current_buffer)
  $new_rows rows_of(terminal)
  $current_rows rows_of(current_buffer)
  $terminal_width width_of(terminal)
  $terminal_height height_of(terminal)
  from_to 1 terminal_height
    !output
    !current_y !current_x
    !current_background_colour !current_text_colour
    : (y)
      $new_row new_rows(y)
      $current_row current_rows(y)
      $last_column find_last_non_empty_column(new_row)
      from_to 1 last_column
	: (x)
	  $new_chr new_row(3*x-2)
	  if
	    new_chr == INVALID_CHARACTER
	    next
	    :
	      $new_text_colour new_row(3*x-1)
	      $new_background_colour new_row(3*x)
	      if
		||
		  new_chr != current_row(3*x-2)
		  new_text_colour != current_row(3*x-1)
		  new_background_colour != current_row(3*x)
		:
		  move_to x y:
		    use_text_colour new_text_colour:
		      use_background_colour new_background_colour:
			emit_character new_chr:
			  next
		next
	:
	  if
	    last_column < terminal_width:
	      move_to last_column+1 y:
		use_background_colour new_row(-1):
		  append &output csi("K") # clear to the end of the line
		  next
	    next
    ->
      output
      current_y current_x
      current_background_colour current_text_colour

  if
    current_y.is_undefined:
      !current_y 1
      !current_x 1
      log! "move cursor to @(current_y), @(current_x)"
      append &output csi(current_y current_x 'H')
      finish
    finish

  $log:
    (
      args*
    )
    if
      do_log:
	debug::print push(create_string(args) '@nl;')
      pass

  $csi: (arguments* command)
    -> string("@esc;[" join(arguments ';') command)

  $move_to: (x y cont)
    if
      y != current_y:
	if
	  x != current_x:
	    !current_y y
	    !current_x x
	    log "move cursor to @(y), @(x)"
	    append &output csi(y x 'H')
	    cont
	  :
	    if
	      y > current_y:
		$delta y-current_y
		!current_y y
		if
		  delta > 1:
		    log "move cursor down by " delta
		    append &output csi(delta 'B')
		    cont

		  :
		    log "move cursor down"
		    append &output csi('B')
		    cont
	      :
		$delta current_y-y
		!current_y y
		if
		  delta > 1:
		    log "move cursor up by " delta
		    append &output csi(delta 'A')
		    cont
		  :
		    log "move cursor up"
		    append &output csi('A')
		    cont
      :
	if
	  x != current_x:
	    if
	      x > current_x:
		$delta x-current_x
		!current_x x
		if
		  delta > 1:
		    log "move cursor right by " delta
		    append &output csi(delta 'C')
		    cont
		  :
		    log "move cursor right"
		    append &output csi('C')
		    cont
	      :
		$delta current_x-x
		!current_x x
		if
		  delta > 1:
		    log "move cursor left by " delta
		    append &output csi(delta 'D')
		    cont
		  :
		    log "move cursor left"
		    append &output csi('D')
		    cont
	  cont

  $use_text_colour: (colour cont)
    if
      colour != current_text_colour:
	!current_text_colour colour
	$colour_value colour.to_integer
	$red colour_value >> 16
	$green (colour_value >> 8) & 0xff
	$blue colour_value & 0xff
	log "set text colour to @(red), @(green), @(blue)"
	append &output csi(38 2 red green blue 'm')
	cont
      cont

  $use_background_colour: (colour cont)
    if
      colour != current_background_colour:
	!current_background_colour colour
	$colour_value colour.to_integer
	$red colour_value >> 16
	$green (colour_value >> 8) & 0xff
	$blue colour_value & 0xff
	log "set background colour to @(red), @(green), @(blue)"
	append &output csi(48 2 red green blue 'm')
	cont
      cont

  $emit_character: (chr cont)
    log "print " debug::string(chr).trim
    $chr_width width_of(chr)
    if !chr !chr_width
      current_x == terminal_width && chr_width == 2
      -> ' ' 1
      -> chr chr_width
    push &output chr
    plus &current_x width_of(chr)
    if
      current_x > terminal_width:
	#
	  there seems to be *no* autowrap to the start of the next line!
	!current_x undefined
	!current_y undefined
	cont
      cont

  $finish:
    if
      terminal.has_a_visible_cursor:
	move_to cursor_x_of(terminal) cursor_y_of(terminal) update_current_buffer
      update_current_buffer

    $update_current_buffer:
      !current_buffer.cursor_y_of current_y
      !current_buffer.cursor_x_of current_x
      !current_buffer.text_colour_of current_text_colour
      !current_buffer.background_colour_of current_background_colour
      !current_buffer.rows_of new_rows
      -> terminal(.current_buffer_of current_buffer) output

$find_last_non_empty_column: (row)
  $i length_of(row)
  $background_colour row(i)
  loop:
    if
      i > 0 && row(i-2) == ' ' && row(i) == background_colour:
	!i i-3
	next
      -> i .div. 3

$std_types::screen/plot:
  #
    plots a half character block

    Draws a lower or upper half block on the specified position.

    Attention: The y-coordinate is measured in half lines.

    Topic: Terminal

    See also: plot_line

    Example:

      get_terminal_size! STDIN_FILENO $terminal_width $terminal_height
      create_terminal $terminal terminal_width terminal_height
      $r 24
      $cy 25
      $width 60
      from_to !terminal 1 width
	: (x)
	  $y cy+to_integer(sin(x*2*PI/width)*r)
	  plot &terminal x y
	  next
	-> terminal
      update_terminal! &terminal $output
      print! output
  (
    screen # the screen or terminal onto which to plot
    x # the x-cordinate of the *half block*
    y # the y-coordinate of the *half block*
  )
  $row_no (y+1) .div. 2
  if
    ||
      row_no < 1
      row_no > height_of(screen)
      x < 1
      x > width_of(screen)
    -> screen
    :
      $rows rows_of(screen)
      $row rows(row_no)
      $chr row(3*x-2)
      if !row
	chr == INVALID_CHARACTER
	-> row(3*x-5 ' ')
	-> row
      if !row
	width_of(chr) == 2
	-> row(3*x+1 ' ')
	-> row
      if
	y.is_odd:
	  # upper half block
	  if
	    chr == '▄':
	      !row(3*x) text_colour_of(screen)
	      -> screen(.rows_of rows(row_no row))
	    :
	      !row(3*x-2) '▄'
	      !row(3*x-1) row(3*x)
	      !row(3*x) text_colour_of(screen)
	      -> screen(.rows_of rows(row_no row))
	:
	  # lower half block
	  if
	    chr == '▄':
	      !row(3*x-1) text_colour_of(screen)
	      -> screen(.rows_of rows(row_no row))
	    :
	      !row(3*x-2) '▄'
	      !row(3*x-1) text_colour_of(screen)
	      -> screen(.rows_of rows(row_no row))

$std_types::screen/plot_line:
  #
    plots a line consisting of half character blocks

    Draws a line from the specified start coordinate (*x1*/*y1*) to the
    specified end coordinate (*x2*/*y2*).

    Attention: The y-coordinates are measured in half lines.

    Topic: Terminal

    See also: plot

    Example:

      get_terminal_size! STDIN_FILENO $terminal_width $terminal_height  (
      create_terminal $terminal terminal_width terminal_height
      plot_line &terminal 5 5 70 30
      plot_line &terminal 70 30 45 40
      plot_line &terminal 45 40 5 5
      update_terminal! &terminal $output
      print! output
  (
    screen # the screen or terminal onto which to plot
    x1 # the x-coordinate of the start point
    y1 # the y-coordinate of the start point
    x2 # the x-coordinate of the end point
    y2 # the y-coordinate of the end point
  )
  $dx x2-x1
  $dy y2-y1
  if
    abs(dx) >= abs(dy):
      $iter bresenham(abs(dx)+1 y1 y2)
      if
	x2 >= x1:
	  from_to x1 x2
	    : (x)
	      next_value &iter $y
	      plot &screen x y
	      next
	    -> screen
	:
	  from_to_by x1 x2 -1
	    : (x)
	      next_value &iter $y
	      plot &screen x y
	      next
	    -> screen
    :
      $iter bresenham(abs(dy)+1 x1 x2)
      if
	y2 >= y1:
	  from_to y1 y2
	    : (y)
	      next_value &iter $x
	      plot &screen x y
	      next
	    -> screen
	:
	  from_to_by y1 y2 -1
	    : (y)
	      next_value &iter $x
	      plot &screen x y
	      next
	    -> screen

$std_types::screen/fill_trapezoid:
  #
    draws a filled trapezoid (without borders)

    The left and top edge are included in the filled area;
    the bottom and right edge are not included.

    Topic: Terminal
  (
    screen # the screen or terminal onto which to draw
    x1 # the x-coordinate of the top left corner
    y1 # the y-coordinate of the top left corner
    w1 # the width of the top edge
    x2 # the x-coordinate of the bottom left corner
    y2 # the y-coordinate of the bottom left corner
    w2 # the width of the bottom edge
  )
  if
    ||
      w1 < 0
      w2 < 0
      y1 >= y2
    -> screen
    :
      # use the Bresenham algorithm to compute the left and right edge
      $dy y2-y1
      $left_iter bresenham(dy x1 x2)
      $right_iter bresenham(dy x1+w1 x2+w2)
      from_to y1 y2-1
	: (y)
	  next_value &left_iter $lx
	  next_value &right_iter $rx
	  plot_line &screen lx y rx-1 y
	  next
	-> screen

$std_types::screen/set_text_colour:
  #
    sets the colour to be used for drawing text or lines

    Topic: Terminal
  (
    screen # the screen on which to set the colour
    colour # the new text colour
  )
  -> screen(.text_colour_of colour)

$std_types::screen/set_background_colour:
  #
    sets the background colour to be used

    Topic: Terminal
  (
    screen # the screen on which to set the colour
    colour # the new background colour
  )
  -> screen(.background_colour_of colour)

#$std::set_character_at:
  #
    sets the character at the specified screen position

    The text and background colours are left unchanged.

    Topic: Terminal

    See also: set_text_colour_at, set_background_colour_at, character_at
  (
    x
    y
    chr
  )
  if
    &&
      y >= 1
      y <= height_of(logical_screen)
      x >= 1
      x <= width_of(logical_screen)
    :
      !logical_screen.characters_of(y)(x) chr

$INVALID_CHARACTER '@0;'

$std_types::screen/set_cursor:
  (
    self # the terminal for which to set the cursor
    x # in logical screen coordinates
    y # in logical screen coordinates (any coordinate within a row is accepted)
  )
  ->
    self
      .cursor_x_of left_x_of(self)+x-1
      .cursor_y_of top_y_of(self)+y-1

$std_types::screen/set_character_at:
  #
    changes the character at the specified screen position

    The arguments are *not* validated!

    See also: set_text_colour_at, set_background_colour_at
  (
    screen # the terminal on which to draw
    x # in logical screen coordinates
    y # in logical screen coordinates (any coordinate within a row is accepted)
    chr # the character to set
  )
  $rows rows_of(screen)
  $row rows(y)
  !row(3*x-2) chr
  !rows(y) row
  -> screen(.rows_of rows)

$std_types::screen/set_text_colour_at:
  #
    changes the text colour at the specified screen position

    The arguments are *not* validated!

    See also: set_background_colour_at, set_character_at
  (
    screen # the terminal on which to draw
    x # in logical screen coordinates
    y # in logical screen coordinates (any coordinate within a row is accepted)
    colour # the new text colour
  )
  $rows rows_of(screen)
  $row rows(y)
  !row(3*x-1) colour
  !rows(y) row
  -> screen(.rows_of rows)

$std_types::screen/set_background_colour_at:
  #
    changes the background colour at the specified screen position

    The arguments are *not* validated!

    See also: set_text_colour_at, set_character_at
  (
    screen # the terminal on which to draw
    x # in logical screen coordinates
    y # in logical screen coordinates (any coordinate within a row is accepted)
    colour # the new background colour
  )
  $rows rows_of(screen)
  $row rows(y)
  !row(3*x) colour
  !rows(y) row
  -> screen(.rows_of rows)

$std_types::screen/draw_character:
  #
    draws a character at the current screen position

    The character is drawn using the current text and background colour.

    Topic: Terminal

    See also: draw_text
  (
    screen # the terminal on which to draw
    x # in logical screen coordinates
    y # in logical screen coordinates (any coordinate within a row is accepted)
    chr # the character to draw
  )
  $width width_of(screen)
  $height height_of(screen)
  $line_height line_height_of(screen)
  update_if line_height > 1 &y -> y+line_height-1 .div. line_height
  if
    x < 1 || x > width || y < 1 || y > height
    -> screen
    :
      $colour
	string
	  text_colour_of(screen)
	  background_colour_of(screen)
      $row rows_of(screen)(y)
      $buf ""
      $sx 3*x-2
      $w 3
      $old_chr row(3*x-2)
      if
	old_chr == INVALID_CHARACTER:
	  push &buf ' '
	  append &buf colour
	  !sx sx-3
	  !w w+3
	  update_character
	update_character

      $update_character:
	push &buf chr
	append &buf colour
	if
	  x == width # no need to check character width
	  return_update
	  :
	    $old_chr_width width_of(old_chr)
	    if
	      width_of(chr) == 1:
		if
		  old_chr_width == 1
		  return_update
		  :
		    push &buf ' '
		    append &buf colour
		    !w w+3
		    return_update
	      :
		if
		  old_chr_width == 1:
		    if
		      x+1 == width || width_of(row(3*x+1)) == 1:
			push &buf INVALID_CHARACTER
			append &buf colour
			!w w+3
			return_update
		      :
			push &buf INVALID_CHARACTER
			append &buf colour
			push &buf ' '
			append &buf colour
			!w w+6
			return_update

		  : # wide -> wide
		    !w w+3
		    push &buf INVALID_CHARACTER # the character will not change
		    append &buf colour # but we need to replace the colour
		    return_update

      $return_update:
	!screen.rows_of(y)
	  append
	    append
	      range(row 1 sx-1)
	      buf
	    range(row sx+w -1)
	-> screen

$std_types::screen/draw_text:
  #
    draw the specified text at the current screen position

    The text is drawn using the current text and background colour.

    The text is clipped on the borders of the current window.

    A *newline*-character moves the drawing position into the next *row* back to
    the original *x*-coordinate.

    Topic: Terminal

    See also: draw_character
  (
    self
    x # in logical screen coordinates
    y # in logical screen coordinates (any coordinate within a row is accepted)
    args* # the text to draw
  )
  $text create_string(args)
  if
    text.is_empty
    -> self
    :
      $left_x get_left_x_of(self)
      $top_y get_top_y_of(self)
      $right_x get_right_x_of(self)
      $bottom_y get_bottom_y_of(self)
      plus &x left_x-1
      plus &y top_y-1
      $line_height line_height_of(self)
      $first_y
	if
	  line_height == 1
	  -> y
	  -> y+line_height-1 .div. line_height
      $colour
	string
	  text_colour_of(self)
	  background_colour_of(self)
      without_suffix &text '@nl;'
      split text '@nl;' $lines
      if
	||
	  x > right_x
	  first_y > bottom_y
	  first_y+length_of(lines) <= top_y
	-> self # text is completely outside the "window"
	:
	  update_if first_y < top_y &lines &first_y
	    -> range(lines top_y+1-first_y -1) top_y
	  $line_count length_of(lines)
	  if !lines $last_y
	    first_y+line_count-1 > bottom_y
	    -> range(lines 1 bottom_y+1-first_y) bottom_y
	    -> lines first_y+line_count-1
	  $rows rows_of(self)
	  ->
	    self
	      .rows_of
		append
		  range(rows 1 first_y-1)
		  map(range(rows first_y last_y) update_row)
		  range(rows last_y+1 -1)

      $update_row: (no row)
	$line lines(no)
	if
	  line.is_empty
	  -> row
	  :
	    $i 1
	    $n length_of(line)
	    $cx x
	    $cw undefined
	    $buf ""
	    skip_clipped_characters

	    $skip_clipped_characters:
	      if
		i > n
		-> row
		:
		  cond
		    -> cx < left_x
		      skip_one_character
		    -> i > 1 && cx > left_x:
		      push_if_wide ' '
		    -> row(3*cx-2) == INVALID_CHARACTER
		      update_preceding_wide_character
		    -> true
		      update_characters

	    $skip_one_character:
	      $chr line(i)
	      inc &i
	      !cw width_of(chr)
	      plus &cx cw
	      skip_clipped_characters

	    $push_if_wide: (chr)
	      if
		cw == 1
		update_characters
		:
		  push &buf chr
		  append &buf colour
		  update_characters

	    $update_characters:
	      if
		i > n:
		  if
		    cx <= right_x && row(3*cx-2) == INVALID_CHARACTER
		    update_following_wide_character
		    return_updates
		:
		  $chr line(i)
		  inc &i
		  !cw width_of(chr)
		  plus &cx cw
		  cond
		    -> cx-1 <= right_x:
		      push &buf chr
		      append &buf colour
		      push_if_wide INVALID_CHARACTER
		    -> cx-cw <= right_x
		      push_trailing_half_character
		    -> true
		      return_updates

	    $update_preceding_wide_character:
	      dec &x
	      push &buf ' '
	      append &buf colour
	      update_characters

	    $update_following_wide_character:
	      inc &cx
	      push &buf ' '
	      append &buf colour
	      return_updates

	    $push_trailing_half_character:
	      push &buf ' '
	      append &buf colour
	      return_updates

	    $return_updates:
	      append
		range(row 1 3*(max(x left_x)-1))
		buf
		range(row max(3*min(cx right_x+1)-2 1) -1)

$std_types::screen/draw_attributed_text:
  #
    draw the specified attributed text at the current screen position

    The text must not contain any newline characters

    The text is clipped on the borders of the current window.

    Topic: Terminal

    See also: draw_text
  (
    self
    x # in logical screen coordinates
    y # in logical screen coordinates (any coordinate within a row is accepted)
    attributed_text # the text to draw
  )
  $n length_of(attributed_text) .div. 3
  $left_x get_left_x_of(self)
  $top_y get_top_y_of(self)
  $right_x get_right_x_of(self)
  $bottom_y get_bottom_y_of(self)
  plus &x left_x-1
  plus &y top_y-1
  if
    ||
      x+n-1 < left_x
      x > right_x
      y < top_y
      y > bottom_y
    -> self # text is completely outside the "window"
    :
      $rows rows_of(self)
      ->
	self
	  .rows_of
	    append
	      push(range(rows 1 y-1) update_row(rows(y)))
	      range(rows y+1 -1)

  $update_row: (row)
    $s max(left_x+1-x 1) # first attributed character to output
    $e min(right_x+1-x n)
    max &x left_x
    $left_text range(row 1 3*(x-1))
    range &attributed_text 3*s-2 3*e
    $right_text range(row 3*(x+e-s)+1 -1)
    update_if left_text.is_not_empty && width_of(left_text(-3)) > 1
      &left_text -> left_text(-3 ' ')
    update_if attributed_text(1) == INVALID_CHARACTER
      &attributed_text -> attributed_text(1 ' ')
    update_if width_of(attributed_text(-3)) > 1
      &attributed_text -> attributed_text(-3 ' ')
    update_if right_text.is_not_empty && right_text(1) == INVALID_CHARACTER
      &right_text -> right_text(1 ' ')
    append left_text attributed_text right_text

$std_types::screen/draw_line:
  #
    draws a horizontal or vertical line

    The following condition must hold:

    x1 == x2 || y1 == y2

    Topic: Terminal

    See also: draw_rectangle
  (
    self
    x1
    y1
    x2
    y2
  )
  $min_x min(x1 x2)
  $max_x max(x1 x2)
  $min_y min(y1 y2)
  $max_y max(y1 y2)
  $width width_of(self)
  $height height_of(self)
  if
    min_x < 1 || max_x > width || min_y < 1 || max_y > height:
      error
	"
	  INVALID ARGUMENTS FOR "std_types::screen/draw_line"@
    horizontal_or_vertical

  $horizontal_or_vertical:
    $colour
      string
	text_colour_of(self)
	background_colour_of(self)
    $rows rows_of(self)
    cond
      -> min_x == max_x vertical
      -> min_y == max_y horizontal
      -> true:
	error
	  "
	    INVALID ARGUMENTS FOR "std_types::screen/draw_line"@

    $vertical:
      if
	min_y == max_y:
	  error
	    "
	      INVALID ARGUMENTS FOR "std_types::screen/draw_line"@
	:
	  $has_left_connection key_order_set('┘' '─' '┴' '┐' '┤' '┬' '┼')
	  $has_right_connection key_order_set('└' '─' '┴' '┌' '├' '┬' '┼')

	  $new_top_row draw_vertical_line(min_y rows(min_y) '┬')
	  $new_middle_rows
	    map(range(rows min_y+1 max_y-1): (y row) draw_vertical_line y row '┼')
	  $new_bottom_row draw_vertical_line(max_y rows(max_y) '┴')
	  ->
	    self
	      .rows_of
		append
		  append
		    push(range(rows 1 min_y-1) new_top_row)
		    push(new_middle_rows new_bottom_row)
		  range(rows max_y+1 -1)

	  $draw_vertical_line: (_y row crossing)
	    $prev_chr row(3*min_x-2)
	    $chr
	      case
		prev_chr
		'─':
		  $left character_left()
		  $right character_right()
		  cond
		    -> has_right_connection(left) && not(has_left_connection(right)):
		      case crossing
			'┼' -> '┤'
			'┬' -> '┐'
			'┴' -> '┘'
			-> '│'
		    -> has_left_connection(right) && not(has_right_connection(left)):
		      case crossing
			'┼' -> '├'
			'┬' -> '┌'
			'┴' -> '└'
			-> '│'
		    -> true -> crossing
		'┌':
		  if
		    crossing == '┬'
		    -> '┌'
		    -> '├'
		'├' -> '├'
		'└':
		  if
		    crossing == '┴'
		    -> '└'
		    -> '├'
		'┐':
		  if
		    crossing == '┬'
		    -> '┐'
		    -> '┤'
		'┤' -> '┤'
		'┘':
		  if
		    crossing == '┴'
		    -> '┘'
		    -> '┤'
		'┬':
		  if
		    crossing == '┬'
		    -> '┬'
		    -> '┼'
		'┴':
		  if
		    crossing == '┴'
		    -> '┴'
		    -> '┼'
		'┼' -> '┼'
		-> '│'
	    $new_row range(row 1 3*(min_x-1))
	    push &new_row chr
	    append &new_row colour
	    append &new_row range(row 3*min_x+1 -1)
	    -> new_row

	    $character_left:
	      if
		min_x > 1
		-> row(3*min_x-5)
		-> ' '

	    $character_right:
	      if
		min_x < width
		-> row(3*min_x+1)
		-> ' '

    $horizontal:
      $has_top_connection key_order_set('┘' '│' '┤' '└' '┴' '├' '┼')
      $has_bottom_connection key_order_set('┐' '│' '┤' '┌' '┬' '├' '┼')
      $orig_row rows(min_y)
      $row range(orig_row 1 3*(min_x-1))
      draw_horizontal_line !row min_x '├'
      from_to min_x+1 max_x-1
	: (x)
	  draw_horizontal_line !row x '┼'
	  next
	:
	  draw_horizontal_line !row max_x '┤'
	  !rows(min_y) row
	  append &row range(orig_row 3*max_x+1 -1)
	  !self.rows_of(min_y) row
	  -> self

      $draw_horizontal_line: (x crossing)
	$prev_chr orig_row(3*x-2)
	$chr
	  case
	    prev_chr
	    '│':
	      $above character_above()
	      $below character_below()
	      cond
		-> has_bottom_connection(above) && not(has_top_connection(below)):
		  case crossing
		    '┼' -> '┴'
		    '├' -> '└'
		    '┤' -> '┘'
		    -> '─'
		-> has_top_connection(below) && not(has_bottom_connection(above)):
		  case crossing
		    '┼' -> '┬'
		    '├' -> '┌'
		    '┤' -> '┐'
		    -> '─'
		-> true -> crossing
	    '┌':
	      if
		crossing == '├'
		-> '┌'
		-> '┬'
	    '┬' -> '┬'
	    '┐':
	      if
		crossing == '┤'
		-> '┐'
		-> '┬'
	    '└':
	      if
		crossing == '├'
		-> '└'
		-> '┴'
	    '┴' -> '┴'
	    '┘':
	      if
		crossing == '┤'
		-> '┘'
		-> '┴'
	    '├':
	      if
		crossing == '├'
		-> '├'
		-> '┼'
	    '┤':
	      if
		crossing == '┤'
		-> '┤'
		-> '┼'
	    '┼' -> '┼'
	    -> '─'
	push &row chr
	append row colour

	$character_above:
	  if
	    min_y > 1
	    -> rows(min_y-1)(3*x-2)
	    -> ' '

	$character_below:
	  if
	    min_y < height
	    -> rows(min_y+1)(3*x-2)
	    -> ' '

$std_types::screen/draw_rectangle:
  #
    draws a rectangle

    The points *x1*/*y1* and *x2*/*y2* denote opposite corners of the rectangle.

    The rectangle goes through the specified corner points.

    Topic: Terminal

    See also: draw_line
  (
    self
    x1
    y1
    x2
    y2
  )
  draw_line &self x1 y1 x1 y2
  draw_line &self x1 y2 x2 y2
  draw_line &self x2 y2 x2 y1
  draw_line self x2 y1 x1 y1

$std::create_terminal:
  #
    must be called before any other terminal function

    Creates a default screen and allows the use of all drawing functions.

    Available options are:

    * <TEXT_COLOUR> (default: <BLACK>)

    * <BACKGROUND_COLOUR> (default: <WHITE>)

    * <LINE_HEIGHT> (default: 1)

    * <VISIBLE_CURSOR> (default: <true>)

    Topic: Terminal

    See also: create_screen

    Example:

      <require basic/stdlib>
      <require terminal/terminal>

      get_terminal_size! STDIN_FILENO $width $height
      create_terminal $terminal width height
	TEXT_COLOUR = WHITE
	BACKGROUND_COLOUR = BLUE
      draw_text &terminal
	10 # column
	5 # row
	"
	  This is a multi-line
	  text.
      update_terminal &terminal $output # create output character stream
      print! output # print the generated character stream
  (
    width # the number of columns
    height # the number of rows
    options* # optional terminal attributes
  )
  extract_options options
    TEXT_COLOUR = BLACK $text_colour
    BACKGROUND_COLOUR = WHITE $background_colour
    LINE_HEIGHT = 1 $line_height
    VISIBLE_CURSOR = true $visible_cursor
  $row dup(string(' ' text_colour background_colour) width)
  $rows dup(list(row) height)
  $terminal
    std_types::terminal
      .cursor_x_of 1
      .cursor_y_of 1
      .width_of width
      .height_of height
      .left_x_of 1
      .top_y_of 1
      .right_x_of width
      .bottom_y_of height
      .text_colour_of text_colour
      .background_colour_of background_colour
      .line_height_of line_height
      .has_a_visible_cursor visible_cursor
      .rows_of rows
  $buffer
    create_screen
      width height
      TEXT_COLOUR = INVALID_COLOUR
      BACKGROUND_COLOUR = INVALID_COLOUR
  ->
    terminal
      .current_buffer_of
	buffer
	  .cursor_x_of undefined # cursor column
	  .cursor_y_of undefined # cursor row

$std_types::terminal/resize:
  #
    resizes the terminal

    Topic: Terminal
  (
    self # the terminal
    new_width # the new number of columns
    new_height # the new number of rows
  )
  resize_rows &self
    new_width new_height
    text_colour_of(self) background_colour_of(self)
  resize_rows &self.current_buffer_of
    new_width new_height
    INVALID_COLOUR INVALID_COLOUR
  -> self

$std::cursor_off:
  #
    turns the terminal cursor off

    Topic: Terminal

    See also: cursor_on, cursor_home, clear_screen

  print! "@esc;[?25l"

$std::cursor_on:
  #
    turns the terminal cursor on

    Topic: Terminal

    See also: cursor_off, cursor_home, clear_screen

  print! "@esc;[?25h"

$std::cursor_home:
  #
    moves the cursor to the top-left position

    Topic: Terminal

    See also: clear_screen, cursor_on, cursor_off

  print! "@esc;[1;1H"

$std::clear_screen:
  #
    clears the terminal screen and moves the cursor to the top-left position

    Topic: Terminal

    See also: cursor_home, cursor_on, cursor_off, restore_colours

  cursor_home!
  print! "@esc;[2J"

$std::restore_colours:
  #
    set default colours for text and background

    Call this during the cleanup phase.

    Topic: Terminal

    See also: clear_screen, cursor_on

  print! "@esc;[39m@esc;[49m"

$std::rgb_character:
  #
    constructs a colour (character) from its primary colours

    Topic: Terminal

    See also: colour_mixture,
	      red_component_of, green_component_of, blue_component_of
  (
    red
    green
    blue
  )
  -> character((red << 16) | (green << 8) | blue)

$std_types::character/red_component_of:
  #
    returns the red component of the colour (character)

    Topic: Terminal

    See also: green_component_of, blue_component_of, rgb_character,
	      colour_mixture
  (
    chr
  )
  -> (chr.to_integer >> 16) & 0xff

$std_types::character/green_component_of:
  #
    returns the green component of the colour (character)

    Topic: Terminal

    See also: red_component_of, blue_component_of, rgb_character,
	      colour_mixture
  (
    chr
  )
  -> (chr.to_integer >> 8) & 0xff

$std_types::character/blue_component_of:
  #
    returns the blue component of the colour (character)

    Topic: Terminal

    See also: red_component_of, green_component_of, rgb_character,
	      colour_mixture
  (
    chr
  )
  -> chr.to_integer & 0xff

$std::colour_mixture:
  #
    constructs a colour (character) from a mixture of the specified colours

    The arguments are colour characters or <std_types::key_value_pair>s of the
    form

    *colour* = *parts*

    Topic: Terminal

    See also: rgb_character,
	      red_component_of, green_component_of, blue_component_of

    Example:

      $RED rgb_character(0xff 0 0)
      $BLUE rgb_character(0 0 0xff)

      $VIOLET colour_mixture(RED BLUE = 2) # one part red, two parts blue
  (
    args*
  )
  $total_parts 0
  $red 0
  $green 0
  $blue 0
  for_each args
    : (arg)
      if
	arg.is_a_key_value_pair:
	  $colour key_of(arg)
	  $parts value_of(arg)
	  plus &red parts*red_component_of(colour)
	  plus &green parts*green_component_of(colour)
	  plus &blue parts*blue_component_of(colour)
	  plus &total_parts parts
	  next
	:
	  plus &red red_component_of(arg)
	  plus &green green_component_of(arg)
	  plus &blue blue_component_of(arg)
	  inc &total_parts
	  next
    ->
      rgb_character
	round(red/total_parts).to_integer
	round(green/total_parts).to_integer
	round(blue/total_parts).to_integer

$std::rows_and_columns:
  #
    returns the number of rows and the width of the longest row in the text

    Topic: Terminal, Strings
  (
    text # the text to measure
  )
  $rows 0
  $longest 0
  $length 0
  for_each text
    : (chr)
      if
	chr == '@nl;':
	  max &longest length
	  inc &rows
	  !length 0
	  next
	:
	  inc &length
	  next
    :
      if
	text(-1) != '@nl;':
	  max &longest length
	  -> rows+1 longest
	-> rows longest

#$std::set_direct_terminal_input_mode
  #
    do-it-all terminal initialization

    Disables key input buffering and input echoing and turns the cursor off.

    The default terminal mode is automatically restored when the program exits.

    See also: get_terminal_attributes, set_terminal_attributes,
	      use_canonical_mode, echo_characters, restore_colours,
	      cursor_on, cursor_off, clear_screen
  :
    do:
      get_terminal_attributes STDIN_FILENO $attributes
      use_canonical_mode &attributes false
      echo_characters &attributes false
      unless set_terminal_attributes(STDIN_FILENO attributes):
	Error! "Failed to disable canonical input mode!"
      cursor_off!
    at_exit:
      restore_colours
      clear_screen
      cursor_on
      get_key $dummy 0
      get_terminal_attributes STDIN_FILENO $attributes
      use_canonical_mode &attributes false
      echo_characters &attributes true
      unless set_terminal_attributes(STDIN_FILENO attributes):
	Error "Failed to reset input mode!"

$std::ansi_text_colour:
  (
    colour
  )
  $colour_value colour.to_integer
  $red colour_value >> 16
  $green (colour_value >> 8) & 0xff
  $blue colour_value & 0xff
  -> csi(38 2 red green blue 'm')

$std::ansi_background_colour:
  (
    colour
  )
  $colour_value colour.to_integer
  $red colour_value >> 16
  $green (colour_value >> 8) & 0xff
  $blue colour_value & 0xff
  -> csi(48 2 red green blue 'm')

$std::ansi_reset_colour:
  -> csi("0m")

$std::csi: (arguments* command)
  -> string("@esc;[" join(arguments ';') command)

$std::add_attributes:
  (
    text
    text_colour
    background_colour
  )
  $buf ""
  for_each text
    : (chr)
      push &buf chr
      push &buf text_colour
      push &buf background_colour
      if
	chr.is_a_wide_character:
	  push &buf INVALID_CHARACTER
	  push &buf text_colour
	  push &buf background_colour
	  next
	next
    -> buf
