#!/usr/bin/env fkyrun

<namespace tedi_types>

<require basic/stdlib>
<require basic/export/json>
<require basic/import/json>
<require terminal/terminal>

<require ./ai/llama>

<using std>
<using ai>

$EXIT . # a special "handler"-value to exit the program

$PASTE_THRESHOLD 16 # when pasting text newlines are treated in a special way

# Cursor Movement (specified for each window)

$WITHIN_TEXT .
$ADD_SINGLE_LINE .
$ANYWHERE .

# Key Classes (used to decide about new history entries)

$MOVEMENT .
$SELECTION .
$DELETION .
$INSERTION .
$FOLDING .
$AI .
$COMMAND .
$OTHER .

# Features (specified for each window)

$HAS_HISTORY .
$ALLOW_SEARCH .
$ALLOW_NEW_LINE .

# Type of Boundary Used to Match Search Expressions

$WORD .
$LINE .

# Components of a TEDI line

$indent_of ()
$text_of ()
$mark_of ()
$folds_of ()
$tokens_of ()

$tedi_types::tedi_line tuple(undefined undefined undefined undefined undefined)
  # indent, text, mark, folds, tokens

$tedi_types::tedi_line/indent_of: (self) -> first(self)
$tedi_types::tedi_line/text_of: (self) -> second(self)
$tedi_types::tedi_line/mark_of: (self) -> third(self)
$tedi_types::tedi_line/folds_of: (self) -> fourth(self)
$tedi_types::tedi_line/tokens_of: (self) -> fifth(self)

# Additional Attributes for AI Models

$is_a_space_token_of ()
$space_tokens_of ()
$period_token_of ()

# State

$ai_model_of () # the ai-model object used for "ai completion"
$windows_of () # a list of all windows
$current_window_index_of () # the currently active window
$text_window_index_of () # the text window to work on
$completion_prefix_of () # used for "smart completion"
$possible_completions_of () # a list of all possibly matching completions
$action_of () # a deferred I/O-action
$search_text_of () # used for search (& replace)
$match_start_boundary_of () # search text must start at a boundary
$match_end_boundary_of () # search text must end at a boundary
$replacement_text_of () # used for search & replace
$clipboard_contents_of () # an internal clipboard used for all windows
$saved_revisions_of ()
  #
    a table containing the most recently saved revisions of each text window;
    indexed by the window id

# Window

  a "paragraph" is a long line that will be broken into "sub_lines" using soft
  line breaks

  a "sub_line" is a line within a "paragraph"

$id_of () # a unique value (currently an integer) to identify the window
$revision_no_of () # the total number of changes
$features_of () # a <hash_set> of the window's features
$key_bindings_of () # a <hash_table> of the window's key bindings
$previous_of () # the previous state of the window (history)
$redo_of () # the redo state of the window (history)
$lines_of () # the logical lines (paragraphs) of the window
$x_of () # the x-coordinate of the current paragraph including the line's indent
$y_of () # the index of the current paragraph
$sub_y_of () # the index of the current "sub_line" within its paragraph
$first_visible_y_of () # the index of the first visible paragraph
$first_visible_sub_y_of () # the first visible sub_line within this paragraph
$first_visible_x_of () # the first visible x-coordinate
$needs_redraw () # the contents were not changed but an update is necessary
$was_updated () # the window's lines were updated in some way
$cursor_x_of () # the cursor position measured from the start of the line
$cursor_y_of () # the cursor position measured from the window's top edge
$inbounds_width_of () # the soft line break width of the window
$upper_bound_of () # do not move the cursor above this window row
$lower_bound_of () # do not move the cursor below this window row
$do_keep_selection () # set by commands that alter the selection
$selection_start_x_of () # the selection spans the range between selection ...
$selection_start_y_of () # ... start and the current position
$cursor_movement_of () # restrictions that apply to the movement of the cursor
$use_soft_line_break_of () # break long lines at <inbounds_width>
$is_a_text_window () # is *not* a status window, etc.
$do_highlight_indentations_of () # show vertical lines at the start of each line
$do_highlight_cursor_line_of () # highlight the cursor's horizontal line
$colour_set_of () # the colour set to use for the window
$colour_set_no_of () # the colour set index of the currently active colour set
$do_define_mark_of () # expect a letter that defines a "mark"

# Colour Set

$text_colour_of ()
$background_colour_of () # the different background colours ...
$background_colour_2_of () # ... are used for ...
$background_colour_3_of () # ... indentation highlighting
$out_of_bounds_colour_of () # used for the area right of the "inbounds width"
$selection_colour_of () # used to highlight the selected text
$folds_colour_of () # used to highlight "folded" lines
$fake_folds_colour_of () # used to highlight folds that fold only whitespace
$bar_text_colour_of () # used for the title bar
$bar_background_colour_of () # used for the title bar
$indentation_patterns_of () # a precomputed pattern to display indents

# Start

program_parameters!
  $filename
  list
    MANDATORY_PARAMETER "filename" "
      the name of the text file to edit

# Optional Function Argument

$argument_of (!)

$functions
  hash_table
    # cursor movement

    "cursor_up" = tuple(cursor_up MOVEMENT)
    "cursor_down" = tuple(cursor_down MOVEMENT)
    "cursor_left" = tuple(cursor_left MOVEMENT)
    "cursor_right" = tuple(cursor_right MOVEMENT)

    "page_up" = tuple(page_up MOVEMENT)
    "page_down" = tuple(page_down MOVEMENT)
    "cursor_home" = tuple(cursor_home MOVEMENT)
    "cursor_end" = tuple(cursor_end MOVEMENT)

    "smart_cursor_up" = tuple(smart_cursor_up MOVEMENT)
    "smart_cursor_down" = tuple(smart_cursor_down MOVEMENT)
    "cursor_top" = tuple(cursor_top MOVEMENT)
    "cursor_bottom" = tuple(cursor_bottom MOVEMENT)

    # text selection

    "select_cursor_up" = tuple(select_cursor_up SELECTION)
    "select_cursor_down" = tuple(select_cursor_down SELECTION)
    "select_cursor_left" = tuple(select_cursor_left SELECTION)
    "select_cursor_right" = tuple(select_cursor_right SELECTION)

    "select_page_up" = tuple(select_page_up SELECTION)
    "select_page_down" = tuple(select_page_down SELECTION)
    "select_cursor_home" = tuple(select_cursor_home SELECTION)
    "select_cursor_end" = tuple(select_cursor_end SELECTION)

    "select_smart_cursor_up" = tuple(select_smart_cursor_up SELECTION)
    "select_smart_cursor_down" = tuple(select_smart_cursor_down SELECTION)
    "select_cursor_top" = tuple(select_cursor_top SELECTION)
    "select_cursor_bottom" = tuple(select_cursor_bottom SELECTION)

    # insert & delete

    "smart_indent" = tuple(smart_indent INSERTION)
    "smart_outdent" = tuple(smart_outdent INSERTION)
    "split_line" = tuple(split_line INSERTION)
    "delete_left" = tuple(delete_left DELETION)
    "delete_right" = tuple(delete_right DELETION)

    "delete_to_line_start" = tuple(delete_to_line_start DELETION)
    "delete_to_line_end" = tuple(delete_to_line_end DELETION)
    "smart_completion" = tuple(smart_completion INSERTION)
    "ai_completion" = tuple(ai_completion AI)
    "toggle_folding" = tuple(toggle_folding FOLDING)
    "fold_contents" = tuple(fold_contents FOLDING)
    "unfold_contents" = tuple(unfold_contents FOLDING)
    "fold_everything" = tuple(fold_everything FOLDING)
    "unfold_everything" = tuple(unfold_everything FOLDING)

    # control commands

    "copy" = tuple(copy OTHER)
    "define_mark" = tuple(define_mark OTHER)
    "find_text_dialog" = tuple(find_text_dialog OTHER)
    "go_to_line_dialog" = tuple(go_to_line_dialog OTHER)
    "join_lines" = tuple(join_lines DELETION)
    "delete_line" = tuple(delete_line DELETION)
    "find_next" = tuple(find_next MOVEMENT)
    "find_previous" = tuple(find_previous MOVEMENT)
    "save_contents" = tuple(save_contents OTHER)
    "save_with_leading_spaces" = tuple(save_with_leading_spaces OTHER)
    "paste" = tuple(paste INSERTION)
    "cut" = tuple(cut DELETION)

    # function keys

    "change_colour_set" = tuple(change_colour_set OTHER)
    =
      "toggle_indentation_highlighting"
      tuple(toggle_indentation_highlighting OTHER)
    =
      "toggle_cursor_line_highlighting"
      tuple(toggle_cursor_line_highlighting OTHER)
    "toggle_soft_line_break" = tuple(toggle_soft_line_break OTHER)

    # filter & action

    "filter" = tuple(filter_selection COMMAND)

$class_of empty_hash_table

load_file! $lines
on lines.is_an_error:
  eprint! "
    Unable to load file "@(filename)"!
  exit! EXIT_FAILURE

$editor_key_bindings
  hash_table
    # cursor movement

    CURSOR_UP = cursor_up
    CURSOR_DOWN = cursor_down
    CURSOR_LEFT = cursor_left
    CURSOR_RIGHT = cursor_right

    PAGE_UP = page_up
    PAGE_DOWN = page_down
    HOME = cursor_home
    END = cursor_end

    CTRL_CURSOR_UP = smart_cursor_up
    CTRL_CURSOR_DOWN = smart_cursor_down
    CTRL_HOME = cursor_top
    CTRL_END = cursor_bottom

    # text selection

    SHIFT_CURSOR_UP = select_cursor_up
    SHIFT_CURSOR_DOWN = select_cursor_down
    SHIFT_CURSOR_LEFT = select_cursor_left
    SHIFT_CURSOR_RIGHT = select_cursor_right

    SHIFT_PAGE_UP = select_page_up
    SHIFT_PAGE_DOWN = select_page_down
    SHIFT_HOME = select_cursor_home
    SHIFT_END = select_cursor_end

    SHIFT_CTRL_CURSOR_UP = select_smart_cursor_up
    SHIFT_CTRL_CURSOR_DOWN = select_smart_cursor_down
    SHIFT_CTRL_HOME = select_cursor_top
    SHIFT_CTRL_END = select_cursor_bottom

    # insert & delete

    TABULATOR = smart_indent
    SHIFT_TABULATOR = smart_outdent
    RETURN = split_line
    BACKSPACE = delete_left
    DELETE = delete_right

    CTRL_BACKSPACE = delete_to_line_start
    CTRL_DELETE = delete_to_line_end
    ALT_SPACE = smart_completion
    CTRL_SPACE = ai_completion
    ALT_RETURN = toggle_folding
    ALT_CURSOR_LEFT = fold_contents
    ALT_CURSOR_RIGHT = unfold_contents
    ALT_CURSOR_UP = fold_everything
    ALT_CURSOR_DOWN = unfold_everything

    # control commands

    CTRL_C = copy
    CTRL_D = define_mark
    CTRL_F = find_text_dialog
    CTRL_G = go_to_line_dialog
    CTRL_J = join_lines
    CTRL_K = delete_line
    CTRL_N = find_next
    CTRL_P = find_previous
    CTRL_Q = EXIT
    CTRL_S = save_contents
    CTRL_ALT_S = save_with_leading_spaces
    CTRL_V = paste
    CTRL_X = cut

    # function keys

    F2 = change_colour_set
    F3 = toggle_indentation_highlighting
    F4 = toggle_cursor_line_highlighting
    F5 = toggle_soft_line_break

$simple_key_bindings
  hash_table
    # cursor movement

    CURSOR_UP = cursor_up
    CURSOR_DOWN = cursor_down
    CURSOR_LEFT = cursor_left
    CURSOR_RIGHT = cursor_right

    HOME = cursor_home
    END = cursor_end

    CTRL_HOME = cursor_top
    CTRL_END = cursor_bottom

    BACKSPACE = delete_left
    DELETE = delete_right

    CTRL_BACKSPACE = delete_to_line_start
    CTRL_DELETE = delete_to_line_end
    ALT_SPACE = smart_completion

    # control commands

    CTRL_Q = EXIT

$search_key_bindings
  new
    simple_key_bindings

    # actions

    RETURN = start_search
    ESCAPE = cancel

    # control commands

    CTRL_C = copy
    CTRL_V = paste
    CTRL_X = cut
    CTRL_N = start_search
    CTRL_P = start_search

$redo_key CTRL_Y
$undo_key CTRL_Z

get_environment $environment
$configuration_filename append(environment("HOME") "/tedi.cfg")

$colour_sets
  list
    std_types::object
      .text_colour_of WHITE
      .background_colour_of '@0x0000e0;'
      .background_colour_2_of '@0x0000c8;'
      .background_colour_3_of '@0x0000b0;'
      .out_of_bounds_colour_of '@0x0000cc;'
      .selection_colour_of '@0x804000;'
      .folds_colour_of '@0x00a0ff;'
      .fake_folds_colour_of '@0x00c0ff;'
      .bar_text_colour_of BLACK
      .bar_background_colour_of WHITE
    std_types::object
      .text_colour_of WHITE
      .background_colour_of BLUE
      .background_colour_2_of '@0x0000f0;'
      .background_colour_3_of '@0x0000e8;'
      .out_of_bounds_colour_of '@0x0000c0;'
      .selection_colour_of '@0x804000;'
      .folds_colour_of '@0x00a0ff;'
      .fake_folds_colour_of '@0x00c0ff;'
      .bar_text_colour_of BLACK
      .bar_background_colour_of WHITE
    std_types::object
      .text_colour_of BLACK
      .background_colour_of WHITE
      .background_colour_2_of '@0xf4f4f4;'
      .background_colour_3_of '@0xe8e8e8;'
      .out_of_bounds_colour_of '@0xeeeeee;'
      .selection_colour_of YELLOW
      .folds_colour_of '@0xa0ffa0;'
      .fake_folds_colour_of '@0xe0ffe0;'
      .bar_text_colour_of WHITE
      .bar_background_colour_of BLACK
    std_types::object
      .text_colour_of WHITE
      .background_colour_of BLACK
      .background_colour_2_of '@0x000810;'
      .background_colour_3_of '@0x000e1c;'
      .out_of_bounds_colour_of '@0x111111;'
      .selection_colour_of '@0x804000;'
      .folds_colour_of '@0x004000;'
      .fake_folds_colour_of '@0x002000;'
      .bar_text_colour_of BLACK
      .bar_background_colour_of WHITE

$status_colour_set
  std_types::object
    .text_colour_of RED
    .background_colour_of YELLOW

map &colour_sets create_indentation_patterns

$prototype_window
  std_types::object
    .needs_redraw true
    .features_of empty_hash_set
    .x_of 1
    .y_of 1
    .cursor_x_of 1
    .cursor_y_of 1
    .sub_y_of 1
    .inbounds_width_of undefined
    .first_visible_y_of 1
    .first_visible_sub_y_of 1
    .first_visible_x_of 1
    .is_a_text_window false
    .upper_bound_of undefined
    .lower_bound_of undefined
    .do_keep_selection false
    .selection_start_x_of undefined
    .selection_start_y_of undefined
    .do_define_mark_of false
    .was_updated false
    .colour_set_no_of undefined
    .do_highlight_indentations_of false
    .do_highlight_cursor_line_of false
    .use_soft_line_break_of false

$go_to_key_bindings
  new
    simple_key_bindings

    # actions

    RETURN = go_to_line
    ESCAPE = cancel

    # control commands

    CTRL_C = copy
    CTRL_V = paste
    CTRL_X = cut

$window
  prototype_window
    .revision_no_of 0
    .features_of
      hash_set
	HAS_HISTORY
	ALLOW_SEARCH
	ALLOW_NEW_LINE
    .key_bindings_of editor_key_bindings
    .previous_of undefined
    .redo_of undefined
    .key_of undefined
    .lines_of lines
    .left_x_of 1
    .top_y_of 2
    .inbounds_width_of 80
    .is_a_text_window true
    .colour_set_of colour_sets(1)
    .colour_set_no_of 1
    .do_highlight_indentations_of true
    .do_highlight_cursor_line_of true
    .cursor_movement_of ANYWHERE

# Window Ids

$STATUS_WINDOW -1
$SEARCH_WINDOW -2
$GO_TO_WINDOW -3

$status_window
  prototype_window
    .id_of STATUS_WINDOW
    .lines_of tedi_line(0 "")
    .left_x_of 1
    .height_of 1
    .colour_set_of status_colour_set

$search_window
  prototype_window
    .id_of SEARCH_WINDOW
    .key_bindings_of search_key_bindings
    .key_of undefined
    .lines_of empty_list
    .left_x_of 1
    .height_of 1
    .colour_set_of colour_sets(3)
    .cursor_movement_of ADD_SINGLE_LINE

$go_to_window
  prototype_window
    .id_of GO_TO_WINDOW
    .key_bindings_of go_to_key_bindings
    .key_of undefined
    .lines_of empty_list
    .left_x_of 1
    .height_of 1
    .colour_set_of colour_sets(4)
    .cursor_movement_of ADD_SINGLE_LINE

$state undefined

$terminal undefined
$io std_types::io

$ai_model_name "codellama-13b.Q4_0.gguf"
$ai_server "127.0.0.1:8080"
$ai_context_size 2560

fstat! $stdout_info STDOUT_FILENO
fstat! $stderr_info STDERR_FILENO
$do_log
  ||
    inode_number_of(stderr_info) != inode_number_of(stdout_info)
    device_of(stderr_info) != device_of(stdout_info)

initialize_terminal!
  RECEIVE_CTRL_C_AND_CTRL_Z = true
  RECEIVE_CTRL_Q_AND_CTRL_S = true
  MAP_CR = true
  TITLE = filename
  main

$previous_window undefined

$main: (initial_terminal)
  !terminal initial_terminal

  $terminal_width width_of(terminal)
  $terminal_height height_of(terminal)
  $window_height terminal_height-2

  !window
    window
      .id_of 1
      .width_of terminal_width
      .height_of window_height
      .upper_bound_of 1+(window_height .div. 4)
      .lower_bound_of window_height-(window_height .div. 4)

  !status_window
    status_window
      .width_of terminal_width
      .top_y_of terminal_height
      .height_of 1

  !search_window
    search_window
      .width_of terminal_width
      .top_y_of terminal_height
      .height_of 1

  !go_to_window
    go_to_window
      .width_of terminal_width
      .top_y_of terminal_height
      .height_of 1

  load! $configuration configuration_filename
  if
    configuration.is_an_error # no configuration file found
    start_tedi
    :
      for_each split(configuration '@nl;')
	: (no line)
	  truncate_from &line '#'
	  normalize &line
	  if
	    line.is_empty
	    next
	    :
	      $name line .truncate_from. ' '
	      behind &line ' '
	      $value line .truncate_from. ' '
	      $argument line .behind. ' '
	      case name
		"ai-model":
		  !ai_model_name value
		  next!
		"ai-server":
		  !ai_server value
		  next!
		"ai-context-size":
		  !ai_context_size value.to_integer
		  next!
		:
		  $key key_names(name)
		  if
		    key.is_undefined:
		      eprint! "
			Invalid key name "@(name)" in line @(no)!
		      next!
		    :
		      case value
			"undefined":
			  if
			    key.is_defined:
			      !editor_key_bindings(key) undefined
			      next!
			    next
			"quit":
			  if
			    key.is_defined:
			      !editor_key_bindings(key) EXIT
			      !class_of(key) OTHER
			      next!
			    next
			"redo":
			  if
			    key.is_defined:
			      !redo_key key
			      !class_of(key) OTHER
			      next!
			    next
			"undo":
			  if
			    key.is_defined:
			      !undo_key key
			      !class_of(key) OTHER
			      next!
			    next
			:
			  $info functions(value)
			  if
			    info.is_undefined:
			      eprint! "
				Invalid function name "@(value)" in line @(no)!
			      next!
			    :
			      info $function $class
			      update_if argument.is_not_empty &function
				-> function(.argument_of argument)
			      !editor_key_bindings(key) function
			      !class_of(key) class
			      next!
	:
	  !window.key_bindings_of editor_key_bindings
	  start_tedi!

$start_tedi:
  !state
    std_types::object
      .ai_model_of undefined
      .windows_of
	list
	  window
	  go_to_window
	  search_window
	  status_window
      .current_window_index_of 1 # current window index
      .text_window_index_of 1
      .key_of undefined
      .completion_prefix_of undefined
      .possible_completions_of undefined
      .action_of undefined
      .clipboard_contents_of undefined
      .search_text_of undefined
      .replacement_text_of undefined
      .saved_revisions_of hash_table(1 = 0)

  !previous_window window
  update_display !terminal !state
  !previous_window windows_of(state)(cwi())
  update_terminal &terminal $initial_output
  print! initial_output

  start_injecting_window_change_events &io
  start_reading_from &io STDIN_FILENO

  event_loop! !terminal !state
  on terminal.is_an_error terminal

$event_loop:
  loop:
    get_events! &io $events
    for_each events
      : (event)
	event $type $fd $input
	case type
	  READ:
	    if
	      fd == STDIN_FILENO:
		from_utf8 &input
		if
		  &&
		    length_of(input) >= PASTE_THRESHOLD
		    input .contains. '@cr;'
		  :
		    extract_window_and_lines:
		      paste_text input !state
		      !window windows_of(state)(cwi())
		      !lines lines_of(window)
		      update_display !terminal !state
		      !previous_window windows_of(state)(cwi())
		      update_terminal &terminal $output
		      print! output
		      next!
		  :
		    $keys extract_keys(input).combine_characters
		    for_each keys
		      : (key)
			if
			  key.is_a_tuple:
			    key $action $new_width $new_height
			    case action
			      NEW_WINDOW_SIZE:
				resize &terminal new_width new_height
				extract_window_and_lines:
				  redraw_all!
			      next
			  :
			    !window windows_of(state)(cwi())
			    update_if
			      &&
				key != ALT_SPACE
				completion_prefix_of(state).is_defined
			      &state
			      ->
				state
				  .completion_prefix_of undefined
				  .possible_completions_of undefined

			    case key
			      redo_key: # redo
				if
				  ||
				    not(features_of(window)(HAS_HISTORY))
				    redo_of(window).is_undefined
				  next
				  :
				    $current_window window
				    !window redo_of(window)
				    !window.previous_of current_window
				    redraw_all!
			      undo_key: # undo
				if
				  ||
				    not(features_of(window)(HAS_HISTORY))
				    previous_of(window).is_undefined
				  next
				  :
				    $current_window window
				    !window previous_of(window)
				    !window.redo_of current_window
				    redraw_all!
			      :
				update_history !window key
				!state.windows_of(cwi()) window
				!lines lines_of(window)
				if
				  key.is_a_string:
				    if
				      do_define_mark_of(window):
					!window.do_define_mark_of false
					set_mark key(1) !state
					range &key 2 -1
					if
					  key.is_empty
					  next
					  :
					    !window windows_of(state)(cwi())
					    !lines lines_of(window)
					    insert_key!
				      insert_key

				    $insert_key:
				      insert !state key
				      maybe_remove_selection_and_update_display
					!terminal !state
				      next!
				  :
				    !state.key_of key
				    !window.key_of key # for history handling
				    !state.windows_of(cwi()) window
				    !window.do_define_mark_of false
				    $handler key_bindings_of(window)(key)
				    if
				      handler.is_undefined
				      next
				      :
					if
					  EXIT == handler
					  -> terminal state
					  :
					    handler !state
					    update!
		      :
			update_terminal &terminal $output
			print! output
			next!
	      next
	  next
      next

  $redraw_all:
    !window.needs_redraw true
    !state.windows_of(cwi()) window
    !lines lines_of(window)
    update_display !terminal !state
    !previous_window windows_of(state)(cwi())
    next!

  $update:
    $action action_of(state)
    if
      action.is_defined:
	!state.action_of undefined
	if
	  EXIT == action
	  -> terminal state
	  :
	    extract_window_and_lines:
	      action! !terminal !state
	      maybe_remove_selection_and_update_display !terminal !state
	      next!
      :
	maybe_remove_selection_and_update_display !terminal !state
	!previous_window windows_of(state)(cwi())
	next!

  $combine_characters: (keys)
    $combined empty_list
    $str ""
    for_each keys
      : (key)
	if
	  key.is_undefined
	  next
	  :
	    if
	      key.is_a_character:
		push &str key
		next
	      :
		if
		  str.is_empty:
		    push &combined key
		    next
		  :
		    push &combined str
		    push &combined key
		    !str ""
		    next
      :
	if
	  str.is_empty
	  -> combined
	  -> push(combined str)

  $maybe_remove_selection_and_update_display:
    extract_window_and_lines:
      update_if_not do_keep_selection(window)
	&window
	->
	  window
	    .selection_start_x_of undefined
	    .selection_start_y_of undefined
      !window.do_keep_selection false
      update_display !terminal !state
      -> terminal state


$update_history: (key)
  if_not
    features_of(window)(HAS_HISTORY)
    -> window(.key_of key)
    :
      if
	previous_of(window).is_undefined
	->
	  window
	    .previous_of window
	    .key_of key
	:
	  $previous_key key_of(window)
	  $class class_of(key)
	  if
	    class == OTHER || class == class_of(previous_key)
	    -> window(.key_of key)
	    ->
	      window
		.previous_of window
		.key_of key

$paste_text: (input)
  replace_all &input '@ht;' = "        "
  $s 1
  $n length_of(input)
  $i 0
  loop:
    inc &i
    if
      i > n:
	insert range(input s n)
      :
	case input(i)
	  '@nl;', '@cr;':
	    insert !state range(input s i-1)
	    extract_window_and_lines:
	      new_line !state
	      !window windows_of(state)(cwi())
	      !lines lines_of(window)
	      !s i+1
	      next
	  next

$select_page_up: select page_up
$select_page_down: select page_down
$select_cursor_home: select cursor_home
$select_cursor_end: select cursor_end
$select_cursor_up: select cursor_up
$select_cursor_down: select cursor_down
$select_cursor_left: select cursor_left
$select_cursor_right: select cursor_right
$select_cursor_top: select cursor_top
$select_cursor_bottom: select cursor_bottom
$select_smart_cursor_up: select smart_cursor_up
$select_smart_cursor_down: select smart_cursor_down

$select: (handler)
  !window.do_keep_selection true
  update_if selection_start_x_of(window).is_undefined &window
    ->
      window
	.selection_start_x_of x_of(window)
	.selection_start_y_of y_of(window)
  handler

$smart_cursor_down:
  $cursor_x cursor_x_of(window)
  $y y_of(window)
  $height length_of(lines)
  loop:
    inc &y
    if
      y <= height:
	$line lines(y)
	if
	  line.is_undefined || indent_of(line) >= cursor_x
	  next
	  :
	    !window
	      window
		.x_of cursor_x
		.y_of y
		.sub_y_of 1
		.cursor_x_of undefined
		.cursor_y_of undefined
	    return_window
      -> state

$page_down:
  cursor_down height_of(window)

$cursor_down: (dy = 1)
  !window
    window
      .x_of undefined
      .y_of undefined
      .sub_y_of undefined
      .cursor_y_of cursor_y_of(window)+dy
  return_window

$smart_cursor_up:
  $cursor_x cursor_x_of(window)
  $y y_of(window)
  loop:
    dec &y
    if
      y >= 1:
	$line lines(y)
	if
	  line.is_undefined || indent_of(line) >= cursor_x
	  next
	  :
	    !window
	      window
		.x_of cursor_x
		.y_of y
		.sub_y_of 1
		.cursor_x_of undefined
		.cursor_y_of undefined
	    return_window
      -> state

$page_up:
  cursor_up height_of(window)

$cursor_up: (dy = 1)
  !window
    window
      .x_of undefined
      .y_of undefined
      .sub_y_of undefined
      .cursor_y_of cursor_y_of(window)-dy
  return_window

$cursor_right: (dx = 1)
  $cursor_x cursor_x_of(window)
  $y y_of(window)
  if
    &&
      use_soft_line_break_of(window)
      cursor_x < first_position(y) || cursor_x > last_position(y)
    :
      !window
	window
	  .x_of undefined
	  .cursor_x_of cursor_x_of(window)+dx
      return_window
    :
      !window
	window
	  .x_of x_of(window)+dx
	  .sub_y_of undefined
	  .cursor_x_of undefined
	  .cursor_y_of undefined
      return_window

$cursor_left: (dx = 1)
  if
    &&
      use_soft_line_break_of(window)
      cursor_x_of(window) != first_position(y_of(window))
    :
      !window
	window
	  .x_of undefined
	  .cursor_x_of max(cursor_x_of(window)-dx 1)
      return_window
    :
      !window
	window
	  .x_of max(x_of(window)-dx 1)
	  .sub_y_of undefined
	  .cursor_x_of undefined
	  .cursor_y_of undefined
      return_window

$cursor_home:
  $pos first_position(y_of(window))
  !window
    window
      .x_of undefined
      .cursor_x_of
	if
	  cursor_x_of(window) == pos
	  -> 1
	  -> pos
  return_window

$cursor_end:
  !window
    window
      .x_of undefined
      .cursor_x_of last_position(y_of(window))
  return_window

$cursor_top:
  !window
    window
      .x_of 1
      .y_of 1
      .sub_y_of undefined
      .cursor_x_of undefined
      .cursor_y_of undefined
  return_window

$cursor_bottom:
  $line_count length_of(lines)
  !window
    window
      .x_of 1
      .y_of
	if
	  cursor_movement_of(window) == WITHIN_TEXT
	  -> line_count
	  -> line_count+1
      .sub_y_of 1
      .cursor_x_of undefined
      .cursor_y_of undefined
  return_window

$insert: (str)
  if
    str.is_empty
    -> state
    :
      $spaces_only str.contains_only_spaces
      $len length_of(str)
      $y y_of(window)
      $height length_of(lines)
      if
	y > height:
	  if
	    spaces_only:
	      cursor_right len
	    :
	      $insert_line_count y-height
	      !window.was_updated true
	      append &lines dup(list(undefined) insert_line_count)
	      insert_text
	insert_text

      $insert_text:
	$x x_of(window)
	$line lines(y)
	if $indent $text $mark $folds
	  line.is_undefined
	  -> x-1 "" "" undefined
	  : line
	$line_width indent+length_of(text)
	$idx x-indent
	if
	  x > line_width:
	    if
	      spaces_only:
		cursor_right len
	      :
		!window.was_updated true
		append &text spaces(x-(line_width+1)) str
		!lines(y) tedi_line(indent text mark folds)
		advance_cursor
	  :
	    !window.was_updated true
	    if
	      x > indent+1:
		!text append(range(text 1 idx-1) str range(text idx -1))
		!lines(y) tedi_line(indent text mark folds)
		advance_cursor
	      :
		!text append(str spaces(indent+1-x) text)
		!lines(y) tedi_line(x-1 text mark folds)
		advance_cursor

	$advance_cursor:
	  !window
	    window
	      .cursor_x_of undefined
	      .cursor_y_of undefined
	      .sub_y_of undefined
	      .x_of x_of(window)+len
	  return_window_and_lines

$insert_line: (str)
  $y y_of(window)
  $line_count length_of(lines)
  if
    y > line_count+1:
      !lines
	push
	  append(lines dup(list(undefined) y-line_count))
	  tedi_line(0 str)
      return
    :
      !lines append(push(range(lines 1 y-1) tedi_line(0 str)) range(lines y -1))
      return

  $return:
    !window
      window
	.cursor_x_of undefined
	.cursor_y_of undefined
	.sub_y_of undefined
	.x_of 1
	.y_of y+1
	.was_updated true
    return_window_and_lines

$contains_only_spaces: (str)
  all_of str: (chr) -> chr == ' '

$smart_indent:
  !window.do_keep_selection true
  $selection_start_y selection_start_y_of(window)
  $x x_of(window)
  if
    selection_start_y.is_undefined:
      $y y_of(window)
      if
	y > length_of(lines) || lines(y).is_undefined:
	  $indent_above find_next_indent_above(x y)
	  $indent_below find_next_indent_below(x y)
	  $indent
	    if
	      &&
		indent_above.is_defined
		||
		  indent_below.is_undefined
		  indent_above <= indent_below
		  indent_below < x
	      -> indent_above
	      -> indent_below
	  if
	    indent.is_defined && indent+1 > x
	    : cursor_right indent+1-x
	    : cursor_right 2
	:
	  lines(y) $indent $text $mark $folds
	  $indent_above find_next_indent_above(indent+1 y)
	  if
	    indent_above.is_defined && indent_above > indent:
	      !lines(y) tedi_line(indent_above text mark folds)
	      !window
		window
		  .x_of x+indent_above-indent
		  .was_updated true
	      return_window_and_lines
	    :
	      !lines(y) tedi_line(indent+2 text mark folds)
	      !window
		window
		  .x_of x+2
		  .was_updated true
	      return_window_and_lines
    :
      $y y_of(window)
      min_max !selection_start_y $selection_end_y y selection_start_y
      update_if selection_end_y > selection_start_y &selection_end_y:
	dec selection_end_y
      reduce_to &selection_end_y length_of(lines)
      $selected_lines range(lines selection_start_y selection_end_y)
      map &selected_lines
	: (line)
	  line $indent $text $mark $folds
	  if
	    line.is_undefined
	    -> undefined
	    -> tedi_line(indent+2 text mark folds)
      !lines
	append
	  range(lines 1 selection_start_y-1)
	  selected_lines
	  range(lines selection_end_y+1 -1)
      !window
	window
	  .x_of x+2
	  .was_updated true
      return_window_and_lines

$find_next_indent_above: (x y)
  reduce_to &y length_of(lines)+1
  loop:
    if
      y > 1:
	dec &y
	$line lines(y)
	if
	  line.is_undefined
	  next
	  :
	    line $indent
	    if
	      indent+1 > x
	      -> indent
	      -> undefined
      -> undefined

$find_next_indent_below: (x y)
  $n length_of(lines)
  loop:
    if
      y < n:
	inc &y
	$line lines(y)
	if
	  line.is_undefined
	  next
	  :
	    line $indent
	    if
	      indent+1 > x
	      -> indent
	      -> undefined
      -> undefined

$smart_outdent:
  !window.do_keep_selection true
  $x x_of(window)
  $y y_of(window)
  $selection_start_y selection_start_y_of(window)
  if
    selection_start_y.is_undefined:
      if
	y > length_of(lines) || lines(y).is_undefined:
	  $indent_above find_previous_indent_above(x y)
	  if
	    indent_above.is_defined && indent_above+1 < x
	    : cursor_left x-(indent_above+1)
	    : cursor_left 2
	:
	  lines(y) $indent $text $mark $folds
	  if
	    indent == 0
	    -> state
	    :
	      $indent_above find_previous_indent_above(indent+1 y)
	      if
		indent_above.is_defined && indent_above < indent:
		  !lines(y) tedi_line(indent_above text mark folds)
		  !window
		    window
		      .x_of max(x-(indent-indent_above) 1)
		      .was_updated true
		  return_window_and_lines
		:
		  !lines(y) tedi_line(max(indent-2 0) text mark folds)
		  !window
		    window
		      .x_of max(x-2 1)
		      .was_updated true
		  return_window_and_lines
    :
      min_max !selection_start_y $selection_end_y y selection_start_y
      update_if selection_end_y > selection_start_y &selection_end_y:
	dec selection_end_y
      reduce_to &selection_end_y length_of(lines)
      $selected_lines range(lines selection_start_y selection_end_y)
      if
	all_of
	  selected_lines: (line) -> line.is_undefined || indent_of(line) >= 2
	:
	  map &selected_lines
	    : (line)
	      line $_indent $_text $mark $folds
	      if
		line.is_undefined
		-> undefined
		-> tedi_line(indent_of(line)-2 text_of(line) mark folds)
	  !lines
	    append
	      range(lines 1 selection_start_y-1)
	      selected_lines
	      range(lines selection_end_y+1 -1)
	  !window
	    window
	      .x_of max(x-2 1)
	      .was_updated true
	  return_window_and_lines
	return_window_and_lines

$find_previous_indent_above: (x y)
  reduce_to &y length_of(lines)+1
  loop:
    if
      y > 1:
	dec &y
	$line lines(y)
	if
	  line.is_undefined
	  next
	  :
	    line $indent
	    if
	      indent+1 < x
	      -> indent
	      next
      -> undefined

$new_line:
  $y y_of(window)
  if
    y > length_of(lines):
      !window.x_of 1
      !window.y_of y+1
      return_window
    :
      !lines append(push(range(lines 1 y) undefined) range(lines y+1 -1))
      !window
	window
	  .cursor_x_of undefined
	  .cursor_y_of undefined
	  .sub_y_of undefined
	  .x_of 1
	  .y_of y+1
	  .was_updated true
      return_window_and_lines

$split_line:
  $x x_of(window)
  $y y_of(window)
  $height length_of(lines)
  !window
    window
      .cursor_x_of undefined
      .cursor_y_of undefined
      .sub_y_of undefined
  if
    y > length_of(lines):
      !window.y_of y+1
      !window.x_of 1
      return_window
    :
      $line lines(y)
      if
	line.is_defined:
	  line $indent $text $mark $folds
	  cond
	    -> x <= indent+1:
	      !lines
		append(push(range(lines 1 y-1) undefined) range(lines y -1))
	      !window
		window
		  .y_of y+1
		  .was_updated true
	      return_window_and_lines
	    -> x > indent+length_of(text):
	      if
		y == height:
		  !window
		    window
		      .x_of indent+1
		      .y_of y+1
		  return_window
		:
		  insert_empty_line indent
	    -> true:
	      if
		text != "" || y < length_of(lines):
		  !lines
		    append
		      push
			push
			  range(lines 1 y-1)
			  tedi_line(indent range(text 1 x-(indent+1)) mark folds)
			tedi_line
			  indent range(text x-indent -1).trim_left mark folds
		      range(lines y+1 -1)
		  !window
		    window
		      .x_of indent+1
		      .y_of y+1
		      .was_updated true
		  return_window_and_lines
		:
		  !window
		    window
		      .x_of indent+1
		      .y_of y+1
		  return_window_and_lines
	:
	  insert_empty_line 0

  $insert_empty_line: (indent)
    !lines append(push(range(lines 1 y) undefined) range(lines y+1 -1))
    !window
      window
	.cursor_x_of undefined
	.cursor_y_of undefined
	.sub_y_of undefined
	.x_of indent+1
	.y_of y+1
	.was_updated true
    return_window_and_lines

$delete_left:
  $x x_of(window)
  $y y_of(window)
  if
    x > 1:
      if
	y > length_of(lines)
	cursor_left
	:
	  $line lines(y)
	  if
	    line.is_undefined
	    cursor_left
	    :
	      line $indent $text $mark $folds
	      cond
		-> x <= indent+1:
		  !window.x_of x-1
		  update_lines_after_deletion y tedi_line(indent-1 text)
		-> x > indent+length_of(text)+1 cursor_left
		-> true:
		  !window.x_of x-1
		  !text
		    append(range(text 1 x-(indent+2)) range(text x-indent -1))
		  update_lines_after_deletion y
		    tedi_line(indent text mark folds)
    -> state

$delete_right:
  $x x_of(window)
  $y y_of(window)
  if
    y > length_of(lines)
    -> state
    :
      $line lines(y)
      if
	line.is_undefined
	-> state
	:
	  line $indent $text $mark $folds

	  cond
	    -> x <= indent:
	      update_lines_after_deletion y tedi_line(indent-1 text)
	    -> x > indent+length_of(text)
	      -> state
	    -> true:
	      !text append(range(text 1 x-(indent+1)) range(text x+1-indent -1))
	      update_lines_after_deletion y tedi_line(indent text mark folds)

$delete_line:
  $y y_of(window)
  $height length_of(lines)
  if
    y > height
    -> state
    :
      if
	y == height:
	  update_lines_after_deletion y undefined
	:
	  !window
	    window
	      .was_updated true
	      .x_of undefined
	      .y_of undefined
	      .sub_y_of undefined
	      .cursor_y_of cursor_y_of(window)-sub_y_of(window)+1
	  !lines append(range(lines 1 y-1) range(lines y+1 height))
	  return_window_and_lines

$delete_to_line_start:
  $y y_of(window)
  if
    y > length_of(lines)
    cursor_home
    :
      $line lines(y)
      if
	line.is_undefined
	cursor_home
	:
	  line $indent $text $mark $folds
	  $x x_of(window)
	  $width indent+length_of(text)
	  cond
	    -> x > width:
	      !window.x_of indent+1
	      update_lines_after_deletion y undefined
	    -> x <= indent+1:
	      update_lines_after_deletion y tedi_line(x-1 text mark folds)
	    -> true:
	      !window.x_of indent+1
	      update_lines_after_deletion y
		tedi_line(indent range(text x-indent -1) mark folds)

$delete_to_line_end:
  $y y_of(window)
  if
    y > length_of(lines)
    -> state
    :
      $line lines(y)
      if
	line.is_undefined
	-> state
	:
	  line $indent $text $mark $folds
	  $x x_of(window)
	  $width indent+length_of(text)
	  cond
	    -> x > width
	      -> state
	    -> x <= indent+1:
	      update_lines_after_deletion y undefined
	    -> true:
	      update_lines_after_deletion y
		tedi_line(indent range(text 1 (x-1)-indent) mark folds)

$update_lines_after_deletion: (y line)
  !window
    window
      .cursor_x_of undefined
      .cursor_y_of undefined
      .sub_y_of undefined
      .was_updated true
  $height length_of(lines)
  if
    line.is_undefined && y == height: # removing last line
      loop:
	dec &y
	if
	  y > 0 && lines(y).is_undefined
	  next
	  :
	    range &lines 1 y
	    return_window_and_lines
    :
      !lines(y) line
      return_window_and_lines

$join_lines:
  $x x_of(window)
  $y y_of(window)
  $height length_of(lines)
  if
    y > height:
      if
	y == height+1
	go_to_end_of_previous_line
	cursor_up
    :
      $line lines(y)
      if
	line.is_undefined:
	  !window.was_updated true
	  if
	    y == 1:
	      range &lines 2 -1
	      $line_below lines(y) # this line must exist
	      if
		line_below.is_undefined
		-> state
		:
		  !window.x_of indent_of(line_below)+1
		  return_window
	    :
	      !lines append(range(lines 1 y-1) range(lines y+1 -1))
	      $line_above lines(y-1)
	      if
		line_above.is_undefined:
		  !window.y_of y-1
		  return_window_and_lines
		:
		  $line_below lines(y)
		  if
		    line_below.is_undefined
		    return_window_and_lines
		    go_to_end_of_previous_line
	:
	  line $indent $text $mark $folds
	  $width indent+length_of(text)
	  cond
	    -> x <= indent+1 && y > 1: # join with line above
	      !window.was_updated true
	      $line_above lines(y-1)
	      if
		line_above.is_undefined:
		  !window.y_of y-1
		  !lines append(range(lines 1 y-2) range(lines y -1))
		  return_window_and_lines
		:
		  line_above $indent_above $text_above
		  $length_above indent_above+length_of(text_above)
		  update_if indent >= 1 &text_above: push text_above ' '
		  append text_above &text
		  !window
		    window
		      .x_of length_above+if(x > 1 (-> 2) (-> 1))
		      .y_of y-1
		  !lines
		    append
		      push
			range(lines 1 y-2)
			tedi_line(indent_above text mark folds)
		      range(lines y+1 -1)
		  return_window_and_lines
	    -> x > width && y < height: # join with line below
	      !window.was_updated true
	      $line_below lines(y+1)
	      if
		line_below.is_undefined:
		  !window.y_of y
		  !lines append(range(lines 1 y) range(lines y+2 -1))
		  return_window_and_lines
		:
		  line_below $indent_below $text_below
		  update_if x > width+1 || indent_below >= 1 &text:
		    push text ' '
		  append &text text_below
		  !window.x_of width+if(x > width+1 (-> 2) (-> 1))
		  !lines
		    append
		      push
			range(lines 1 y-1)
			tedi_line(indent text mark folds)
		      range(lines y+2 -1)
		  return_window_and_lines
	    -> true
	      -> state

  $go_to_end_of_previous_line:
    $line_above lines(y-1)
    line_above $indent_above $text_above
    $length_above indent_above+length_of(text_above)
    !window
      window
	.x_of length_above+if(x == 1 (-> 1) (-> 2))
	.y_of y-1
    return_window_and_lines

$save_contents -> state(.action_of save_contents_action)

$save_contents_action:
  save! filename lines_to_text(lines)
  !state.saved_revisions_of(id_of(window)) revision_no_of(window)
  -> terminal state

$save_with_leading_spaces -> state(.action_of save_with_leading_spaces_action)

$save_with_leading_spaces_action:
  save! filename lines_to_spaced_text(lines)
  !state.saved_revisions_of(id_of(window)) revision_no_of(window)
  -> terminal state

$lines_to_text: (some_lines)
  map_reduce some_lines
    : (line)
      if
	line.is_defined:
	  line $indent $text $_mark $folds
	  $line_text append(tabs_and_spaces(indent) text.to_utf8 "@nl;")
	  if
	    folds.is_defined
	    -> append(line_text lines_to_text(folds))
	    -> line_text
	-> "@nl;"
    append
    ""

$lines_to_spaced_text: (some_lines)
  map_reduce some_lines
    : (line)
      if
	line.is_defined:
	  line $indent $text $_mark $folds
	  $line_text append(spaces(indent) text.to_utf8 "@nl;")
	  if
	    folds.is_defined
	    -> append(line_text lines_to_spaced_text(folds))
	    -> line_text
	-> "@nl;"
    append
    ""

$smart_completion:
  $x x_of(window)
  $y y_of(window)
  $completion_prefix completion_prefix_of(state)
  if
    completion_prefix.is_defined:
      $possible_completions possible_completions_of(state)
      $line lines(y)
      line $indent $text $mark $folds
      $first first_item_of(possible_completions)
      $left range(text 1 x-(indent+1+length_of(first)))
      $right range(text x-indent -1)
      minus &x length_of(first)
      !possible_completions(first) false
      !first first_item_of(possible_completions)
      !window.was_updated true
      if
	possible_completions.is_empty:
	  !lines(y)
	    tedi_line(indent append(left completion_prefix right) mark folds)
	  !window
	    window
	      .cursor_x_of undefined
	      .cursor_y_of undefined
	      .sub_y_of undefined
	      .x_of x+length_of(completion_prefix)
	  !state.completion_prefix_of undefined
	  !state.possible_completions_of undefined
	  return_window_and_lines
	:
	  !lines(y)
	    tedi_line(indent append(left first right) mark folds)
	  !window
	    window
	      .cursor_x_of undefined
	      .cursor_y_of undefined
	      .sub_y_of undefined
	      .x_of x+length_of(first)
	  !state.possible_completions_of possible_completions
	  return_window_and_lines
    :
      $height length_of(lines)
      if
	y > height:
	  complete_prefix ""
	:
	  $line lines(y)
	  if
	    line.is_undefined:
	      complete_prefix ""
	    :
	      line $indent $text
	      $width indent+length_of(text)
	      if
		x <= indent || x > width+1:
		  complete_prefix ""
		:
		  $e x-indent
		  $s e
		  loop:
		    if
		      s > 1 && text(s-1).is_an_identifier_character:
			dec &s
			next
		      :
			complete_prefix range(text s e-1)

$complete_prefix: (prefix)
  !window windows_of(state)(text_window_index_of(state))
  !lines lines_of(window)
  $y y_of(window)
  $height length_of(lines)
  $words empty_insert_order_set
  split $left_part $mid_part $right_part

  update_if cwi() != text_window_index_of(state)
    &words: collect_words mid_part false
    #
      do not use the word at the cursor position for completion unless we're in
      a "dialog box"
  collect_words !words left_part true
  collect_words !words right_part false
  $dy 0
  loop:
    inc &dy
    $upper_y y-dy
    $lower_y y+dy
    if
      upper_y < 1 && lower_y > height:
	if
	  words.is_empty
	  -> state
	  :
	    !state.completion_prefix_of prefix
	    !state.possible_completions_of words
	    !window windows_of(state)(cwi())
	    !lines lines_of(window)
	    insert range(first_item_of(words) length_of(prefix)+1 -1)
      :
	update_if upper_y >= 1 &words: add_words upper_y true
	update_if lower_y <= height &words: add_words lower_y false
	next

  $split:
    $line lines(y)
    if
      line.is_undefined
      -> undefined undefined undefined
      :
	line $indent $text
	$x x_of(window)
	cond
	  -> x <= indent -> "" "" text
	  -> x > indent+length_of(text) -> text "" ""
	  -> true:
	    minus &x indent
	    $left trim_right(range(text 1 x-1) is_an_identifier_character)
	    $right trim_left(range(text x -1) is_an_identifier_character)
	    ->
	      left
	      range(text length_of(left)+1 -(length_of(right)+1))
	      right

  $add_words: (line_no right_to_left)
    $line lines(line_no)
    if
      line.is_undefined
      -> words
      :
	collect_words text_of(line) right_to_left

  $collect_words: (text right_to_left)
    cond
      -> text.is_undefined -> empty_list
      -> right_to_left:
	$i length_of(text)+1
	$e undefined
	loop:
	  dec &i
	  if
	    i < 1:
	      if
		e.is_defined
		-> add_word(range(text 1 e))
		-> words
	    :
	      if
		text(i).is_an_identifier_character:
		  update_if e.is_undefined &e -> i
		  next
		:
		  if
		    e.is_defined:
		      add_word !words range(text i+1 e)
		      !e undefined
		      next
		    next
      -> true:
	$n length_of(text)
	$i 0
	$s undefined
	loop:
	  inc &i
	  if
	    i > n:
	      if
		s.is_defined
		-> add_word(range(text s n))
		-> words
	    :
	      if
		text(i).is_an_identifier_character:
		  update_if s.is_undefined &s -> i
		  next
		:
		  if
		    s.is_defined:
		      add_word !words range(text s i-1)
		      !s undefined
		      next
		    next

  $add_word: (word)
    if
      &&
	word .has_prefix. prefix
	word != prefix
	not(words(word))
      -> words(word true)
      -> words

$is_an_identifier_character: (chr)
  -> chr.is_a_letter_character || chr.is_a_digit || chr == '_'

$ai_completion -> state(.action_of ai_completion_action)

$ai_completion_action:
  on do_log:
    eprint! "
      --------------------
  current_time! $t1
  $t2 undefined
  $ai_model ai_model_of(state)
  if
    ai_model.is_defined
    check_tokens
    :
      initialize_ai! !ai_model
      current_time! !t2
      on do_log:
	edump `ai_model
	eprintln!
	  format("%2.3: loading model " t2-t1)
      !t1 t2
      if
	ai_model.is_an_error:
	  on do_log: eprint! debug_string(ai_model 0 10)
	  -> terminal state
	:
	  !state.ai_model_of ai_model
	  check_tokens!

  $check_tokens:
    get_not_tokenized_lines $line_numbers $line_texts
    if
      line_numbers.is_empty
      attempt_completion
      :
	tokenize! ai_model line_texts $line_tokens
	update_tokens !lines line_numbers line_tokens
	current_time! !t2
	on do_log: eprintln! format("%2.3: tokenize " t2-t1)
	!t1 t2
	attempt_completion!

  $attempt_completion:
    line_start_tokens x_of(window) $cx $tokens $suffix
    $at_line_start tokens.is_empty
    $start_tokens empty_list
    $sy 0
    $cy y_of(window)
    $half_context_size (context_size_of(ai_model) .div. 2)-64
    loop !sy !start_tokens:
      inc &sy
      if
	sy >= cy
	-> sy-1 start_tokens
	:
	  line_to_tokens $line_tokens sy
	  if
	    length_of(start_tokens)+length_of(line_tokens) > half_context_size
	    -> sy-1 start_tokens
	    :
	      append &start_tokens line_tokens
	      next
    loop !tokens:
      dec &cy
      if
	cy <= sy
	-> tokens
	:
	  line_to_tokens $line_tokens cy
	  if
	    length_of(line_tokens)+length_of(tokens) > half_context_size
	    -> tokens
	    :
	      append line_tokens &tokens
	      next
    append start_tokens &tokens
    $newline_token newline_token_of(ai_model)
    $first_token tokens(1)
    update_if_not
      is_a_space_token_of(ai_model)(first_token) || first_token == newline_token
      &tokens -> put(tokens space_token_of(ai_model))
    on do_log:
      $detokenized_text detokenize(ai_model tokens)
      debug_write "
	prompt length: @(length_of(tokens)) tokens
      $line_count count_occurrences(detokenized_text '@nl;')
      if
	line_count > 7:
	  debug_write "prompt = "
	  debug_print truncate_from(detokenized_text '@nl;' 3)
	  debug_write "..."
	  debug_print truncate_until(detokenized_text '@nl;' -4)
	:
	  debug_print detokenized_text
      debug_write "suffix = "
      debug_print detokenize(ai_model suffix)
    $n length_of(tokens)
    $rest empty_list
    $generated_tokens_count 0
    loop:
      current_time! $t3
      evaluate! ai_model $token tokens SMART length_of(start_tokens)
      inc &generated_tokens_count
      if
	token == -1
	-> terminal state
	:
	  current_time! $t4
	  detokenize ai_model token $piece &rest
	  on do_log:
	    eprint!
	      format("%2.3: %5 " t4-t3 token)
	      '@quot;' escaped_piece(piece) '@quot;'
	    if
	      rest.is_empty:
		eprintln!
	      :
		edump `rest
	  $end_of_text_token end_of_text_token_of(ai_model)
	  $period_token period_token_of(ai_model)
	  $use_soft_line_break use_soft_line_break_of(window)
	  if!
	    &&
	      generated_tokens_count < 50
	      token != newline_token
	      token != end_of_text_token
	      not(use_soft_line_break) || token != period_token
	    :
	      push &tokens token
	      next!
	    :
	      # tokenization is so fast that we do not store the returned tokens

	      update_if token == period_token &tokens: push tokens token
	      $ai_text detokenize(ai_model range(tokens n+1 -1))
	      on do_log: edump `ai_text
	      if
		ai_text.is_empty:
		  if
		    token == newline_token
		    -> terminal split_line()
		    -> terminal state
		:
		  !window.previous_of window
		  !window
		    window
		      .cursor_x_of undefined
		      .cursor_y_of undefined
		      .sub_y_of undefined
		      .x_of cx
		  update_if at_line_start && ai_text(1) == ' '
		    &ai_text -> range(ai_text 2 -1)
		  if
		    token == newline_token && at_line_start
		    -> terminal insert_line(ai_text)
		    -> terminal insert(ai_text)

  $line_to_tokens: (y)
    if
      y > length_of(lines)
      -> list(newline_token_of(ai_model))
      :
	$line lines(y)
	if
	  line.is_defined:
	    line $indent $_text $_mark $_folds $tokens
	    push indented_tokens(indent tokens) newline_token_of(ai_model)
	  -> list(newline_token_of(ai_model))

  $get_not_tokenized_lines:
    $line_numbers empty_list
    $line_texts empty_list
    for_each lines
      : (no line)
	if
	  line.is_undefined
	  next
	  :
	    line $_indent $text $_mark $_folds $tokens
	    if
	      tokens.is_defined
	      next
	      :
		push &line_numbers no
		push &line_texts text
		next
      -> line_numbers line_texts

  $update_tokens: (line_numbers line_tokens)
    for_each line_numbers
      : (idx no)
	lines(no) $indent $text $mark $folds
	!lines(no)
	  new(tedi_types::tedi_line indent text mark folds line_tokens(idx))
	next
      -> lines

$line_start_tokens:
  #
    return a list of tokens corresponding to the text from the line start
    (including indent) to the current cursor position;
    a trailing space is ignored, because this would harm the tokenization
  $y y_of(window)
  if
    y > length_of(lines)
    -> 1 empty_list empty_list
    :
      $line lines(y)
      if
	line.is_undefined
	-> 1 empty_list empty_list
	:
	  line $indent $_text $_mark $_folds $tokens
	  $x x_of(window)
	  $cx indent+1
	  if
	    x <= cx
	    -> 1 empty_list tokens
	    :
	      $ai_model ai_model_of(state)
	      $rest empty_list
	      for_each tokens
		: (i token)
		  detokenize ai_model token $piece &rest
		  $len length_of(piece)
		  plus &cx
		    if
		      i == 1 && piece(1) == ' '
		      -> len-1
		      -> len
		  if
		    cx <= x
		    next
		    :
		      if
			i == 1
			-> 1 empty_list tokens
			:
			  return
			    range(tokens 1 i)
			    range(tokens i+1 -1)
		:
		  return tokens empty_list

	      $return: (prefix suffix)
		-> cx indented_tokens(indent prefix) suffix

$indented_tokens: (indent tokens)
  if
    tokens.is_empty
    -> empty_list
    :
      $ai_model ai_model_of(state)
      $first_token tokens(1)
      $first_piece detokenize(ai_model first_token)
      $is_spaced first_piece(1) == ' '
      if
	indent > 0:
	  update_if_not is_spaced &indent -> indent+1
	  -> append(space_tokens_of(ai_model)(indent) tokens)
	:
	  if
	    is_spaced
	    -> tokens
	    -> put(tokens space_token_of(ai_model))

$initialize_ai:
   load_ai_model! $model ai_model_name ai_server
   reduce_to &model.context_size_of ai_context_size
   if
     model.is_an_error
     -> model
     :
       $space_token empty_list
       $is_a_space_token empty_hash_set
       from_to 1 16
	 : (i)
	   $token piece_table_of(model)(spaces(i))
	   push &space_token token
	   if
	     token.is_defined:
	       !is_a_space_token(token) true
	       next
	     next
	 :
	   !model.period_token_of piece_table_of(model)(".")
	   $space_tokens empty_list
	   $tokens empty_list
	   from_to 1 80
	     : (i)
	       $n i .mod. 16
	       if
		 n == 0:
		   push &tokens space_token(16)
		   push &space_tokens tokens
		   next
		 :
		   $piece space_token(n)
		   if
		     piece.is_defined:
		       push &space_tokens push(tokens piece)
		       next
		     : # the desired number of spaces is not a single token
		       push &space_tokens
			 push(push(tokens space_token(n-1)) space_token(1))
		       next
	     ->
	       model
		 .is_a_space_token_of is_a_space_token
		 .space_tokens_of space_tokens

$filter_selection: (myself^)
  -> state(.action_of filter_selection_action(.argument_of argument_of(myself)))

$filter_selection_action: (myself^)
  $filter_command argument_of(myself)
  on do_log: debug_write "
    filter_selection_action "@(filter_command)"
  get_spaced_selection_text $text
  if
    text.is_undefined
    -> terminal state
    :
      on do_log: debug_write "
	@(text)
      extern $command filter_command
      pipe! $ret_list $out $_err_list text command
      if
	ret_list(1) == 0:
	  on do_log: debug_write out
	  update_if out .contains. '@nl;' &out:
	    $raw_lines split(out '@nl;')
	    map raw_lines: (line) tedi_line 0 line.trim_right
	  cut !state
	  ->
	    terminal
	    extract_window_and_lines(: paste_contents out)
	-> terminal state

$get_spaced_selection_text:
  $selection_start_y selection_start_y_of(window)
  $line_count length_of(lines)
  if
    selection_start_y_of.is_undefined
    -> undefined
    :
      $y y_of(window)
      if
	y != selection_start_y: # multi-line selection
	  min_max &selection_start_y &y
	  !y min(y-1 line_count)
	  -> lines_to_spaced_text(range(lines selection_start_y y))
	:
	  if
	    y > line_count
	    -> undefined
	    :
	      $line lines(y)
	      if
		line.is_undefined
		-> undefined
		:
		  line $indent $text
		  $selection_start_x selection_start_x_of(window)
		  $x x_of(window)
		  min_max &selection_start_x &x
		  append spaces(indent) &text
		  !x min(x-1 length_of(text))
		  -> range(text selection_start_x x)

$copy: cut_or_copy false

$cut: cut_or_copy true

$cut_or_copy: (do_cut)
  $selection_start_x selection_start_x_of(window)
  $selection_start_y selection_start_y_of(window)
  if
    selection_start_y.is_undefined
    -> state
    :
      !window.selection_start_x_of undefined
      !window.selection_start_y_of undefined
      $y y_of(window)
      $height length_of(lines)
      min_max_minus_1 !selection_start_y $selection_end_y y selection_start_y
      if
	selection_end_y < selection_start_y:
	  if
	    y > height || lines(y).is_undefined
	    -> state
	    :
	      $line lines(y)
	      line $indent $text $mark $folds
	      $width indent+length_of(text)
	      $x min(x_of(window) width+1)
	      min_max !selection_start_x $selection_end_x x selection_start_x
	      $s max(selection_start_x-indent 1)
	      $e min((selection_end_x-1)-indent length_of(text))
	      $contents range(text s e)
	      if
		contents.is_empty
		return_window
		:
		  !state.clipboard_contents_of contents
		  if
		    do_cut
		    :
		      !window
			window
			  .cursor_x_of undefined
			  .cursor_y_of undefined
			  .sub_y_of undefined
			  .x_of selection_start_x
			  .was_updated true
		      !lines(y)
			tedi_line
			  indent
			  append(range(text 1 s-1) range(text e+1 -1))
			  mark
			  folds
		      return_window_and_lines
		    return_window
	:
	  $contents
	    if
	      selection_start_y > height
	      -> empty_list
	      -> range(lines selection_start_y min(selection_end_y height))
	  update_if selection_end_y > height &contents ->
	    append
	      contents
	      dup
		list(undefined)
		selection_end_y-max(selection_start_y-1 height)
	  !state.clipboard_contents_of contents
	  if
	    do_cut:
	      !window
		window
		  .cursor_x_of undefined
		  .cursor_y_of undefined
		  .sub_y_of undefined
		  .x_of 1
		  .y_of selection_start_y
	      !window.was_updated true
	      if
		selection_start_y > height
		return_window
		:
		  if
		    selection_end_y < height:
		      !lines
			append
			  range(lines 1 selection_start_y-1)
			  range(lines selection_end_y+1 -1)
		      return_window_and_lines
		    :
		      range &lines 1 selection_start_y-1
		      return_window_and_lines
	    return_window

$paste:
  paste_contents clipboard_contents_of(state)

$paste_contents: (contents)
  if
    contents.is_defined:
      if
	contents.is_a_string:
	  insert contents
	:
	  $y y_of(window)
	  if
	    y > length_of(lines):
	      $insert_line_count y-length_of(lines)
	      append &lines dup(list(undefined) insert_line_count)
	      insert_lines
	    insert_lines

	  $insert_lines:
	    !lines
	      trim_lines
		append
		  range(lines 1 y-1)
		  contents
		  range(lines y -1)
	    !window
	      window
		.cursor_x_of undefined
		.cursor_y_of undefined
		.sub_y_of undefined
		.y_of y+length_of(contents)
		.was_updated true
	    return_window_and_lines
    -> state

$trim_lines: (updated_lines)
  $y length_of(updated_lines)
  if
    updated_lines(y).is_defined
    -> updated_lines
    :
      loop:
	dec &y
	if
	  y > 0 && updated_lines(y).is_undefined
	  next
	  -> range(updated_lines 1 y)

$find_text_dialog:
  $windows windows_of(state)
  !window windows(SEARCH_WINDOW)
  !lines lines_of(window)
  !window
    window
      .cursor_x_of undefined
      .cursor_y_of undefined
      .sub_y_of undefined
      .x_of 1
      .y_of
	if
	  lines.is_defined
	  -> length_of(lines)+1
	  -> 1
  !windows(SEARCH_WINDOW) window
  ->
    state
      .text_window_index_of cwi()
      .current_window_index_of SEARCH_WINDOW
      .windows_of windows

$start_search:
  # get search string
  $x x_of(window)
  $y y_of(window)
  $line
    if
      y > length_of(lines)
      -> undefined
      -> lines(y)
  if
    line.is_undefined:
      if
	x > 1:
	  search_for_text dup(" " x-1)
	:
	  -> state(.current_window_index_of text_window_index_of(state))
    :
      line $indent $text
      append spaces(indent) &text
      $len length_of(text)
      if
	x > len+1:
	  search_for_text append(text spaces(x-1-len))
	:
	  search_for_text text

$search_for_text: (text)
  $search_text ""
  $replacement_text undefined
  $match_start_boundary false
  $match_end_boundary undefined
  $escaped false
  $len length_of(text)
  for_each text
    : (idx chr)
      if
	escaped:
	  !escaped false
	  add_character
	:
	  case chr
	    '\':
	      !escaped true
	      next
	    '%':
	      if
		search_text.is_empty:
		  !match_start_boundary WORD
		  next
		:
		  if
		    idx == len || text(idx+1) == '/':
		      !match_end_boundary WORD
		      next
		    add_character
	    '^':
	      if
		search_text.is_empty:
		  !match_start_boundary LINE
		  next
		add_character
	    '$':
	      if
		idx == len || text(idx+1) == '/':
		  !match_end_boundary LINE
		  next
		add_character
	    '/':
	      if
		replacement_text.is_defined
		-> state # error
		:
		  !replacement_text ""
		  next
	    add_character

      $add_character:
	if
	  replacement_text.is_defined:
	    push &replacement_text chr
	    next
	  :
	    push &search_text chr
	    next
    :
      # switch back to text window:
      !state.current_window_index_of text_window_index_of(state)

      !state.search_text_of search_text
      !state.match_start_boundary_of match_start_boundary
      !state.match_end_boundary_of match_end_boundary
      !state.replacement_text_of replacement_text
      !window windows_of(state)(cwi())
      !lines lines_of(window)
      if
	key_of(state) == CTRL_P:
	  find_previous max(x_of(window) 1)
	:
	  find_next
	    max
	      x_of(window)-length_of(search_text)
	      first_position(y_of(window))

$find_next: (x = undefined)
  $search_text search_text_of(state)
  if
    search_text.is_undefined
    -> state
    :
      if
	&&
	  replacement_text_of(state).is_defined
	  search_text == selected_text()
	replace_selection
	:
	  update_if x.is_undefined &x -> x_of(window)
	  $y y_of(window)
	  $height length_of(lines)
	  if
	    y > height
	    -> state
	    :
	      $line lines(y)
	      if
		line.is_undefined
		search_forwards
		:
		  line $indent $text
		  $s max(x-indent 1)
		  if
		    s > length_of(text)
		    search_forwards
		    :
		      range &text s -1
		      search $pos $len search_text text
		      if
			pos.is_defined && is_a_valid_match(text pos len):
			  !window
			    window
			      .previous_of window
			      .cursor_x_of undefined
			      .cursor_y_of undefined
			      .sub_y_of undefined
			      .selection_start_x_of x+pos-1
			      .selection_start_y_of y
			      .x_of x+pos+len-1
			      .do_keep_selection true
			  return_window
			search_forwards

	  $search_forwards:
	    loop
	      :
		inc &y
		if
		  y > height
		  -> state
		  :
		    $line lines(y)
		    if
		      line.is_undefined
		      next
		      :
			line $indent $text
			search $pos $len search_text text
			if
			  pos.is_defined && is_a_valid_match(text pos len):
			    !window
			      window
				.previous_of window
				.x_of indent+pos+len
				.y_of y
				.sub_y_of undefined
				.cursor_x_of undefined
				.cursor_y_of undefined
				.selection_start_x_of indent+pos
				.selection_start_y_of y
				.do_keep_selection true
			    return_window
			  next
	      -> state

$find_previous: (x = undefined)
  $search_text search_text_of(state)
  if
    search_text.is_undefined
    -> state
    :
      if
	&&
	  replacement_text_of(state).is_defined
	  search_text == selected_text()
	replace_selection
	:
	  update_if x.is_undefined &x -> x_of(window)
	  $height length_of(lines)
	  $y min(y_of(window) height)
	  if
	    y < 1
	    -> state
	    :
	      $line lines(y)
	      if
		line.is_undefined
		search_backwards
		:
		  line $indent $text
		  $e x-indent-1
		  if
		    e <= indent
		    search_backwards
		    :
		      range &text 1 e
		      search $pos $len search_text text -1
		      if
			pos.is_defined && is_a_valid_match(text pos len):
			  !window
			    window
			      .previous_of window
			      .cursor_x_of undefined
			      .sub_y_of undefined
			      .cursor_x_of undefined
			      .cursor_y_of undefined
			      .selection_start_x_of indent+pos+len
			      .selection_start_y_of y
			      .x_of indent+pos
			      .do_keep_selection true
			  return_window
			search_backwards

	  $search_backwards:
	    loop:
	      dec &y
	      if
		y < 1
		-> state
		:
		  $line lines(y)
		  if
		    line.is_undefined
		    next
		    :
		      line $indent $text
		      search $pos $len search_text text -1
		      if
			pos.is_defined && is_a_valid_match(text pos len):
			  !window
			    window
			      .previous_of window
			      .x_of indent+pos
			      .y_of y
			      .sub_y_of undefined
			      .cursor_x_of undefined
			      .cursor_y_of undefined
			      .selection_start_x_of indent+pos+len
			      .selection_start_y_of y
			      .do_keep_selection true
			  return_window
			next

$is_a_valid_match: (text pos len)
  $match_start_boundary match_start_boundary_of(state)
  if
    ||
      &&
	match_start_boundary == WORD
	pos > 1
	is_a_word_character(text(pos)) == is_a_word_character(text(pos-1))
      &&
	match_start_boundary == LINE
	pos > 1
    -> false
    :
      $e pos+len
      $match_end_boundary match_end_boundary_of(state)
      $text_len length_of(text)
      -> # ATTENTION: Why is the "->" necessary?
	not
	  ||
	    &&
	      match_end_boundary == WORD
	      e <= text_len
	      is_a_word_character(text(e)) == is_a_word_character(text(e-1))
	    &&
	      match_end_boundary == LINE
	      e < text_len

$is_a_word_character: (chr)
  -> chr == '_' || chr.is_a_digit || chr.is_a_letter_character

$selected_text:
  #
    returns the selected text if a single line of text is selected and this
    line is not empty; otherwise <undefined> is returned
  $y y_of(window)
  if
    y <= length_of(lines) && y == selection_start_y_of(window)
    :
      $line lines(y)
      if
	line.is_defined:
	  line $indent $text
	  $x x_of(window)-indent
	  $selection_start_x selection_start_x_of(window)-indent
	  if $lx $rx
	    selection_start_x > x
	    -> x selection_start_x
	    -> selection_start_x x
	  if
	    lx < 1 || rx-1 > length_of(text)
	    -> undefined
	    -> range(text lx rx-1)
	-> undefined
    -> undefined

$replace_selection:
  $x x_of(window)
  $y y_of(window)
  $selection_start_x selection_start_x_of(window)
  $replacement_text replacement_text_of(state)
  $line lines(y)
  line $indent $text $mark $folds
  min_max !selection_start_x $selection_end_x x selection_start_x
  $s max(selection_start_x-indent 1)
  $e min((selection_end_x-1)-indent length_of(text))
  !text
    append
      range(text 1 s-1)
      replacement_text
      range(text e+1 -1)
  !lines(y) tedi_line(indent text mark folds)
  !window
    window
      .previous_of window
      .cursor_x_of undefined
      .cursor_y_of undefined
      .sub_y_of undefined
      .was_updated true
      .x_of indent+s+length_of(replacement_text)
  return_window_and_lines

$cancel
  -> state(.current_window_index_of text_window_index_of(state))

$go_to_line_dialog:
  $windows windows_of(state)
  !window windows(GO_TO_WINDOW)
  !lines lines_of(window)
  !window
    window
      .x_of 1
      .y_of
	if
	  lines.is_defined
	  -> length_of(lines)+1
	  -> 1
  !windows(GO_TO_WINDOW) window
  ->
    state
      .text_window_index_of cwi()
      .current_window_index_of GO_TO_WINDOW
      .windows_of windows

$go_to_line:
  $y y_of(window)
  $line
    if
      y > length_of(lines)
      -> undefined
      -> lines(y)
  if
    line.is_undefined
    -> state(.current_window_index_of text_window_index_of(state))
    :
      $text text_of(line)
      if
	length_of(text) == 1 && text(1) >= 'a' && text(1) <= 'z':
	  go_to_mark text(1)
	:
	  $line_no text.to_integer
	  if
	    line_no.is_undefined
	    -> state(.current_window_index_of text_window_index_of(state))
	    :
	      # switch back to text window:
	      !state.current_window_index_of text_window_index_of(state)
	      !window windows_of(state)(cwi())
	      !window
		window
		  .x_of 1
		  .y_of line_no
		  .cursor_y_of undefined
	      return_window

$define_mark:
  !window.do_define_mark_of true
  return_window

$set_mark: (letter)
  if
    letter < 'a' || letter > 'z'
    -> state
    :
      $prev_y find_mark(letter)
      if
	prev_y.is_defined:
	  lines(prev_y) $indent $text $_mark $folds $tokens
	  !lines(prev_y) tedi_line(indent text undefined folds tokens)
	  add_mark
	add_mark

  $add_mark:
    $y y_of(window)
    if
      y > length_of(lines)
      -> state
      :
	$line lines(y)
	if
	  line.is_undefined
	  -> state
	  :
	    line $indent $text $_mark $folds $tokens
	    !lines(y) tedi_line(indent text letter folds tokens)
	    return_window_and_lines

$go_to_mark: (letter)
  # switch back to text window:
  !state.current_window_index_of text_window_index_of(state)
  !window windows_of(state)(cwi())
  !lines lines_of(window)
  $y find_mark(letter)
  if
    y.is_defined:
      !window
	window
	  .y_of y
	  .cursor_y_of undefined
      return_window
    -> state

$find_mark: (letter)
  for_each lines
    : (y line)
      if
	line.is_undefined
	next
	:
	  line $_indent $_text $mark
	  if
	    mark == letter
	    -> y
	    next
    -> undefined

$toggle_folding:
  # toggles a single folding level
  $y y_of(window)
  if
    y > length_of(lines) || lines(y).is_undefined
    -> state
    :
      $line lines(y)
      line $indent $text $mark $folds
      if
	folds.is_defined:
	  !window.was_updated true
	  !lines
	    append
	      push
		range(lines 1 y-1)
		tedi_line(indent text mark undefined)
	      folds
	      range(lines y+1 -1)
	  return_window_and_lines
	:
	  collect_indented_lines $e lines y indent
	  if
	    e <= y
	    -> state
	    :
	      !window.needs_redraw true
	      !lines
		append
		  push
		    range(lines 1 y-1)
		    tedi_line(indent text mark range(lines y+1 e))
		  range(lines e+1 -1)
	      return_window_and_lines

$fold_contents:
  $y y_of(window)
  $height length_of(lines)
  if
    y > height || lines(y).is_undefined
    -> window lines
    :
      $line lines(y)
      line $indent
      collect_indented_lines $e lines y indent
      !window.was_updated true
      !lines
	append
	  range(lines 1 y-1)
	  fold_all(range(lines y e))
	  range(lines e+1 -1)
      return_window_and_lines


$unfold_contents:
  $y y_of(window)
  $height length_of(lines)
  if
    y > height || lines(y).is_undefined
    -> window lines
    :
      !window.was_updated true
      !lines
	append
	  range(lines 1 y-1)
	  recursively_collect_folded_lines(lines(y))
	  range(lines y+1 -1)
      return_window_and_lines

$fold_everything:
  if
    lines.is_empty
    -> window lines
    :
      $y y_of(window)
      $height length_of(lines)
      find_first $skip $_dummy lines is_defined
      !window.y_of
	+
	  skip-1
	  count(range(lines 1 min(y height)) is_a_top_level_line)
	  max(y-height 0)
      !window.was_updated true
      fold_all &lines
      return_window_and_lines

      $is_a_top_level_line: (line)
	-> line.is_defined && indent_of(line) == 0

$unfold_everything:
  $y y_of(window)
  $height length_of(lines)
  $groups map(lines recursively_collect_folded_lines)
  !window.y_of
    +
      map_reduce(range(groups 1 min(y-1 height)) length_of plus 0)
      max(y-height 1)
  !window.was_updated true
  !lines reduce(groups append empty_list)
  return_window_and_lines

$fold_all: (some_lines)
  $i 0
  $n length_of(some_lines)
  $folds empty_list
  loop:
    inc &i
    if
      i > n
      -> folds
      :
	$line some_lines(i)
	if
	  line.is_undefined:
	    push &folds line
	    next
	  :
	    line $indent $text $mark $subfolds
	    if
	      subfolds.is_defined:
		push &folds
		  tedi_line(indent text mark fold_all(subfolds))
		next
	      :
		collect_indented_lines $e some_lines i indent
		if
		  e > i:
		    push &folds
		      tedi_line
			indent
			text
			mark
			fold_all(range(some_lines i+1 e))
		    !i e
		    next
		  :
		    push &folds line
		    next

$collect_indented_lines: (some_lines i indent)
  $n length_of(some_lines)
  loop:
    inc &i
    if
      i > n
      -> n
      :
	$current_line some_lines(i)
	if
	  current_line.is_undefined
	  next
	  :
	    if
	      indent_of(current_line) > indent
	      next
	      -> i-1

$recursively_collect_folded_lines: (line)
  if
    line.is_defined:
      line $indent $text $mark $folds
      if
	folds.is_defined:
	  put
	    map_reduce(folds recursively_collect_folded_lines)
	    tedi_line(indent text mark undefined)
	-> list(line)
    -> list(undefined)

$change_colour_set:
  $colour_set_no colour_set_no_of(window)
  if
    colour_set_no.is_undefined
    -> state
    :
      $next_colour_set_no
	if
	  colour_set_no >= length_of(colour_sets)
	  -> 1
	  -> colour_set_no+1
      !window
	window
	  .colour_set_no_of next_colour_set_no
	  .colour_set_of colour_sets(next_colour_set_no)
	  .needs_redraw true
      return_window

$toggle_indentation_highlighting:
  !window
    window
      .do_highlight_indentations_of not(do_highlight_indentations_of(window))
      .inbounds_width_of
	if
	  inbounds_width_of(window).is_defined
	  -> undefined
	  -> 80
      .needs_redraw true
  return_window

$toggle_cursor_line_highlighting:
  !window
    window
      .do_highlight_cursor_line_of not(do_highlight_cursor_line_of(window))
      .needs_redraw true
  return_window

$toggle_soft_line_break:
  !window
    window
      .use_soft_line_break_of not(use_soft_line_break_of(window))
      .cursor_x_of undefined
      .cursor_y_of undefined
      .sub_y_of undefined
      .needs_redraw true
  return_window

$load_file:
  load! $buf filename
  from_utf8 &buf
  trim_right &buf
  update_if buf.is_not_empty &buf -> push(buf '@nl;')
  map split_into_indented_lines(buf): (line)
    if
      line.is_defined
      -> tedi_line(first(line) trim_right(range(second(line) 1 -2)))
      -> undefined

$return_window_and_lines:
  !window.lines_of lines
  return_window

$return_window:
  !state.windows_of(cwi()) window
  -> state

$extract_window_and_lines: (body)
  !window windows_of(state)(cwi())
  !lines lines_of(window)
  body!

$min_max_minus_1: (v1 v2)
  min_max &v1 &v2
  -> v1 v2-1

$update_display:
  #
    if <cursor_x> or <cursor_y> is undefined then <x> and <y> must be defined

    if <sub_y> is undefined then either
      <x> and <y> or <cursor_x> and <cursor_y> must be defined

    if <y> is undefined then <cursor_x> and <cursor_y> must be defined

    if <x> is undefined then <sub_y> and <cursor_x> must be defined

  update_if was_updated(window) &window
    -> window(.revision_no_of revision_no_of(window)+1)
  $use_soft_line_break use_soft_line_break_of(window)
  $width width_of(window)
  $height height_of(window)
  $upper_bound default_value(upper_bound_of(window) 1)
  $lower_bound default_value(lower_bound_of(window) height)
  $first_visible_x first_visible_x_of(window)
  $first_visible_y first_visible_y_of(window)
  $first_visible_sub_y first_visible_sub_y_of(window)
  $inbounds_width default_value(inbounds_width_of(window) first_visible_x+width)
  $line_count length_of(lines)
  $x x_of(window)
  $y y_of(window)

  if $cursor_x $cursor_y $sub_y
    cursor_y_of(window).is_defined
    -> cursor_x_of(window) cursor_y_of(window) sub_y_of(window)
    :
      if_not
	use_soft_line_break
	-> x y-first_visible_y+1 1
	:
	  $dy count_lines_from_to(first_visible_y first_visible_sub_y y 1)
	  $line
	    if
	      y > line_count
	      -> undefined
	      -> lines(y)
	  if
	    line.is_defined:
	      line $indent $text
	      !cursor_x x-indent
	      $text_lines break_into_lines(text inbounds_width-indent)
	      $text_line_count length_of(text_lines)
	      $text_line_no 1
	      loop:
		if
		  text_line_no >= text_line_count
		  -> indent+cursor_x dy+text_line_count text_line_count
		  :
		    $len length_of(text_lines(text_line_no))+1 # trailing space
		    if
		      cursor_x <= len
		      -> indent+cursor_x dy+text_line_no text_line_no
		      :
			minus &cursor_x len
			inc &text_line_no
			next
	    -> x dy+1 1

  update_if y.is_undefined &y &sub_y &cursor_y:
    move !y !sub_y $dy first_visible_y first_visible_sub_y cursor_y-1
    -> y sub_y cursor_y-dy

  update_if x.is_undefined &x:
    if_not
      use_soft_line_break
      -> cursor_x
      :
	$line
	  if
	    y > line_count
	    -> undefined
	    -> lines(y)
	if
	  line.is_undefined
	  -> cursor_x
	  :
	    line $indent $text
	    $text_lines break_into_lines(text inbounds_width-indent)
	    $text_line_no 1
	    !x
	      if
		sub_y == 1
		-> cursor_x
		-> max(cursor_x indent+1)
	    loop:
	      $len length_of(text_lines(text_line_no))+1 # trailing space
	      if
		sub_y <= text_line_no
		-> x-max(cursor_x-indent-len 0)
		:
		  plus &x len
		  inc &text_line_no
		  next

  !first_visible_x
    cond
      -> cursor_x < first_visible_x
	-> cursor_x
      -> cursor_x >= first_visible_x+width
	-> cursor_x-width+1
      -> true
	-> first_visible_x

  $selection_start_x selection_start_x_of(window)
  $selection_start_y selection_start_y_of(window)
  if !selection_start_x $selection_end_x !selection_start_y $selection_end_y
    selection_start_y.is_undefined
    -> undefined undefined undefined undefined
    :
      if
	selection_start_y == y # horizontal selection
	-> min(selection_start_x x) max(selection_start_x x) y y
	->
	  undefined undefined
	  min(selection_start_y y) max(selection_start_y y)-1

  !window
    window
      .first_visible_x_of first_visible_x
      .x_of x
      .y_of y

  update_if window.is_a_text_window &terminal: draw_title_bar
  define_window &terminal left_x_of(window) top_y_of(window) -1 -1

  $do_highlight_cursor_line do_highlight_cursor_line_of(window)
  $do_highlight_indentations do_highlight_indentations_of(window)
  cond
    -> cursor_y < upper_bound:
      move &first_visible_y &first_visible_sub_y $dy cursor_y-upper_bound
      !cursor_y max(upper_bound+dy 1)
      update
    -> cursor_y > lower_bound:
      move &first_visible_y &first_visible_sub_y $_dummy cursor_y-lower_bound
      !cursor_y lower_bound
      update
    -> true
      update

  $update:
    if
      ||
	needs_redraw(window)
	was_updated(window)
	id_of(window) != id_of(previous_window)
	first_visible_x != first_visible_x_of(previous_window)
	first_visible_y != first_visible_y_of(previous_window)
	first_visible_sub_y != first_visible_sub_y_of(previous_window)
	selection_start_y.is_defined
	selection_start_y_of(previous_window).is_defined
      draw
      :
	if
	  do_highlight_cursor_line && y != y_of(previous_window):
	    draw y y_of(previous_window)
	  update_cursor

  $update_cursor:
    !window
      window
	.cursor_x_of cursor_x
	.cursor_y_of cursor_y
	.sub_y_of sub_y
    set_cursor &terminal cursor_x-first_visible_x+1 cursor_y
    -> terminal return_window()

  $draw:
    (
      y1 = equals_everything
      y2 = equals_everything
    )
    !window
      window
	.first_visible_y_of first_visible_y
	.first_visible_sub_y_of first_visible_sub_y
	.needs_redraw false
	.was_updated false
    $colour_set colour_set_of(window)
    $text_colour text_colour_of(colour_set)
    $background_colour background_colour_of(colour_set)
    $out_of_bounds_colour out_of_bounds_colour_of(colour_set)
    $selection_colour selection_colour_of(colour_set)
    $indentation_pattern indentation_patterns_of(colour_set)(1)
    set_text_colour &terminal text_colour

    $indent undefined
    $cy first_visible_y-1
    $sy first_visible_sub_y
    $display_y 1
    loop:
      if
	display_y > height
	update_cursor
	draw_line

    $draw_line:
      inc &cy
      if
	cy > line_count:
	  !indent 0
	  draw_empty_line
	:
	  $line lines(cy)
	  if
	    line.is_undefined
	    draw_empty_line
	    :
	      line !indent $text $_marks $folds
	      if
		use_soft_line_break && indent+length_of(text) > inbounds_width
		draw_long_line
		draw_short_line

	      $draw_short_line:
		if
		  y1 == cy || y2 == cy:
		    draw_text_line !terminal text indent+1 folds
		    inc &display_y
		    next
		  :
		    inc &display_y
		    next

	      $draw_long_line:
		$text_lines break_into_lines(text inbounds_width-indent)
		range &text_lines sy -1
		!sy 1
		update_if length_of(text_lines) > height-display_y+1 &text_lines
		  -> range(text_lines 1 height-display_y+1)
		if
		  y1 == cy || y2 == cy:
		    $cx indent+1
		    for_each text_lines
		      : (text)
			draw_text_line !terminal text cx folds
			plus &cx length_of(text)+1
			inc &display_y
			next
		      next
		  :
		    plus &display_y length_of(text_lines)
		    next

    $draw_empty_line:
      update_if indent.is_undefined &indent:
	loop:
	  dec &cy
	  if
	    cy < 1
	    -> 0
	    :
	      $line lines(cy)
	      if
		line.is_undefined
		next
		-> indent_of(line)
      if
	y1 == cy || y2 == cy:
	  if
	    &&
	      selection_start_y.is_defined
	      cy >= selection_start_y
	      cy <= selection_end_y
	    :
	      set_window_colour !terminal selection_colour_of(colour_set)
	      draw_text &terminal 1 display_y spaces(width)
	      inc &display_y
	      next
	    :
	      set_window_colour !terminal background_colour
	      draw_indent !terminal
	      draw_text &terminal indent-first_visible_x+2 display_y
		spaces(inbounds_width)
	      draw_out_of_bounds !terminal
	      inc &display_y
	      next
	:
	  inc &display_y
	  next


    $draw_text_line: (text cx folds)
      update_if folds.is_defined &background_colour:
	if
	  any_of(folds is_defined)
	  -> folds_colour_of(colour_set)
	  -> fake_folds_colour_of(colour_set)
      $text_length length_of(text)
      $sx indent-first_visible_x+2
      $dx
	if
	  sx < 1
	  -> 1-sx
	  -> 0
      update_if dx > 0 &text:
	if
	  dx < text_length
	  -> range(text 1+dx -1)
	  -> ""
      max &sx 1
      pad_right &text width-sx+1
      range &text 1 width-sx+1
      if
	&&
	  selection_start_y.is_defined
	  selection_start_x.is_undefined
	  cy >= selection_start_y
	  cy <= selection_end_y
	:
	  set_window_colour !terminal selection_colour_of(colour_set)
	  draw_text terminal 1 display_y append(spaces(sx-1) text)
	:
	  $attributed_text
	    if
	      sx > 1:
		if
		  do_highlight_indentations
		  -> range(indentation_pattern 3*first_visible_x-2 3*indent)
		  :
		    $cell string(' ' text_colour background_colour)
		    -> dup(cell indent-first_visible_x+1)
	      -> ""
	  $inbounds_rx max(inbounds_width-max(first_visible_x-1 indent) 0)
	  if
	    &&
	      selection_start_x.is_defined
	      cy == selection_start_y
	      overlap(selection_start_x selection_end_x cx cx+text_length+1)
	    :
	      min &selection_end_x cx+text_length+1
	      minus &selection_start_x cx-1+dx
	      minus &selection_end_x cx-1+dx
	      max &selection_start_x 1
	      min &selection_start_x length_of(text)+1
	      min &selection_end_x length_of(text)+1
	      append_text background_colour selection_start_x-1:
		append_text selection_colour selection_end_x-selection_start_x:
		  append_text background_colour:
		    draw_attributed_text terminal 1 display_y attributed_text
	    :
	      append_text background_colour:
		draw_attributed_text terminal 1 display_y attributed_text

	  $append_text:
	    (
	      colour
	      width = undefined
	      continuation
	    )
	    update_if width.is_undefined &width -> length_of(text)
	    on width > length_of(text):
	      edump `width
	      edump `text
	    if
	      width < 0
	      continuation
	      :
		if
		  inbounds_rx > width || colour != background_colour:
		    append &attributed_text
		      add_attributes
			range(text 1 width)
			text_colour
			window_colour(colour)
		    cont
		  :
		    if
		      inbounds_rx <= 0:
			append &attributed_text
			  add_attributes
			    range(text 1 width)
			    text_colour
			    window_colour(out_of_bounds_colour)
			cont
		      :
			append &attributed_text
			  add_attributes
			    range(text 1 inbounds_rx)
			    text_colour
			    window_colour(colour)
			append &attributed_text
			  add_attributes
			    range(text inbounds_rx+1 width)
			    text_colour
			    window_colour(out_of_bounds_colour)
			cont

		$cont:
		  range &text width+1 -1
		  minus &inbounds_rx width
		  continuation

    $draw_indent:
      if
	first_visible_x > indent
	-> terminal
	:
	  if
	    do_highlight_indentations:
	      draw_attributed_text terminal 1 display_y
		range(indentation_pattern 3*first_visible_x-2 3*indent)
	    :
	      draw_text terminal 1 display_y spaces(indent-first_visible_x+1)

    $draw_out_of_bounds: (text = "")
      if
	first_visible_x+width-1 > inbounds_width:
	  set_window_colour !terminal out_of_bounds_colour
	  draw_text terminal
	    inbounds_width-first_visible_x+2 display_y
	    pad_right(text first_visible_x+width-1-inbounds_width)
	-> terminal

    $window_colour: (colour)
      if
	&&
	  do_highlight_cursor_line
	  cy == y
	:
	  $red red_component_of(colour)
	  $green green_component_of(colour)
	  $blue blue_component_of(colour)
	  ->
	    rgb_character
	      if(red < 0xe0 (-> red+0x20) (-> red-0x20))
	      if(green < 0xe0 (-> green+0x20) (-> green-0x20))
	      if(blue < 0xe0 (-> blue+0x20) (-> blue-0x20))
	-> colour

    $set_window_colour: (colour)
      set_background_colour terminal window_colour(colour)

$overlap: (s1 e1 s2 e2)
  # the end positions are *exclusive*!
  -> e1 > s2 && e2 > s1

$break_into_lines: (text width)
  $text_lines empty_list
  $s 1
  $i 0
  $n length_of(text)
  $b undefined
  loop:
    inc &i
    if
      i > n
      -> push(text_lines range(text s -1))
      :
	if
	  text(i) == ' ' && text(i-1) != ' ':
	    !b i
	    next
	  :
	    if
	      b.is_undefined || i-s < width
	      next
	      :
		push &text_lines range(text s b-1)
		!s b+1
		!b undefined
		next

$get_line_height: (y)
  if
    y < 1 || y > length_of(lines)
    -> 1
    :
      $line lines(y)
      if
	line.is_undefined
	-> 1
	:
	  line $indent $text
	  $inbounds_width default_value(inbounds_width_of(window) 999'999'999)
	  -> length_of(break_into_lines(text inbounds_width-indent))

$count_lines_from_to: (first_y first_sub_y last_y last_sub_y)
  if
    ||
      first_y > last_y
      first_y == last_y && first_sub_y > last_sub_y
    :
      assign
	!first_y last_y
	!first_sub_y last_sub_y
	!last_y first_y
	!last_sub_y first_sub_y
      count_lines true
    :
      count_lines false

  $count_lines: (do_swap)
    $count 0
    loop:
      if
	first_y == last_y:
	  plus &count last_sub_y-first_sub_y
	  if
	    do_swap
	    -> -count
	    -> count
	:
	  $line_height get_line_height(first_y)
	  plus &count line_height-first_sub_y+1
	  inc &first_y
	  !first_sub_y 1
	  next

$move: (y sub_y dy)
  $cursor_movement cursor_movement_of(window)
  if_not
    use_soft_line_break_of(window):
      plus &y dy
      if
	y < 1
	-> 1 1 y-1
	:
	  $height length_of(lines)
	  case cursor_movement
	    WITHIN_TEXT:
	      if
		y > height
		-> height 1 y-height
		-> y 1 0
	    ADD_SINGLE_LINE:
	      if
		y > height+1
		-> height+1 1 y-(height+1)
		-> y 1 0
	    -> y 1 0
    :
      cond
	-> dy > 0:
	  $line_count length_of(lines)
	  loop:
	    if
	      dy == 0
	      -> y sub_y 0
	      :
		$line_height get_line_height(y)
		if
		  sub_y+dy <= line_height
		  -> y sub_y+dy 0
		  :
		    if
		      ||
			cursor_movement == WITHIN_TEXT && y == line_count
			cursor_movement == ADD_SINGLE_LINE && y == line_count+1
		      -> y line_height dy-(line_height-sub_y)
		      :
			minus &dy line_height+1-sub_y
			inc &y
			!sub_y 1
			next
	-> dy < 0:
	  loop:
	    if
	      y < 1
	      -> 1 1 dy-1
	      :
		$line_height get_line_height(y)
		update_if sub_y.is_undefined &sub_y -> line_height
		if
		  dy == 0
		  -> y sub_y 0
		  :
		    if
		      sub_y+dy >= 1
		      -> y sub_y+dy 0
		      :
			plus &dy sub_y
			dec &y
			!sub_y undefined
			next
	-> true -> y sub_y 0

$draw_title_bar:
  define_window &terminal 1 1 -1 1
  $colour_set colour_set_of(window)
  set_text_colour &terminal bar_text_colour_of(colour_set)
  set_background_colour &terminal bar_background_colour_of(colour_set)
  clear &terminal
  draw_text &terminal 1 1
    pad_left("@(y_of(window))/@(length_of(lines))" 11)
    ':' pad_right(x_of(window) 3)
    if
      use_soft_line_break_of(window)
      -> "≡"
      -> "−"
    "  "
    if
      revision_no_of(window) != saved_revisions_of(state)(id_of(window))
      -> "*"
      -> ""
    filename
  -> terminal

# Helper Functions

$first_position: (y)
  if
    y > length_of(lines)
    -> 1
    :
      $line lines(y)
      if
	line.is_undefined
	-> 1
	-> indent_of(line)+1

$last_position: (y)
  if
    y > length_of(lines)
    -> 1
    :
      $line lines(y)
      if
	line.is_undefined
	-> 1
	:
	  line $indent $text
	  if
	    use_soft_line_break_of(window):
	      $inbounds_width
		default_value(inbounds_width_of(window) 999'999'999)
	      $text_lines break_into_lines(text inbounds_width-indent)
	      -> indent+length_of(text_lines(sub_y_of(window)))+1
	    -> indent+length_of(text)+1

$tedi_line:
  (
    indent
    text
    mark = ""
    folds = undefined
    tokens = undefined
  )
  # must not be called with a text containing only space characters
  if
    text.is_empty
    -> undefined
    :
      $prefix_spaces count_prefix_spaces(text)
      $suffix_spaces count_suffix_spaces(text)
      range &text prefix_spaces+1 -(suffix_spaces+1)
      -> new(tedi_types::tedi_line indent+prefix_spaces text mark folds tokens)

$equals_everything std_types::object
$equals_everything/equal: (_left _right) -> true

$cwi -> current_window_index_of(state)

$count_prefix_spaces: (str)
  $len length_of(str)
  $i 1
  loop:
    if
      i <= len && str(i) == ' ':
	inc &i
	next
      -> i-1

$count_suffix_spaces: (str)
  $len length_of(str)
  $i len
  loop:
    if
      i >= 1 && str(i) == ' ':
	dec &i
	next
      -> len-i

$create_indentation_patterns: (colour_set)
  $text_colour text_colour_of(colour_set)
  $background_colour background_colour_of(colour_set)
  $background_colour_2 background_colour_2_of(colour_set)
  $background_colour_3 background_colour_3_of(colour_set)
  ->
    colour_set
      .indentation_patterns_of
	list
	  dup
	    string
	      ' '
	      text_colour
	      background_colour
	      ' '
	      text_colour
	      background_colour
	      ' '
	      text_colour
	      background_colour_2
	      ' '
	      text_colour
	      background_colour_2
	    256
	  dup
	    string
	      ' '
	      text_colour
	      background_colour
	      ' '
	      text_colour
	      background_colour
	      ' '
	      text_colour
	      background_colour_3
	      ' '
	      text_colour
	      background_colour_3
	    256
	  dup
	    string
	      ' '
	      text_colour
	      background_colour_2
	      ' '
	      text_colour
	      background_colour_2
	      ' '
	      text_colour
	      background_colour_3
	      ' '
	      text_colour
	      background_colour_3
	    256
