#!/usr/bin/env fkyrun

<namespace tedi_types>

<require basic/stdlib>
<require basic/export/json>
<require basic/import/json>
<require terminal/terminal>

<require ./ai/llama>

<using std>
<using ai>

<allow unused>

$EXIT .

$PASTE_THRESHOLD 16

# Cursor Movement

$WITHIN_TEXT .
$ADD_SINGLE_LINE .
$ANYWHERE .

# Key Classes

$MOVEMENT .
$SELECTION .
$DELETION .
$INSERTION .
$FOLDING .
$OTHER .

# Features

$HAS_HISTORY .
$ALLOW_SEARCH .
$ALLOW_NEW_LINE .

$indent_of ()
$text_of ()
$mark_of ()
$folds_of ()

$space_tokens_of ()

$tedi_types::tedi_line tuple(undefined undefined undefined undefined undefined)
  # indent, text, mark, folds, tokens

$tedi_types::tedi_line/indent_of: (self) -> first(self)
$tedi_types::tedi_line/text_of: (self) -> second(self)
$tedi_types::tedi_line/mark_of: (self) -> third(self)
$tedi_types::tedi_line/folds_of: (self) -> fourth(self)

# State

$ai_model_of ()
$windows_of ()
$current_window_index_of () # the currently active window
$text_window_index_of () # the text window to work on
$completion_prefix_of ()
$possible_completions_of ()
$action_of ()
$search_text_of ()
$match_start_boundary_of () # search text must start at a boundary
$match_end_boundary_of () # search text must end at a boundary
$replacement_text_of ()

# Window

$features_of ()
$key_bindings_of ()
$previous_of ()
$redo_of ()
$lines_of ()
$x_of ()
$y_of ()
$previous_x_of ()
$previous_y_of ()
$first_visible_y_of ()
$first_visible_x_of ()
$first_updated_y_of ()
$last_updated_y_of ()
$is_locked ()
$upper_bound_of ()
$lower_bound_of ()
$do_keep_selection ()
$has_a_permanent_selection ()
$selection_start_x_of ()
$selection_start_y_of ()
$previous_selection_start_x_of ()
$previous_selection_start_y_of ()
$go_to_history_of ()
$cursor_movement_of ()

$is_a_text_window ()

$text_colour_of ()
$background_colour_of ()
$background_colour_2_of ()
$background_colour_3_of ()
$inbounds_width_of ()
$out_of_bounds_colour_of ()
$selection_colour_of ()
$folds_colour_of ()
$fake_folds_colour_of ()
$bar_text_colour_of ()
$bar_background_colour_of ()
$indentation_patterns_of ()
$do_highlight_indentations_of ()
$colour_set_of ()
$colour_set_no_of ()
$clipboard_contents_of ()

$do_define_mark_of ()

program_parameters!
  $filename
  list
    MANDATORY_PARAMETER "filename" "
      the name of the text file to edit

$alt_key_to_letter
  hash_table
    ALT_A = 'a'
    ALT_B = 'b'
    ALT_C = 'c'
    ALT_D = 'd'
    ALT_E = 'e'
    ALT_F = 'f'
    ALT_G = 'g'
    ALT_H = 'h'
    ALT_I = 'i'
    ALT_J = 'j'
    ALT_K = 'k'
    ALT_L = 'l'
    ALT_M = 'm'
    ALT_N = 'n'
    ALT_O = 'o'
    ALT_P = 'p'
    ALT_Q = 'q'
    ALT_R = 'r'
    ALT_S = 's'
    ALT_T = 't'
    ALT_U = 'u'
    ALT_V = 'v'
    ALT_W = 'w'
    ALT_X = 'x'
    ALT_Y = 'y'
    ALT_Z = 'z'

load_file! $lines
on lines.is_an_error:
  eprint! "
    Unable to load file "@(filename)"!
  exit! EXIT_FAILURE

$editor_key_bindings
  hash_table
    # cursor movement

    CURSOR_UP = cursor_up
    CURSOR_DOWN = cursor_down
    CURSOR_LEFT = cursor_left
    CURSOR_RIGHT = cursor_right

    PAGE_UP = page_up
    PAGE_DOWN = page_down
    HOME = cursor_home
    END = cursor_end

    CTRL_CURSOR_UP = smart_cursor_up
    CTRL_CURSOR_DOWN = smart_cursor_down
    CTRL_HOME = cursor_top
    CTRL_END = cursor_bottom

    # text selection

    SHIFT_CURSOR_UP = select_cursor_up
    SHIFT_CURSOR_DOWN = select_cursor_down
    SHIFT_CURSOR_LEFT = select_cursor_left
    SHIFT_CURSOR_RIGHT = select_cursor_right

    SHIFT_PAGE_UP = select_page_up
    SHIFT_PAGE_DOWN = select_page_down
    SHIFT_HOME = select_cursor_home
    SHIFT_END = select_cursor_end

    SHIFT_CTRL_CURSOR_UP = select_smart_cursor_up
    SHIFT_CTRL_CURSOR_DOWN = select_smart_cursor_down
    SHIFT_CTRL_HOME = select_cursor_top
    SHIFT_CTRL_END = select_cursor_bottom

    # insert & delete

    TABULATOR = smart_indent
    SHIFT_TABULATOR = smart_outdent
    RETURN = split_line
    BACKSPACE = delete_left
    DELETE = delete_right

    CTRL_BACKSPACE = delete_to_line_start
    CTRL_DELETE = delete_to_line_end
    ALT_SPACE = smart_completion
    CTRL_SPACE = ai_completion
    ALT_RETURN = toggle_folding
    ALT_CURSOR_LEFT = fold_contents
    ALT_CURSOR_RIGHT = unfold_contents
    ALT_CURSOR_UP = fold_everything
    ALT_CURSOR_DOWN = unfold_everything

    # control commands

    CTRL_C = copy
    CTRL_D = define_mark
    CTRL_F = find_text_dialog
    CTRL_G = go_to_line_dialog
    CTRL_J = join_lines
    CTRL_K = delete_line
    CTRL_N = find_next
    CTRL_P = find_previous
    CTRL_Q = EXIT
    CTRL_S = save_contents
    CTRL_ALT_S = save_with_leading_spaces_action
    CTRL_V = paste
    CTRL_X = cut

$simple_key_bindings
  hash_table
    # cursor movement

    CURSOR_UP = cursor_up
    CURSOR_DOWN = cursor_down
    CURSOR_LEFT = cursor_left
    CURSOR_RIGHT = cursor_right

    HOME = cursor_home
    END = cursor_end

    CTRL_HOME = cursor_top
    CTRL_END = cursor_bottom

    BACKSPACE = delete_left
    DELETE = delete_right

    CTRL_BACKSPACE = delete_to_line_start
    CTRL_DELETE = delete_to_line_end
    ALT_SPACE = smart_completion

    # control commands

    CTRL_Q = EXIT

$search_key_bindings
  new
    simple_key_bindings

    # actions

    RETURN = start_search
    ESCAPE = cancel

    # control commands

    CTRL_C = copy
    CTRL_V = paste
    CTRL_X = cut
    CTRL_N = start_search
    CTRL_P = start_search

get_environment $environment
$configuration_filename append(environment("HOME") "/tedi.cfg")
load! $configuration configuration_filename

$colour_sets
  list
    std_types::object
      .text_colour_of WHITE
      .background_colour_of '@0x0000e0;'
      .background_colour_2_of '@0x0000c8;'
      .background_colour_3_of '@0x0000b0;'
      .out_of_bounds_colour_of '@0x0000cc;'
      .selection_colour_of '@0x804000;'
      .folds_colour_of '@0x00a0ff;'
      .fake_folds_colour_of '@0x00c0ff;'
      .bar_text_colour_of BLACK
      .bar_background_colour_of WHITE
    std_types::object
      .text_colour_of WHITE
      .background_colour_of BLUE
      .background_colour_2_of '@0x0000f0;'
      .background_colour_3_of '@0x0000e8;'
      .out_of_bounds_colour_of '@0x0000c0;'
      .selection_colour_of '@0x804000;'
      .folds_colour_of '@0x00a0ff;'
      .fake_folds_colour_of '@0x00c0ff;'
      .bar_text_colour_of BLACK
      .bar_background_colour_of WHITE
    std_types::object
      .text_colour_of BLACK
      .background_colour_of WHITE
      .background_colour_2_of '@0xf4f4f4;'
      .background_colour_3_of '@0xe8e8e8;'
      .out_of_bounds_colour_of '@0xeeeeee;'
      .selection_colour_of YELLOW
      .folds_colour_of '@0xa0ffa0;'
      .fake_folds_colour_of '@0xe0ffe0;'
      .bar_text_colour_of WHITE
      .bar_background_colour_of BLACK
    std_types::object
      .text_colour_of WHITE
      .background_colour_of BLACK
      .background_colour_2_of '@0x000810;'
      .background_colour_3_of '@0x000e1c;'
      .out_of_bounds_colour_of '@0x111111;'
      .selection_colour_of '@0x804000;'
      .folds_colour_of '@0x004000;'
      .fake_folds_colour_of '@0x002000;'
      .bar_text_colour_of BLACK
      .bar_background_colour_of WHITE

$status_colour_set
  std_types::object
    .text_colour_of RED
    .background_colour_of YELLOW

map &colour_sets create_indentation_patterns

$prototype_window
  std_types::object
    .features_of empty_hash_set
    .x_of 1
    .y_of 1
    .previous_x_of 1
    .previous_y_of 1
    .inbounds_width_of undefined
    .first_visible_y_of 1
    .first_visible_x_of 1
    .is_a_text_window false
    .is_locked false
    .upper_bound_of undefined
    .lower_bound_of undefined
    .has_a_permanent_selection false
    .do_keep_selection false
    .selection_start_x_of undefined
    .selection_start_y_of undefined
    .previous_selection_start_x_of undefined
    .previous_selection_start_y_of undefined
    .go_to_history_of empty_list
    .do_define_mark_of false
    .first_updated_y_of 1
    .last_updated_y_of END
    .colour_set_no_of undefined
    .do_highlight_indentations_of false

$go_to_key_bindings
  new
    simple_key_bindings

    # actions

    RETURN = go_to_line
    ESCAPE = cancel

    # control commands

    CTRL_C = copy
    CTRL_V = paste
    CTRL_X = cut

$window
  prototype_window
    .features_of
      hash_set
	HAS_HISTORY
	ALLOW_SEARCH
	ALLOW_NEW_LINE
    .key_bindings_of editor_key_bindings
    .previous_of undefined
    .redo_of undefined
    .key_of undefined
    .lines_of lines
    .left_x_of 1
    .top_y_of 2
    .inbounds_width_of 80
    .is_locked true
    .is_a_text_window true
    .colour_set_of colour_sets(1)
    .colour_set_no_of 1
    .do_highlight_indentations_of true
    .cursor_movement_of ANYWHERE

$status_window
  prototype_window
    .lines_of tedi_line(0 "")
    .left_x_of 1
    .height_of 1
    .colour_set_of status_colour_set

$search_window
  prototype_window
    .key_bindings_of search_key_bindings
    .key_of undefined
    .lines_of empty_list
    .left_x_of 1
    .height_of 1
    .colour_set_of colour_sets(3)
    .cursor_movement_of ADD_SINGLE_LINE

$go_to_window
  prototype_window
    .key_bindings_of go_to_key_bindings
    .key_of undefined
    .lines_of empty_list
    .left_x_of 1
    .height_of 1
    .colour_set_of colour_sets(4)
    .cursor_movement_of ADD_SINGLE_LINE

# Window Ids

$STATUS_WINDOW -1
$SEARCH_WINDOW -2
$GOTO_WINDOW -3

$state undefined
$current_window_index 1

$terminal undefined
$io std_types::io

initialize_terminal!
  RECEIVE_CTRL_C_AND_CTRL_Z = true
  RECEIVE_CTRL_Q_AND_CTRL_S = true
  MAP_CR = true
  TITLE = filename
  main

$main: (initial_terminal)
  !terminal initial_terminal

  $terminal_width width_of(terminal)
  $terminal_height height_of(terminal)
  $window_height terminal_height-2

  !window.width_of terminal_width
  !window.height_of window_height
  !window.upper_bound_of 1+(window_height .div. 4)
  !window.lower_bound_of window_height-(window_height .div. 4)

  !status_window.width_of terminal_width
  !status_window.top_y_of terminal_height
  !status_window.width_of terminal_width

  !search_window.width_of terminal_width
  !search_window.top_y_of terminal_height
  !search_window.width_of terminal_width

  !go_to_window.width_of terminal_width
  !go_to_window.top_y_of terminal_height
  !go_to_window.width_of terminal_width

  !state
    std_types::object
      .ai_model_of undefined
      .windows_of
	list
	  window
	  go_to_window
	  search_window
	  status_window
      .current_window_index_of 1 # current window index
      .text_window_index_of 1
      .key_of undefined
      .completion_prefix_of undefined
      .possible_completions_of undefined
      .action_of undefined
      .clipboard_contents_of undefined
      .search_text_of undefined
      .replacement_text_of undefined

  update_display !terminal !state
  update_terminal &terminal $initial_output
  print! initial_output

  start_reading_from &io STDIN_FILENO
  event_loop! !terminal !state
  on terminal.is_an_error terminal

$event_loop:
  $rc result_count()
  loop:
    get_events! &io $events
    for_each events
      : (event)
	event $type $fd $input
	case type
	  READ:
	    if
	      fd == STDIN_FILENO:
		from_utf8 &input
		if
		  &&
		    length_of(input) >= PASTE_THRESHOLD
		    input .contains. '@cr;'
		  :
		    paste_text input !state
		    !window windows_of(state)(current_window_index)
		    !lines lines_of(window)
		    update_display !terminal !state
		    update_terminal &terminal $output
		    print! output
		    next!
		  :
		    $keys extract_keys(input).combine_characters
		    for_each keys
		      : (key)
			#update_if do_toggle_backspace &key:
			  case key
			    BACKSPACE -> CTRL_BACKSPACE
			    CTRL_BACKSPACE -> BACKSPACE
			    -> key
			!current_window_index current_window_index_of(state)
			!window windows_of(state)(current_window_index)
			!window.previous_x_of x_of(window)
			!window.previous_y_of y_of(window)
			!window.previous_selection_start_x_of
			  selection_start_x_of(window)
			!window.previous_selection_start_y_of
			  selection_start_y_of(window)
			update_if
			  &&
			    key != ALT_SPACE
			    completion_prefix_of(state).is_defined
			  &state
			  ->
			    state
			      .completion_prefix_of undefined
			      .possible_completions_of undefined

			case key
			  CTRL_Y: # redo
			    if
			      ||
				not(features_of(window)(HAS_HISTORY))
				redo_of(window).is_undefined
			      next
			      :
				$current_window window
				!window redo_of(window)
				!window.previous_of current_window
				update_all!
			  CTRL_Z: # undo
			    if
			      ||
				not(features_of(window)(HAS_HISTORY))
				previous_of(window).is_undefined
			      next
			      :
				$current_window window
				!window previous_of(window)
				!window.redo_of current_window
				update_all!
			  :
			    update_history !window key
			    !state.windows_of(current_window_index) window
			    !lines lines_of(window)
			    if
			      key.is_a_string:
				if
				  do_define_mark_of(window):
				    !window.do_define_mark_of false
				    set_mark key(1) !state
				    range &key 2 -1
				    if
				      key.is_empty
				      next
				      :
					!window
					  windows_of(state)(current_window_index)
					!lines lines_of(window)
					insert_key!
				  insert_key

				$insert_key:
				  insert !state key
				  maybe_remove_selection_and_update_display
				    !terminal !state
				  next!
			      :
				!state.key_of key
				!window.key_of key # for history handling
				!state.windows_of(current_window_index) window
				!window.do_define_mark_of false
				$handler key_bindings_of(window)(key)
				if
				  handler.is_undefined
				  next
				  :
				    if
				      EXIT == handler
				      -> terminal state
				      :
					handler !state
					update!
		      :
			update_terminal &terminal $output
			print! output
			next!
	      next
	  next
      next

  $update_all:
    !window.first_updated_y_of
      first_visible_y_of(window)
    !window.last_updated_y_of END
    !state.windows_of(current_window_index) window
    !lines lines_of(window)
    update_display !terminal !state
    next!

  $update:
    $action action_of(state)
    if
      action.is_defined:
	!state.action_of undefined
	if
	  EXIT == action
	  -> terminal state
	  :
	    !current_window_index current_window_index_of(state)
	    !window windows_of(state)(current_window_index)
	    !lines lines_of(window)
	    action! !terminal !state
	    maybe_remove_selection_and_update_display !terminal !state
	    next!
      :
	maybe_remove_selection_and_update_display !terminal !state
	next!

  $combine_characters: (keys)
    $combined empty_list
    $str ""
    for_each keys
      : (key)
	if
	  key.is_undefined
	  next
	  :
	    if
	      key.is_a_character:
		push &str key
		next
	      :
		if
		  str.is_empty:
		    push &combined key
		    next
		  :
		    push &combined str
		    push &combined key
		    !str ""
		    next
      :
	if
	  str.is_empty
	  -> combined
	  -> push(combined str)

  $maybe_remove_selection_and_update_display:
    !current_window_index current_window_index_of(state)
    !window windows_of(state)(current_window_index)
    !lines lines_of(window)
    update_if_not do_keep_selection(window) || has_a_permanent_selection(window)
      &window
      ->
	window
	  .selection_start_x_of undefined
	  .selection_start_y_of undefined
    !window.do_keep_selection false
    update_display

$update_history: (key)
  if_not
    features_of(window)(HAS_HISTORY)
    -> window(.key_of key)
    :
      if
	previous_of(window).is_undefined
	->
	  window
	    .previous_of window
	    .key_of key
	:
	  $previous_key key_of(window)
	  $class class_of(key)
	  if
	    class == OTHER || class == class_of(previous_key)
	    -> window(.key_of key)
	    ->
	      window
		.previous_of window
		.key_of key

$class_of: (key)
  case key
    undefined -> undefined
    sequence
      CURSOR_LEFT
      CURSOR_RIGHT
      CURSOR_UP
      CURSOR_DOWN
      PAGE_UP
      PAGE_DOWN
      HOME
      END
      CTRL_CURSOR_UP
      CTRL_CURSOR_DOWN
      CTRL_HOME
      CTRL_END
    -> MOVEMENT
    sequence
      SHIFT_CURSOR_LEFT
      SHIFT_CURSOR_RIGHT
      SHIFT_CURSOR_UP
      SHIFT_CURSOR_DOWN
      PAGE_UP
      PAGE_DOWN
      SHIFT_HOME
      SHIFT_END
      SHIFT_CTRL_CURSOR_UP
      SHIFT_CTRL_CURSOR_DOWN
      SHIFT_CTRL_HOME
      SHIFT_CTRL_END
      CTRL_F
      CTRL_G
      CTRL_N
      CTRL_P
    -> SELECTION
    sequence
      ALT_RETURN
      ALT_CURSOR_LEFT
      ALT_CURSOR_RIGHT
      ALT_CURSOR_UP
      ALT_CURSOR_DOWN
    -> FOLDING
    sequence
      BACKSPACE
      DELETE
      SHIFT_TABULATOR
      CTRL_BACKSPACE
      CTRL_DELETE
      CTRL_X
    -> DELETION
    RETURN, TABULATOR, CTRL_V, CTRL_SPACE, ALT_SPACE -> INSERTION
    :
      if
	key.is_a_string
	-> INSERTION
	-> OTHER

$paste_text: (input)
  $s 1
  $n length_of(input)
  $i 0
  loop:
    inc &i
    if
      i > n:
	insert range(input s n)
      :
	case input(i)
	  '@ht;':
	    insert !state range(input s i-1)
	    !window windows_of(state)(current_window_index)
	    !lines lines_of(window)
	    insert !state "        "
	    !window windows_of(state)(current_window_index)
	    !lines lines_of(window)
	    !s i+1
	    next
	  '@nl;', '@cr;':
	    insert !state range(input s i-1)
	    !window windows_of(state)(current_window_index)
	    !lines lines_of(window)
	    new_line !state
	    !window windows_of(state)(current_window_index)
	    !lines lines_of(window)
	    !s i+1
	    next
	  next

$do_nothing -> window lines

$select_page_up: select page_up
$select_page_down: select page_down
$select_cursor_home: select cursor_home
$select_cursor_end: select cursor_end
$select_cursor_up: select cursor_up
$select_cursor_down: select cursor_down
$select_cursor_left: select cursor_left
$select_cursor_right: select cursor_right
$select_cursor_top: select cursor_top
$select_cursor_bottom: select cursor_bottom
$select_smart_cursor_up: select smart_cursor_up
$select_smart_cursor_down: select smart_cursor_down

$select: (handler)
  !window.do_keep_selection true
  update_if selection_start_x_of(window).is_undefined &window
    ->
      window
	.selection_start_x_of x_of(window)
	.selection_start_y_of y_of(window)
  handler

$page_up:
  cursor_up height_of(window)

$cursor_up: (dy = 1)
  !window.y_of max(y_of(window)-dy 1)
  return_window

$page_down:
  cursor_down height_of(window)

$cursor_down: (dy = 1)
  $height length_of(lines)
  case cursor_movement_of(window)
    ANYWHERE:
      plus &window.y_of dy
      return_window
    WITHIN_TEXT:
      !window.y_of min(y_of(window)+dy height)
      return_window
    ADD_SINGLE_LINE:
      !window.y_of min(y_of(window)+dy height+1)
      return_window

$smart_cursor_up:
  $x x_of(window)
  $y y_of(window)
  $new_y y
  loop:
    dec &new_y
    if
      new_y <= length_of(lines):
	$line lines(new_y)
	if
	  line.is_undefined || indent_of(line) >= x
	  next
	  : cursor_up y-new_y
      -> state

$smart_cursor_down:
  $x x_of(window)
  $y y_of(window)
  $new_y y
  loop:
    inc &new_y
    if
      new_y <= length_of(lines):
	$line lines(new_y)
	if
	  line.is_undefined || indent_of(line) >= x
	  next
	  :
	    cursor_down new_y-y
      -> state

$cursor_left: (dx = 1)
  !window.x_of max(x_of(window)-dx 1)
  return_window

$cursor_right: (dx = 1)
  plus &window.x_of dx
  return_window

$cursor_home:
  $x x_of(window)
  $y y_of(window)
  if
    y > length_of(lines)
    :
      !window.x_of 1
      return_window
    :
      $line lines(y)
      if
	line.is_undefined:
	  !window.x_of 1
	  return_window
	:
	  line $indent
	  !window.x_of
	    if
	      x == indent+1
	      -> 1
	      -> indent+1
	  return_window

$cursor_end:
  $y y_of(window)
  if
    y > length_of(lines):
      !window.x_of 1
      return_window
    :
      $line lines(y)
      if
	line.is_undefined:
	  !window.x_of 1
	  return_window
	:
	  line $indent $text
	  !window.x_of indent+length_of(text)+1
	  return_window

$cursor_top:
  !window
    window
      .x_of 1
      .y_of 1
  return_window

$cursor_bottom:
  !window
    window
      .x_of 1
      .y_of length_of(lines)+1
  return_window

$insert: (str)
  if
    str.is_empty
    -> state
    :
      $spaces_only all_of(str: (chr) -> chr == ' ')
      $len length_of(str)
      $y y_of(window)
      $height length_of(lines)
      if
	y > height:
	  if
	    spaces_only:
	      cursor_right len
	    :
	      $insert_line_count y-height
	      set_first_updated_y !window height+1
	      !window.last_updated_y_of y
	      append &lines dup(list(undefined) insert_line_count)
	      insert_text
	insert_text

      $insert_text:
	$x x_of(window)
	$line lines(y)
	if $indent $text $mark $folds
	  line.is_undefined
	  -> x-1 "" "" undefined
	  : line
	$line_width indent+length_of(text)
	$idx x-indent
	if
	  x > line_width:
	    if
	      spaces_only:
		cursor_right len
	      :
		set_first_updated_y !window y
		append &text spaces(x-(line_width+1)) str
		!lines(y) tedi_line(indent text mark folds)
		!window.lines_of lines
		cursor_right len
	  :
	    set_first_updated_y !window y
	    if
	      x > indent+1:
		!text append(range(text 1 idx-1) str range(text idx -1))
		!lines(y) tedi_line(indent text mark folds)
		!window.lines_of lines
		cursor_right len
	      :
		!text append(str spaces(indent+1-x) text)
		!lines(y) tedi_line(x-1 text mark folds)
		!window.lines_of lines
		cursor_right len

$set_first_updated_y: (y)
  $first_updated_y first_updated_y_of(window)
  if
    first_updated_y.is_undefined || y < first_updated_y
    -> window(.first_updated_y_of y)
    -> window

$update_from: (y)
  set_first_updated_y !window y
  -> window(.last_updated_y_of END)

$smart_indent:
  !window.do_keep_selection true
  $selection_start_y selection_start_y_of(window)
  $x x_of(window)
  if
    selection_start_y.is_undefined:
      $y y_of(window)
      if
	y > length_of(lines) || lines(y).is_undefined:
	  $indent_above find_next_indent_above(x y)
	  $indent_below find_next_indent_below(x y)
	  $indent
	    if
	      &&
		indent_above.is_defined
		||
		  indent_below.is_undefined
		  indent_above <= indent_below
		  indent_below < x
	      -> indent_above
	      -> indent_below
	  if
	    indent.is_defined && indent+1 > x
	    : cursor_right indent+1-x
	    : cursor_right 2
	:
	  lines(y) $indent $text $mark $folds
	  $indent_above find_next_indent_above(indent+1 y)
	  if
	    indent_above.is_defined && indent_above > indent:
	      !lines(y) tedi_line(indent_above text mark folds)
	      !window
		window
		  .x_of x+indent_above-indent
		  .first_updated_y_of y
	      return_window_and_lines
	    :
	      !lines(y) tedi_line(indent+2 text mark folds)
	      !window
		window
		  .x_of x+2
		  .first_updated_y_of y
	      return_window_and_lines
    :
      $y y_of(window)
      min_max !selection_start_y $selection_end_y y selection_start_y
      update_if selection_end_y > selection_start_y &selection_end_y:
	dec selection_end_y
      reduce_to &selection_end_y length_of(lines)
      $selected_lines range(lines selection_start_y selection_end_y)
      map &selected_lines
	: (line)
	  line $indent $text $mark $folds
	  if
	    line.is_undefined
	    -> undefined
	    -> tedi_line(indent+2 text mark folds)
      !lines
	append
	  range(lines 1 selection_start_y-1)
	  selected_lines
	  range(lines selection_end_y+1 -1)
      !window.first_updated_y_of selection_start_y
      !window.last_updated_y_of selection_end_y
      !window.x_of x+2
      return_window_and_lines

$find_next_indent_above: (x y)
  reduce_to &y length_of(lines)+1
  loop:
    if
      y > 1:
	dec &y
	$line lines(y)
	if
	  line.is_undefined
	  next
	  :
	    line $indent
	    if
	      indent+1 > x
	      -> indent
	      -> undefined
      -> undefined

$find_next_indent_below: (x y)
  $n length_of(lines)
  loop:
    if
      y < n:
	inc &y
	$line lines(y)
	if
	  line.is_undefined
	  next
	  :
	    line $indent
	    if
	      indent+1 > x
	      -> indent
	      -> undefined
      -> undefined

$smart_outdent:
  !window.do_keep_selection true
  $x x_of(window)
  $y y_of(window)
  $selection_start_y selection_start_y_of(window)
  if
    selection_start_y.is_undefined:
      if
	y > length_of(lines) || lines(y).is_undefined:
	  $indent_above find_previous_indent_above(x y)
	  if
	    indent_above.is_defined && indent_above+1 < x
	    : cursor_left x-(indent_above+1)
	    : cursor_left 2
	:
	  lines(y) $indent $text $mark $folds
	  if
	    indent == 0
	    -> state
	    :
	      $indent_above find_previous_indent_above(indent+1 y)
	      if
		indent_above.is_defined && indent_above < indent:
		  !lines(y) tedi_line(indent_above text mark folds)
		  !window
		    window
		      .x_of max(x-(indent-indent_above) 1)
		      .first_updated_y_of y
		  return_window_and_lines
		:
		  !lines(y) tedi_line(max(indent-2 0) text mark folds)
		  !window
		    window
		      .x_of max(x-2 1)
		      .first_updated_y_of y
		  return_window_and_lines
    :
      min_max !selection_start_y $selection_end_y y selection_start_y
      update_if selection_end_y > selection_start_y &selection_end_y:
	dec selection_end_y
      reduce_to &selection_end_y length_of(lines)
      $selected_lines range(lines selection_start_y selection_end_y)
      if
	all_of
	  selected_lines: (line) -> line.is_undefined || indent_of(line) >= 2
	:
	  map &selected_lines
	    : (line)
	      line $_indent $_text $mark $folds
	      if
		line.is_undefined
		-> undefined
		-> tedi_line(indent_of(line)-2 text_of(line) mark folds)
	  !lines
	    append
	      range(lines 1 selection_start_y-1)
	      selected_lines
	      range(lines selection_end_y+1 -1)
	  !window.first_updated_y_of selection_start_y
	  !window.last_updated_y_of selection_end_y
	  !window.x_of max(x-2 1)
	  return_window_and_lines
	return_window_and_lines

$find_previous_indent_above: (x y)
  reduce_to &y length_of(lines)+1
  loop:
    if
      y > 1:
	dec &y
	$line lines(y)
	if
	  line.is_undefined
	  next
	  :
	    line $indent
	    if
	      indent+1 < x
	      -> indent
	      next
      -> undefined

$new_line:
  $y y_of(window)
  if
    y > length_of(lines):
      !window.x_of 1
      !window.y_of y+1
      return_window
    :
      !lines append(push(range(lines 1 y) undefined) range(lines y+1 -1))
      set_first_updated_y !window y+1
      !window.last_updated_y_of END
      !window.x_of 1
      !window.y_of y+1
      return_window_and_lines

$split_line:
  $x x_of(window)
  $y y_of(window)
  $height length_of(lines)
  if
    y > length_of(lines):
      !window.y_of y+1
      !window.x_of 1
      return_window
    :
      $line lines(y)
      if
	line.is_defined:
	  line $indent $text $mark $folds
	  cond
	    -> x <= indent+1:
	      !lines
		append(push(range(lines 1 y-1) undefined) range(lines y -1))
	      !window.first_updated_y_of y
	      !window.last_updated_y_of END
	      !window.y_of y+1
	      return_window_and_lines
	    -> x > indent+length_of(text):
	      if
		y == height:
		  !window
		    window
		      .x_of indent+1
		      .y_of y+1
		  return_window
		:
		  insert_empty_line indent
	    -> true:
	      update_if text != "" || y < length_of(lines) &lines:
		append
		  push
		    push
		      range(lines 1 y-1)
		      tedi_line(indent range(text 1 x-(indent+1)) mark folds)
		    tedi_line
		      indent range(text x-indent -1).trim_left mark folds
		  range(lines y+1 -1)
	      !window.first_updated_y_of y
	      !window.last_updated_y_of END
	      !window.x_of indent+1
	      !window.y_of y+1
	      return_window_and_lines
	:
	  insert_empty_line 0

  $insert_empty_line: (indent)
    !lines append(push(range(lines 1 y) undefined) range(lines y+1 -1))
    !window.first_updated_y_of y+1
    !window.last_updated_y_of END
    !window.x_of indent+1
    !window.y_of y+1
    return_window_and_lines

$delete_left:
  $x x_of(window)
  $y y_of(window)
  if
    x > 1:
      if
	y > length_of(lines)
	cursor_left
	:
	  $line lines(y)
	  if
	    line.is_undefined
	    cursor_left
	    :
	      line $indent $text $mark $folds
	      cond
		-> x <= indent+1:
		  !window.x_of x-1
		  update_lines_after_deletion y tedi_line(indent-1 text)
		-> x > indent+length_of(text)+1 cursor_left
		-> true:
		  !window.x_of x-1
		  !text
		    append(range(text 1 x-(indent+2)) range(text x-indent -1))
		  update_lines_after_deletion y
		    tedi_line(indent text mark folds)
    -> state

$delete_right:
  $x x_of(window)
  $y y_of(window)
  if
    y > length_of(lines)
    -> state
    :
      $line lines(y)
      if
	line.is_undefined
	-> state
	:
	  line $indent $text $mark $folds

	  cond
	    -> x <= indent:
	      update_lines_after_deletion y tedi_line(indent-1 text)
	    -> x > indent+length_of(text)
	      -> state
	    -> true:
	      !text append(range(text 1 x-(indent+1)) range(text x+1-indent -1))
	      update_lines_after_deletion y tedi_line(indent text mark folds)

$delete_line:
  $y y_of(window)
  $height length_of(lines)
  if
    y > height
    -> state
    :
      !window.last_updated_y_of END
      if
	y == height:
	  update_lines_after_deletion y undefined
	:
	  !window.first_updated_y_of y
	  !lines append(range(lines 1 y-1) range(lines y+1 height))
	  return_window_and_lines

$delete_to_line_start:
  $y y_of(window)
  if
    y > length_of(lines)
    cursor_home
    :
      $line lines(y)
      if
	line.is_undefined
	cursor_home
	:
	  line $indent $text $mark $folds
	  $x x_of(window)
	  $width indent+length_of(text)
	  cond
	    -> x > width:
	      !window.x_of indent+1
	      update_lines_after_deletion y undefined
	    -> x <= indent+1:
	      update_lines_after_deletion y tedi_line(x-1 text mark folds)
	    -> true:
	      !window.x_of indent+1
	      update_lines_after_deletion y
		tedi_line(indent range(text x-indent -1) mark folds)

$delete_to_line_end:
  $y y_of(window)
  if
    y > length_of(lines)
    -> state
    :
      $line lines(y)
      if
	line.is_undefined
	-> window lines
	:
	  line $indent $text $mark $folds
	  $x x_of(window)
	  $width indent+length_of(text)
	  cond
	    -> x > width
	      -> state
	    -> x <= indent+1:
	      update_lines_after_deletion y undefined
	    -> true:
	      update_lines_after_deletion y
		tedi_line(indent range(text 1 (x-1)-indent) mark folds)

$update_lines_after_deletion: (y line)
  $height length_of(lines)
  if
    line.is_undefined && y == height: # removing last line
      loop:
	dec &y
	if
	  y > 0 && lines(y).is_undefined
	  next
	  :
	    !window.first_updated_y_of max(y 1)
	    range &lines 1 y
	    return_window_and_lines
    :
      !window.first_updated_y_of y
      !lines(y) line
      return_window_and_lines

$join_lines:
  $x x_of(window)
  $y y_of(window)
  $height length_of(lines)
  if
    y > height:
      if
	y == height+1
	go_to_end_of_previous_line
	cursor_up
    :
      $line lines(y)
      if
	line.is_undefined:
	  update_from !window y
	  if
	    y == 1:
	      range &lines 2 -1
	      $line_below lines(y) # this line must exist
	      if
		line_below.is_undefined
		-> state
		:
		  !window.x_of indent_of(line_below)+1
		  return_window
	    :
	      !lines append(range(lines 1 y-1) range(lines y+1 -1))
	      $line_above lines(y-1)
	      if
		line_above.is_undefined
		-> window(.y_of y-1) lines
		:
		  $line_below lines(y)
		  if
		    line_below.is_undefined
		    return_window_and_lines
		    go_to_end_of_previous_line
	:
	  line $indent $text $mark $folds
	  $width indent+length_of(text)
	  cond
	    -> x <= indent+1 && y > 1: # join with line above
	      update_from !window y-1
	      $line_above lines(y-1)
	      if
		line_above.is_undefined:
		  !window.y_of y-1
		  !lines append(range(lines 1 y-2) range(lines y -1))
		  return_window_and_lines
		:
		  line_above $indent_above $text_above
		  $length_above indent_above+length_of(text_above)
		  update_if indent >= 1 &text_above: push text_above ' '
		  append text_above &text
		  !window
		    window
		      .x_of length_above+if(x > 1 (-> 2) (-> 1))
		      .y_of y-1
		  !lines
		    append
		      push
			range(lines 1 y-2)
			tedi_line(indent_above text mark folds)
		      range(lines y+1 -1)
		  return_window_and_lines
	    -> x > width && y < height: # join with line below
	      update_from !window y
	      $line_below lines(y+1)
	      if
		line_below.is_undefined:
		  !window.y_of y
		  !lines append(range(lines 1 y) range(lines y+2 -1))
		  return_window_and_lines
		:
		  line_below $indent_below $text_below
		  update_if x > width+1 || indent_below >= 1 &text:
		    push text ' '
		  append &text text_below
		  !window.x_of width+if(x > width+1 (-> 2) (-> 1))
		  !lines
		    append
		      push
			range(lines 1 y-1)
			tedi_line(indent text mark folds)
		      range(lines y+2 -1)
		  return_window_and_lines
	    -> true
	      -> state

  $go_to_end_of_previous_line:
    $line_above lines(y-1)
    line_above $indent_above $text_above
    $length_above indent_above+length_of(text_above)
    !window
      window
	.x_of length_above+if(x == 1 (-> 1) (-> 2))
	.y_of y-1
    return_window_and_lines

$save_contents -> state(.action_of save_contents_action)

$save_contents_action:
  save! filename lines_to_text(lines)
  -> terminal state

$save_with_leading_spaces -> state(.action_of save_with_leading_spaces_action)

$save_with_leading_spaces_action:
  save! filename lines_to_spaced_text(lines)
  -> terminal state

$lines_to_text: (some_lines)
  map_reduce some_lines
    : (line)
      if
	line.is_defined:
	  line $indent $text $_mark $folds
	  $line_text append(tabs_and_spaces(indent) text.to_utf8 "@nl;")
	  if
	    folds.is_defined
	    -> append(line_text lines_to_text(folds))
	    -> line_text
	-> "@nl;"
    append
    ""

$lines_to_spaced_text: (some_lines)
  map_reduce some_lines
    : (line)
      if
	line.is_defined:
	  line $indent $text $_mark $folds
	  $line_text append(spaces(indent) text.to_utf8 "@nl;")
	  if
	    folds.is_defined
	    -> append(line_text lines_to_spaced_text(folds))
	    -> line_text
	-> "@nl;"
    append
    ""

$smart_completion:
  $x x_of(window)
  $y y_of(window)
  $completion_prefix completion_prefix_of(state)
  if
    completion_prefix.is_defined:
      $possible_completions possible_completions_of(state)
      $line lines(y)
      line $indent $text $mark $folds
      $left range(text 1 x-(indent+1+length_of(possible_completions(1))))
      $right range(text x-indent -1)
      minus &x length_of(possible_completions(1))
      range &possible_completions 2 -1
      !window.first_updated_y_of y
      if
	possible_completions.is_empty:
	  !lines(y)
	    tedi_line(indent append(left completion_prefix right) mark folds)
	  !window.x_of x+length_of(completion_prefix)
	  !state.completion_prefix_of undefined
	  !state.possible_completions_of undefined
	  return_window_and_lines
	:
	  !lines(y)
	    tedi_line
	      indent append(left possible_completions(1) right) mark folds
	  !window.x_of x+length_of(possible_completions(1))
	  !state.possible_completions_of possible_completions
	  return_window_and_lines
    :
      $height length_of(lines)
      if
	y > height:
	  complete_prefix ""
	:
	  $line lines(y)
	  if
	    line.is_undefined:
	      complete_prefix ""
	    :
	      line $indent $text
	      $width indent+length_of(text)
	      if
		x <= indent || x > width+1:
		  complete_prefix ""
		:
		  $e x-indent
		  $s e
		  loop:
		    if
		      s > 1 && text(s-1).is_an_identifier_character:
			dec &s
			next
		      :
			complete_prefix range(text s e-1)

$complete_prefix: (prefix)
  !window windows_of(state)(text_window_index_of(state))
  !lines lines_of(window)
  $y y_of(window)
  $height length_of(lines)
  $words empty_list
  split $left_part $mid_part $right_part
  update_if current_window_index != text_window_index_of(state)
    &words: collect_words mid_part false
    #
      do not use the word at the cursor position for completion unless we're in
      a "dialog box"
  collect_words !words left_part true
  collect_words !words right_part false
  $dy 0
  loop:
    inc &dy
    $upper_y y-dy
    $lower_y y+dy
    if
      upper_y < 1 && lower_y > height:
	if
	  words.is_empty
	  -> state
	  :
	    !state.completion_prefix_of prefix
	    !state.possible_completions_of words
	    !window windows_of(state)(current_window_index)
	    !lines lines_of(window)
	    insert range(words(1) length_of(prefix)+1 -1)
      :
	update_if upper_y >= 1 &words: add_words upper_y true
	update_if lower_y <= height &words: add_words lower_y false
	next

  $split:
    $line lines(y)
    if
      line.is_undefined
      -> undefined undefined undefined
      :
	line $indent $text
	$x x_of(window)
	cond
	  -> x <= indent -> "" "" text
	  -> x > indent+length_of(text) -> text "" ""
	  -> true:
	    minus &x indent
	    $left trim_right(range(text 1 x-1) is_an_identifier_character)
	    $right trim_left(range(text x -1) is_an_identifier_character)
	    ->
	      left
	      range(text length_of(left)+1 -(length_of(right)+1))
	      right

  $add_words: (line_no right_to_left)
    $line lines(line_no)
    if
      line.is_undefined
      -> words
      :
	collect_words text_of(line) right_to_left

  $collect_words: (text right_to_left)
    cond
      -> text.is_undefined -> empty_list
      -> right_to_left:
	$i length_of(text)+1
	$e undefined
	loop:
	  dec &i
	  if
	    i < 1:
	      if
		e.is_defined
		-> add_word(range(text 1 e))
		-> words
	    :
	      if
		text(i).is_an_identifier_character:
		  update_if e.is_undefined &e -> i
		  next
		:
		  if
		    e.is_defined:
		      add_word !words range(text i+1 e)
		      !e undefined
		      next
		    next
      -> true:
	$n length_of(text)
	$i 0
	$s undefined
	loop:
	  inc &i
	  if
	    i > n:
	      if
		s.is_defined
		-> add_word(range(text s n))
		-> words
	    :
	      if
		text(i).is_an_identifier_character:
		  update_if s.is_undefined &s -> i
		  next
		:
		  if
		    s.is_defined:
		      add_word !words range(text s i-1)
		      !s undefined
		      next
		    next

  $add_word: (word)
    if
      &&
	word .has_prefix. prefix
	word != prefix
	not(words .contains. word)
      -> push(words word)
      -> words

$is_an_identifier_character: (chr)
  -> chr.is_a_letter || chr.is_a_digit || chr == '_'

$ai_completion -> state(.action_of ai_completion_action)

$ai_completion_action:
  current_time! $t1
  $ai_model ai_model_of(state)
  if
    ai_model.is_defined
    check_tokens
    :
      initialize_ai! !ai_model
      if
	ai_model.is_an_error:
	  eprint! debug_string(ai_model 0 10)
	  -> terminal window lines
	:
	  !state.ai_model_of ai_model
	  check_tokens!

  $check_tokens:
    get_not_tokenized_lines $line_numbers $line_texts
    if
      line_numbers.is_empty
      attempt_completion
      :
	tokenize! ai_model line_texts $line_tokens
	update_tokens !lines line_numbers line_tokens
	attempt_completion!

  $attempt_completion:
    $y y_of(window)
    line_start_tokens !window.x_of $tokens $suffix
    $within_line tokens.is_not_empty
    dump_tokens tokens
    dump_tokens suffix
    loop !tokens:
      dec &y
      if
	y < 1
	-> tokens
	:
	  line_to_tokens $line_tokens y
	  if
	    length_of(line_tokens)+length_of(tokens) > 2560
	    -> tokens
	    :
	      append line_tokens &tokens
	      next
    edump `length_of(tokens)
    # ATTENTION: infill seems *not* to work - therefor it is currently ignored!
    #put &tokens begin_of_stream_token_of(ai_model)
    #update_if suffix.is_not_empty &tokens:
      $space_token space_tokens_of(ai_model)(1)(1)
      put &tokens prefix_token_of(ai_model)
      put &tokens space_token
      push &tokens space_token
      push &tokens suffix_token_of(ai_model)
      append &tokens suffix
      push &tokens space_token
      push tokens middle_token_of(ai_model)
    #edump `length_of(tokens)
    current_time! $t2
    eprintln!
      format("%2.3: preparation " t2-t1)
    $n length_of(tokens)
    loop:
      current_time! $t3
      evaluate! ai_model $token tokens
      current_time! $t4
      eprintln!
	format("%2.3: " t4-t3)
	'@quot;' escaped_token(ai_model token) '@quot;'
      if!
	token != newline_token_of(ai_model):
	  push &tokens token
	  next!
	:
	  # tokenization is that fast that we do not store the returned tokens

	  $ai_text detokenize(ai_model range(tokens n+1 -1))
	  if
	    within_line:
	      if
		ai_text.is_empty
		->
		  terminal
		  state
		:
		  if
		    ai_text(1) == ' ':
		      $line lines(y)
		      line $indent $text
		      $prev_x x_of(window)-indent-1
		      if
			prev_x > length_of(text) || text(prev_x) == ' ':
			  range &ai_text 2 -1
			  return
			return
		    return
	    :
	      if
		ai_text.is_empty
		->
		  terminal
		  split_line()
		:
		  update_if ai_text(1) == ' ' && ai_text(2) != ' ' &ai_text
		    -> range(ai_text 2 -1)
		  !window.x_of 1
		  insert !state ai_text
		  !window windows_of(state)(current_window_index)
		  !lines lines_of(window)
		  ->
		    terminal
		    split_line()

	  $return:
	    ->
	      terminal
	      insert(ai_text)

  $line_to_tokens: (y)
    if
      y > length_of(lines)
      -> list(newline_token_of(ai_model))
      :
	$line lines(y)
	if
	  line.is_defined:
	    line $indent $_text $_mark $_folds $tokens
	    update_if indent > 1 &tokens:
	      append space_tokens_of(ai_model)(indent-1) tokens
	    push tokens newline_token_of(ai_model)
	  -> list(newline_token_of(ai_model))

  $get_not_tokenized_lines:
    $line_numbers empty_list
    $line_texts empty_list
    for_each lines
      : (no line)
	if
	  line.is_undefined
	  next
	  :
	    line $_indent $text $_mark $_folds $tokens
	    if
	      tokens.is_defined
	      next
	      :
		push &line_numbers no
		push &line_texts text
		next
      -> line_numbers line_texts

  $update_tokens: (line_numbers line_tokens)
    for_each line_numbers
      : (idx no)
	lines(no) $indent $text $mark $folds
	!lines(no)
	  new(tedi_types::tedi_line indent text mark folds line_tokens(idx))
	next
      -> lines

  $get_indent: (text)
    $i 0
    $n length_of(text)
    $indent 0
    loop:
      inc &i
      if
	i > n
	-> undefined 0
	:
	  case text(i)
	    ' ':
	      inc &indent
	      next
	    '@ht;':
	      plus &indent 8
	      next
	    -> range(text i -1) indent

$line_start_tokens:
  #
    return a list of tokens corresponding to the text from the line start
    (including indent) to the current cursor position;
    a trailing space is ignored, because this would harm the tokenization
  $y y_of(window)
  if
    y > length_of(lines)
    -> 1 empty_list empty_list
    :
      $line lines(y)
      if
	line.is_undefined
	-> 1 empty_list empty_list
	:
	  line $indent $text $_mark $_folds $tokens
	  $x x_of(window)
	  $cx indent+1
	  if
	    x <= cx
	    -> 1 empty_list empty_list
	    :
	      $ai_model ai_model_of(state)
	      for_each tokens
		: (i token)
		  $piece detokenize(ai_model token)
		  $len length_of(piece)
		  plus &cx
		    if
		      i == 1 && piece(1) == ' '
		      -> len-1
		      -> len
		  if
		    cx < x
		    next
		    :
		      if
			i == 1
			-> 1 empty_list empty_list
			:
			  return
			    range(tokens 1 i)
			    range(tokens i+1 -1)
		:
		  return tokens empty_list

	      $return: (prefix suffix)
		update_if indent >= 2 &prefix:
		  append
		    space_tokens_of(ai_model)(indent-1)
		    prefix
		-> cx prefix suffix

$dump_tokens: (tokens)
  debug_write "@quot;"
  debug_write
    map_reduce
      tokens
      : (token) -> detokenize(ai_model_of(state) token)
      append
      ""
  debug_write "
    @quot;

$initialize_ai:
   load_ai_model! $model "codellama-13b.Q4_0.gguf"
   if
     model.is_an_error
     -> model
     :
       $space_token empty_list
       from_to 1 16
	 : (i)
	   push &space_token piece_table_of(model)(spaces(i))
	   next
	 :
	   $space_tokens empty_list
	   $tokens empty_list
	   from_to 1 80
	     : (i)
	       $n i .mod. 16
	       if
		 n == 0:
		   push &tokens space_token(16)
		   push &space_tokens tokens
		   next
		 :
		   push &space_tokens push(tokens space_token(n))
		   next
	     -> model(.space_tokens_of space_tokens)

$set_upper_bound:
  ->
    window
      .is_locked true
      .upper_bound_of y_of(window)+1-first_visible_y_of(window)
    lines

$set_lower_bound:
  ->
    window
      .is_locked true
      .lower_bound_of y_of(window)+1-first_visible_y_of(window)
    lines

$toggle_line_lock:
  -> window(.is_locked not(window.is_locked)) lines

$toggle_permanent_selection:
  if
    window.has_a_permanent_selection
    ->
      window
	.has_a_permanent_selection false
	.selection_start_x_of undefined
	.selection_start_y_of undefined
      lines
    ->
      window
	.has_a_permanent_selection true
	.selection_start_x_of x_of(window)
	.selection_start_y_of y_of(window)
      lines

$copy: cut_or_copy false

$cut: cut_or_copy true

$cut_or_copy: (do_cut)
  $selection_start_x selection_start_x_of(window)
  $selection_start_y selection_start_y_of(window)
  if
    selection_start_y.is_undefined
    -> state
    :
      !window.selection_start_x_of undefined
      !window.selection_start_y_of undefined
      $y y_of(window)
      $height length_of(lines)
      min_max_minus_1 !selection_start_y $selection_end_y y selection_start_y
      if
	selection_end_y < selection_start_y:
	  if
	    y > height || lines(y).is_undefined
	    -> state
	    :
	      $line lines(y)
	      line $indent $text $mark $folds
	      $width indent+length_of(text)
	      $x min(x_of(window) width+1)
	      min_max !selection_start_x $selection_end_x x selection_start_x
	      $s max(selection_start_x-indent 1)
	      $e min((selection_end_x-1)-indent length_of(text))
	      $contents range(text s e)
	      if
		contents.is_empty
		return_window
		:
		  !state.clipboard_contents_of contents
		  if
		    do_cut
		    :
		      !window.x_of selection_start_x
		      !window.first_updated_y_of y
		      !lines(y)
			tedi_line
			  indent
			  append(range(text 1 s-1) range(text e+1 -1))
			  mark
			  folds
		      return_window_and_lines
		    return_window
	:
	  $contents
	    if
	      selection_start_y > height
	      -> empty_list
	      -> range(lines selection_start_y min(selection_end_y height))
	  update_if selection_end_y > height &contents ->
	    append
	      contents
	      dup
		list(undefined)
		selection_end_y-max(selection_start_y-1 height)
	  !state.clipboard_contents_of contents
	  if
	    do_cut:
	      !window.y_of selection_start_y
	      update_from !window selection_start_y
	      if
		selection_start_y > height
		return_window
		:
		  if
		    selection_end_y < height:
		      !lines
			append
			  range(lines 1 selection_start_y-1)
			  range(lines selection_end_y+1 -1)
		      return_window_and_lines
		    :
		      range &lines 1 selection_start_y-1
		      return_window_and_lines
	    return_window

$paste:
  $clipboard_contents clipboard_contents_of(state)
  if
    clipboard_contents.is_defined:
      if
	clipboard_contents.is_a_string:
	  insert clipboard_contents
	:
	  $y y_of(window)
	  if
	    y > length_of(lines):
	      $insert_line_count y-length_of(lines)
	      append &lines dup(list(undefined) insert_line_count)
	      insert_lines
	    insert_lines

	  $insert_lines:
	    !window
	      window
		.first_updated_y_of y
		.last_updated_y_of END
	    !lines
	      trim_lines
		append
		  range(lines 1 y-1)
		  clipboard_contents
		  range(lines y -1)
	    return_window_and_lines
    -> state

$trim_lines: (updated_lines)
  $y length_of(updated_lines)
  if
    updated_lines(y).is_defined
    -> updated_lines
    :
      loop:
	dec &y
	if
	  y > 0 && updated_lines(y).is_undefined
	  next
	  -> range(updated_lines 1 y)

$find_text_dialog:
  $windows windows_of(state)
  !window windows(SEARCH_WINDOW)
  !lines lines_of(window)
  !window.x_of 1
  !window.y_of
    if
      lines.is_defined
      -> length_of(lines)+1
      -> 1
  !windows(SEARCH_WINDOW) window
  ->
    state
      .text_window_index_of current_window_index_of(state)
      .current_window_index_of SEARCH_WINDOW
      .windows_of windows

$start_search:
  # get search string
  $x x_of(window)
  $y y_of(window)
  $line
    if
      y > length_of(lines)
      -> undefined
      -> lines(y)
  if
    line.is_undefined:
      if
	x > 1:
	  search_for_text dup(" " x-1)
	:
	  -> state(.current_window_index_of text_window_index_of(state))
    :
      line $indent $text
      append spaces(indent) &text
      $len length_of(text)
      if
	x > len+1:
	  search_for_text append(text spaces(x-1-len))
	:
	  search_for_text text

$search_for_text: (text)
  $search_text ""
  $replacement_text undefined
  $match_start_boundary false
  $match_end_boundary false
  $escaped false
  for_each text
    : (chr)
      if
	escaped:
	  !escaped false
	  add_character
	:
	  case chr
	    '\':
	      !escaped true
	      next
	    '%':
	      if
		search_text.is_empty:
		  !match_start_boundary true
		  next
		:
		  !match_end_boundary true
		  next
	    '/':
	      if
		replacement_text.is_defined
		-> state # error
		:
		  !replacement_text ""
		  next
	    add_character

      $add_character:
	if
	  replacement_text.is_defined:
	    push &replacement_text chr
	    next
	  :
	    push &search_text chr
	    next
    :
      # switch back to text window:
      !current_window_index text_window_index_of(state)
      !state.current_window_index_of current_window_index

      !state.search_text_of search_text
      !state.match_start_boundary_of match_start_boundary
      !state.match_end_boundary_of match_end_boundary
      !state.replacement_text_of replacement_text
      !window windows_of(state)(current_window_index)
      !lines lines_of(window)
      if
	key_of(state) == CTRL_P:
	  find_previous max(x_of(window) 1)
	:
	  find_next max(x_of(window)-length_of(search_text) 1)

$find_next: (x = undefined)
  if
    &&
      replacement_text_of(state).is_defined
      search_text_of(state) == selected_text()
    replace_selection
    :
      update_if x.is_undefined &x -> x_of(window)
      $y y_of(window)
      $search_text search_text_of(state)
      $height length_of(lines)
      if
	y > height
	-> state
	:
	  $line lines(y)
	  if
	    line.is_undefined
	    search_forwards
	    :
	      line $indent $text
	      $s x-indent
	      if
		s > length_of(text)
		search_forwards
		:
		  edump `text
		  edump `s
		  edump `search_text
		  range &text s -1
		  search $pos $len search_text text
		  if
		    pos.is_defined && is_a_valid_match(text pos len):
		      !window.selection_start_x_of x+pos-1
		      !window.selection_start_y_of y
		      !window.x_of x+pos+len-1
		      !window.do_keep_selection true
		      return_window
		    search_forwards

      $search_forwards:
	loop
	  :
	    inc &y
	    if
	      y > height
	      -> state
	      :
		$line lines(y)
		if
		  line.is_undefined
		  next
		  :
		    line $indent $text
		    search $pos $len search_text text
		    if
		      pos.is_defined && is_a_valid_match(text pos len):
			!window.x_of indent+pos+len
			!window.y_of y
			!window.selection_start_x_of indent+pos
			!window.selection_start_y_of y
			!window.do_keep_selection true
			return_window
		      next
	  -> state

$find_previous: (x = undefined)
  if
    &&
      replacement_text_of(state).is_defined
      search_text_of(state) == selected_text()
    replace_selection
    :
      update_if x.is_undefined &x -> x_of(window)
      $height length_of(lines)
      $y min(y_of(window) height)
      $search_text search_text_of(state)
      if
	y < 1
	-> state
	:
	  $line lines(y)
	  if
	    line.is_undefined
	    search_backwards
	    :
	      line $indent $text
	      $e x-indent-1
	      if
		e <= indent
		search_backwards
		:
		  edump `text
		  edump `e
		  range &text 1 e
		  search $pos $len search_text text -1
		  if
		    pos.is_defined && is_a_valid_match(text pos len):
		      !window.selection_start_x_of indent+pos+len
		      !window.selection_start_y_of y
		      !window.x_of indent+pos
		      !window.do_keep_selection true
		      return_window
		    search_backwards

      $search_backwards:
	loop:
	  dec &y
	  if
	    y < 1
	    -> state
	    :
	      $line lines(y)
	      if
		line.is_undefined
		next
		:
		  line $indent $text
		  search $pos $len search_text text -1
		  if
		    pos.is_defined && is_a_valid_match(text pos len):
		      !window.x_of indent+pos
		      !window.y_of y
		      !window.selection_start_x_of indent+pos+len
		      !window.selection_start_y_of y
		      !window.do_keep_selection true
		      return_window
		    next

$is_a_valid_match: (text pos len)
  if
    &&
      match_start_boundary_of(state)
      pos > 1
      ==
	is_a_word_character(text(pos))
	is_a_word_character(text(pos-1))
    -> false
    :
      $e pos+len
      -> # ATTENTION: Why is the "->" necessary?
	not
	  &&
	    match_end_boundary_of(state)
	    e <= length_of(text)
	    ==
	      is_a_word_character(text(e-1))
	      is_a_word_character(text(e))

$is_a_word_character: (chr)
  -> chr == '_' || chr.is_a_digit || chr.is_a_letter_character

$selected_text:
  #
    returns the selected text if a single line of text is selected and this
    line is not empty; otherwise <undefined> is returned
  $y y_of(window)
  if
    y < length_of(lines) && y == selection_start_y_of(window)
    :
      $line lines(y)
      if
	line.is_defined:
	  line $indent $text
	  $x x_of(window)-indent
	  $selection_start_x selection_start_x_of(window)-indent
	  if $lx $rx
	    selection_start_x > x
	    -> x selection_start_x
	    -> selection_start_x x
	  if
	    lx < 1 || rx-1 > length_of(text)
	    -> undefined
	    -> range(text lx rx-1)
	-> undefined
    -> undefined

$replace_selection:
  $x x_of(window)
  $y y_of(window)
  $selection_start_x selection_start_x_of(window)
  $replacement_text replacement_text_of(state)
  $line lines(y)
  line $indent $text $mark $folds
  min_max !selection_start_x $selection_end_x x selection_start_x
  $s max(selection_start_x-indent 1)
  $e min((selection_end_x-1)-indent length_of(text))
  !text
    append
      range(text 1 s-1)
      replacement_text
      range(text e+1 -1)
  !lines(y) tedi_line(indent text mark folds)
  !window.first_updated_y_of y
  !window.x_of s+length_of(replacement_text)
  return_window_and_lines

$cancel
  -> state(.current_window_index_of text_window_index_of(state))

$go_to_line_dialog:
  $windows windows_of(state)
  !window windows(GOTO_WINDOW)
  !lines lines_of(window)
  !window.x_of 1
  !window.y_of
    if
      lines.is_defined
      -> length_of(lines)+1
      -> 1
  !windows(GOTO_WINDOW) window
  ->
    state
      .text_window_index_of current_window_index_of(state)
      .current_window_index_of GOTO_WINDOW
      .windows_of windows

$go_to_line:
  $y y_of(window)
  $line
    if
      y > length_of(lines)
      -> undefined
      -> lines(y)
  if
    line.is_undefined
    -> state(.current_window_index_of text_window_index_of(state))
    :
      $text text_of(line)
      if
	length_of(text) == 1 && text(1) >= 'a' && text(1) <= 'z':
	  go_to_mark text(1)
	:
	  $line_no text.to_integer
	  if
	    line_no.is_undefined
	    -> state(.current_window_index_of text_window_index_of(state))
	    :
	      # switch back to text window:
	      !current_window_index text_window_index_of(state)
	      !state.current_window_index_of current_window_index
	      !window windows_of(state)(current_window_index)
	      !window.x_of 1
	      !window.y_of line_no
	      return_window

$define_mark:
  !window.do_define_mark_of true
  return_window

$set_mark: (letter)
  if
    letter < 'a' || letter > 'z'
    -> state
    :
      $y y_of(window)
      if
	y > length_of(lines)
	-> state
	:
	  $line lines(y)
	  if
	    line.is_undefined
	    -> state
	    :
	      line $indent $text $_mark $folds $tokens
	      !lines(y) tedi_line(indent text letter folds tokens)
	      return_window_and_lines

$go_to_mark: (letter)
  # switch back to text window:
  !current_window_index text_window_index_of(state)
  !state.current_window_index_of current_window_index
  !window windows_of(state)(current_window_index)
  !lines lines_of(window)

  for_each lines
    : (y line)
      if
	line.is_undefined
	next
	:
	  line $_indent $_text $mark
	  if
	    mark == letter:
	      !window.y_of y
	      return_window
	    next
    -> state

$toggle_folding:
  # toggles a single folding level
  $y y_of(window)
  if
    y > length_of(lines) || lines(y).is_undefined
    -> window lines
    :
      $line lines(y)
      line $indent $text $mark $folds
      if
	folds.is_defined:
	  update_from !window y
	  ->
	    window
	    append
	      push
		range(lines 1 y-1)
		tedi_line(indent text mark undefined)
	      folds
	      range(lines y+1 -1)
	:
	  collect_indented_lines $e lines y indent
	  if
	    e <= y
	    -> window lines
	    :
	      update_from !window y
	      ->
		window
		append
		  push
		    range(lines 1 y-1)
		    tedi_line(indent text mark range(lines y+1 e))
		  range(lines e+1 -1)

$fold_contents:
  $y y_of(window)
  $height length_of(lines)
  if
    y > height || lines(y).is_undefined
    -> window lines
    :
      $line lines(y)
      line $indent
      collect_indented_lines $e lines y indent
      update_from !window y # only necessary if e > y
      ->
	window

	append
	  range(lines 1 y-1)
	  fold_all(range(lines y e))
	  range(lines e+1 -1)

$unfold_contents:
  $y y_of(window)
  $height length_of(lines)
  if
    y > height || lines(y).is_undefined
    -> window lines
    :
      update_from !window y
      ->
	window
	append
	  range(lines 1 y-1)
	  recursively_collect_folded_lines(lines(y))
	  range(lines y+1 -1)

$fold_everything:
  if
    lines.is_empty
    -> window lines
    :
      $y y_of(window)
      $height length_of(lines)
      find_first $skip $_dummy lines is_defined
      !window.y_of
	+
	  skip-1
	  count(range(lines 1 min(y height)) is_a_top_level_line)
	  max(y-height 0)
      update_from !window 1
      -> window fold_all(lines)

      $is_a_top_level_line: (line)
	-> line.is_defined && indent_of(line) == 0

$unfold_everything:
  $y y_of(window)
  $height length_of(lines)
  $groups map(lines recursively_collect_folded_lines)
  !window.y_of
    +
      map_reduce(range(groups 1 min(y-1 height)) length_of plus 0)
      max(y-height 1)
  update_from !window 1
  -> window reduce(groups append empty_list)

$fold_all: (some_lines)
  $i 0
  $n length_of(some_lines)
  $folds empty_list
  loop:
    inc &i
    if
      i > n
      -> folds
      :
	$line some_lines(i)
	if
	  line.is_undefined:
	    push &folds line
	    next
	  :
	    line $indent $text $mark $subfolds
	    if
	      subfolds.is_defined:
		push &folds
		  tedi_line(indent text mark fold_all(subfolds))
		next
	      :
		collect_indented_lines $e some_lines i indent
		if
		  e > i:
		    push &folds
		      tedi_line
			indent
			text
			mark
			fold_all(range(some_lines i+1 e))
		    !i e
		    next
		  :
		    push &folds line
		    next

$collect_indented_lines: (some_lines i indent)
  $n length_of(some_lines)
  loop:
    inc &i
    if
      i > n
      -> n
      :
	$current_line some_lines(i)
	if
	  current_line.is_undefined
	  next
	  :
	    if
	      indent_of(current_line) > indent
	      next
	      -> i-1

$recursively_collect_folded_lines: (line)
  if
    line.is_defined:
      line $indent $text $mark $folds
      if
	folds.is_defined:
	  put
	    map_reduce(folds recursively_collect_folded_lines)
	    tedi_line(indent text mark undefined)
	-> list(line)
    -> list(undefined)

$help:
  #debug_write "
    show help
  -> window lines

$change_colour_set:
  $colour_set_no colour_set_no_of(window)
  if
    colour_set_no.is_undefined
    -> window lines
    :
      $next_colour_set_no
	if
	  colour_set_no >= length_of(colour_sets)
	  -> 1
	  -> colour_set_no+1
      ->
	window
	  .colour_set_no_of next_colour_set_no
	  .colour_set_of colour_sets(next_colour_set_no)
	  .first_updated_y_of 1
	  .last_updated_y_of END
	lines

$toggle_indentation_highlighting:
  ->
    window
      .do_highlight_indentations_of not(do_highlight_indentations_of(window))
      .first_updated_y_of 1
      .last_updated_y_of END
    lines

$load_file:
  load! $buf filename
  from_utf8 &buf
  trim_right &buf
  update_if buf.is_not_empty &buf -> push(buf '@nl;')
  map split_into_indented_lines(buf): (line)
    if
      line.is_defined
      -> tedi_line(first(line) trim_right(range(second(line) 1 -2)))
      -> undefined

$update_display:
  update_if window.is_a_text_window &terminal: draw_title_bar
  $left_x left_x_of(window)
  $top_y top_y_of(window)
  define_window &terminal
    left_x top_y left_x+width_of(window)-1 top_y+height_of(window)-1
  $x x_of(window)
  $y y_of(window)
  $width width_of(window)
  $height height_of(window)
  $first_visible_x first_visible_x_of(window)
  $first_visible_y first_visible_y_of(window)
  $upper_bound upper_bound_of(window)
  $lower_bound lower_bound_of(window)
  cond $new_first_visible_x $cursor_x
    -> x < first_visible_x
      -> x 1
    -> x >= first_visible_x+width
      -> x+1-width width
    -> true
      -> first_visible_x x+1-first_visible_x
  $new_first_visible_y
    cond
      -> window.is_locked:
	cond
	  -> y < first_visible_y+upper_bound-1
	    -> max(y+1-upper_bound 1)
	  -> y > first_visible_y+lower_bound-1
	    -> y+1-lower_bound
	  -> true
	    -> first_visible_y
      -> y < first_visible_y
	-> y
      -> y >= first_visible_y+height
	-> y+1-height
      -> true
	-> first_visible_y
  $cursor_y 1+y-new_first_visible_y
  $first_updated_y first_updated_y_of(window)
  $last_updated_y last_updated_y_of(window)
  update_if
    ||
      new_first_visible_x != first_visible_x
      new_first_visible_y != first_visible_y
    &first_visible_x &first_visible_y &first_updated_y &last_updated_y
    ->
      new_first_visible_x new_first_visible_y
      new_first_visible_y new_first_visible_y+height-1
  $previous_x previous_x_of(window)
  $previous_y previous_y_of(window)
  $previous_selection_start_x previous_selection_start_x_of(window)
  $previous_selection_start_y previous_selection_start_y_of(window)
  $selection_start_x selection_start_x_of(window)
  $selection_start_y selection_start_y_of(window)
  #if $selection_first_updated_y $selection_last_updated_y
    previous_selection_start_x.is_defined:
      if
	selection_start_x.is_defined:
	  # check for selection change
	  cond
	    -> y != previous_y:
	      if
		y > previous_y
		-> previous_y y-1
		-> y previous_y
	    -> x != previous_x -> y y
	    -> true -> first_updated_y last_updated_y
	:
	  # remove selection highlights
	  if
	    previous_y == previous_selection_start_y
	    -> previous_y previous_y
	    : min_max_minus_1 previous_y previous_selection_start_y
    :
      if
	selection_start_x.is_defined:
	  # show initial selection
	  if
	    y == selection_start_y
	    -> y y
	    : min_max_minus_1 y selection_start_y
	-> first_updated_y last_updated_y
  #!first_updated_y
    if
      first_updated_y.is_undefined
      -> selection_first_updated_y
      -> min(first_updated_y selection_first_updated_y)
  #!last_updated_y
    cond
      -> last_updated_y.is_undefined -> selection_last_updated_y
      -> last_updated_y == END -> END
      -> true -> max(last_updated_y selection_last_updated_y)
  !window
    window
      .first_visible_x_of first_visible_x
      .first_visible_y_of first_visible_y
      .first_updated_y_of first_updated_y
      .last_updated_y_of last_updated_y
  set_cursor &terminal cursor_x cursor_y
  if
    first_updated_y.is_defined:
      update_if previous_y.is_defined && previous_y < first_updated_y
	&first_updated_y -> previous_y
      extend_to &first_updated_y first_visible_y
      draw_lines !terminal
	first_updated_y+1-first_visible_y first_updated_y last_updated_y
      !window.first_updated_y_of undefined
      !window.last_updated_y_of undefined
      return
    :
      $last_visisble_y first_visible_y+height-1
      $already_updated empty_hash_set
      if
	selection_start_y.is_defined:
	  if
	    previous_selection_start_y.is_undefined:
	      # new selection
	      if
		selection_start_y > y:
		  update_lines y selection_start_y
		:
		  update_lines selection_start_y y
	    :
	      if
		selection_start_y != previous_selection_start_y:
		  # changed selection - the new selecton must be inline
		  remove_previous_selection
		:
		  if
		    y != previous_y:
		      # added or removed selection lines
		      if
			y < previous_y:
			  # maybe the previous selection was inline
			  update_lines y previous_y
			:
			  # maybe the previous selection was inline
			  update_lines previous_y y
		    :
		      if
			x != previous_x:
			  # changed inline selection
			  draw_lines !terminal y+1-first_visible_y y y
			  return
			return # changed nothing
	:
	  if
	    previous_selection_start_y.is_defined
	    remove_previous_selection
	    check_movement

      $remove_previous_selection:
	if
	  previous_selection_start_y > previous_y:
	    update_lines previous_y previous_selection_start_y
	  :
	    update_lines previous_selection_start_y previous_y

      $update_lines: (sy ey)
	extend_to &sy first_visible_y
	reduce_to &ey last_visisble_y
	draw_lines !terminal sy+1-first_visible_y sy ey
	from_to sy ey
	  : (cy)
	    !already_updated(cy) true
	    next
	  check_movement

      $check_movement:
	if
	  y != previous_y:
	    if
	      ||
		previous_y < first_visible_y
		previous_y > last_visisble_y
		already_updated(previous_y)
	      update_current_line
	      :
		draw_lines !terminal
		  previous_y+1-first_visible_y
		  previous_y previous_y
		update_current_line

	    $update_current_line:
	      if
		||
		  y < first_visible_y
		  y > last_visisble_y
		  already_updated(y)
		return
		:
		  draw_lines !terminal y+1-first_visible_y y y
		  return
	  return

  $return
    -> terminal return_window()

$return_window_and_lines:
  !window.lines_of lines
  return_window

$return_window:
  !state.windows_of(current_window_index) window
  -> state

$min_max_minus_1: (v1 v2)
  min_max &v1 &v2
  -> v1 v2-1

$draw_lines: (terminal_y first_y last_y)
  $colour_set colour_set_of(window)
  $do_highlight_indentations do_highlight_indentations_of(window)
  $selection_colour selection_colour_of(colour_set)
  $out_of_bounds_colour out_of_bounds_colour_of(colour_set)
  set_text_colour &terminal text_colour_of(colour_set)
  !last_y
    cond
      -> last_y == undefined -> first_y
      -> last_y == END -> first_y+height_of(window)-terminal_y
      -> true -> min(last_y first_y+height_of(window)-terminal_y)
  #debug_write "
    draw_lines @(first_y) .. @(last_y)
  $first_visible_x first_visible_x_of(window)
  $width width_of(window)
  $line_count length_of(lines)
  $selection_start_y selection_start_y_of(window)
  $selection_end_y undefined
  if
    selection_start_y.is_defined:
      !selection_end_y max(y_of(window) selection_start_y)
      !selection_start_y min(y_of(window) selection_start_y)
      draw_line_range
    draw_line_range
  $draw_line_range:
    #debug_write "
      draw_line_range @(first_y) .. @(last_y)
    from_to first_y last_y
      : (y)
	$default_background_colour background_colour_of(colour_set)
	  #case
	    y .mod. 3
	    0 -> background_colour_of(colour_set)
	    1 -> background_colour_2_of(colour_set)
	    2 -> background_colour_3_of(colour_set)
	$background_colour
	  if
	    y > line_count
	    -> out_of_bounds_colour
	    -> default_background_colour
	set_window_colour !terminal background_colour
	if
	  y > line_count
	  clear_line
	  :
	    $line lines(y)
	    if
	      within_selection():
		if
		  selection_start_y == selection_end_y:
		    draw_selected_line
		  :
		    set_window_colour !terminal selection_colour
		    draw_line
	      :
		if
		  line.is_defined && folds_of(line).is_defined:
		    if
		      all_of(folds_of(line) is_undefined):
			set_window_colour !terminal
			  fake_folds_colour_of(colour_set)
			draw_line
		      :
			set_window_colour !terminal folds_colour_of(colour_set)
			draw_line
		  :
		    set_window_colour !terminal background_colour
		    draw_line

	    $draw_line:
	      if
		line.is_undefined
		clear_line
		:
		  line $indent $text
		  $inbounds_width inbounds_width_of(window)
		  $cy terminal_y+y-first_y
		  if
		    &&
		      do_highlight_indentations
		      y != y_of(window)
		      not(within_selection())
		    :
		      pad_right &text first_visible_x+width-(indent+1)
		      range &text max(first_visible_x-indent 1) -1
		      if
			indent >= first_visible_x:
			  draw_attributed_text &terminal 1 cy
			    range
			      indentation_patterns_of(colour_set)(1)
			      3*first_visible_x-2
			      3*indent
			  draw_rest
			draw_rest

		      $draw_rest:
			!indent max(indent+1-first_visible_x 0)
			if
			  inbounds_width.is_defined && width > inbounds_width:
			    !inbounds_width
			      max(inbounds_width+1-first_visible_x 1)
			    draw_text &terminal indent+1 cy
			      range(text 1 inbounds_width-indent)
			    set_window_colour !terminal out_of_bounds_colour
			    draw_text &terminal inbounds_width+1 cy
			      range(text inbounds_width+1-indent -1)
			    next
			  :
			    draw_text &terminal indent+1 cy text
			    next
		    :
		      append spaces(indent) &text
		      pad_right &text first_visible_x+width-1
		      range &text first_visible_x -1
		      if
			inbounds_width.is_defined && width > inbounds_width:
			  !inbounds_width
			    max(inbounds_width+1-first_visible_x 1)
			  draw_text &terminal 1 cy range(text 1 inbounds_width)
			  set_window_colour !terminal out_of_bounds_colour
			  draw_text &terminal inbounds_width+1 cy
			    range(text inbounds_width+1 -1)
			  next
			:
			  draw_text &terminal 1 cy text
			  next

	    $draw_selected_line:
	      if
		line.is_undefined
		clear_line
		:
		  get_horizontal_selection $selection_start_x $selection_end_x
		  line $indent $text
		  append spaces(indent) &text
		  pad_right &text first_visible_x+width-1
		  range &text first_visible_x -1
		  $current_y terminal_y+y-first_y
		  !selection_start_x selection_start_x+1-first_visible_x
		  extend_to &selection_start_x 1
		  reduce_to &selection_start_x width
		  !selection_end_x selection_end_x+1-first_visible_x
		  extend_to &selection_end_x 1
		  reduce_to &selection_end_x width
		  set_window_colour !terminal background_colour
		  draw_text &terminal 1 current_y
		    range(text 1 selection_start_x-1)
		  set_window_colour !terminal selection_colour
		  draw_text &terminal selection_start_x current_y
		    range(text selection_start_x selection_end_x-1)
		  set_window_colour !terminal background_colour
		  draw_text &terminal selection_end_x current_y
		    range(text selection_end_x -1)
		  next

	$clear_line:
	  if
	    within_selection():
	      set_window_colour !terminal selection_colour
	      clear_and_next
	    clear_and_next

	  $clear_and_next:
	    $cy terminal_y+y-first_y
	    $inbounds_width inbounds_width_of(window)
	    if
	      &&
		do_highlight_indentations
		y != y_of(window)
		y < line_count
		not(within_selection())
	      :
		$indent get_next_indent(y)
		if
		  indent == 0
		  clear_whole_line
		  :
		    if
		      indent >= first_visible_x:
			draw_attributed_text &terminal 1 cy
			  range
			    indentation_patterns_of(colour_set)(1)
			    3*first_visible_x-2
			    3*indent
			clear_rest
		      clear_rest
		    $clear_rest:
		      !indent max(indent+1-first_visible_x 0)
		      if
			inbounds_width.is_defined && width > inbounds_width:
			  !inbounds_width
			    max(inbounds_width+1-first_visible_x 1)
			  reduce_to &indent inbounds_width
			  clear &terminal indent+1 cy inbounds_width-indent 1
			  set_window_colour !terminal out_of_bounds_colour
			  clear &terminal inbounds_width+1 cy width-inbounds_width 1
			  next
			:
			  clear &terminal indent+1 cy width 1
			  next
	      clear_whole_line

	    $clear_whole_line:
	      if
		inbounds_width.is_defined && width > inbounds_width:
		  !inbounds_width max(inbounds_width+1-first_visible_x 1)
		  clear &terminal 1 cy inbounds_width 1
		  set_window_colour !terminal out_of_bounds_colour
		  clear &terminal inbounds_width+1 cy width-inbounds_width 1
		  next
		:
		  clear &terminal 1 cy width 1
		  next

	$within_selection
	  ->
	    &&
	      selection_start_y.is_defined
	      y >= selection_start_y
	      y < selection_end_y || y == selection_start_y

	$get_horizontal_selection:
	  $x x_of(window)
	  $selection_start_x selection_start_x_of(window)
	  -> min(x selection_start_x) max(x selection_start_x)

	$set_window_colour: (colour)
	  if
	    y == y_of(window):
	      $red red_component_of(colour)
	      $green green_component_of(colour)
	      $blue blue_component_of(colour)
	      set_background_colour terminal
		rgb_character
		  if(red < 0xe0 (-> red+0x20) (-> red-0x20))
		  if(green < 0xe0 (-> green+0x20) (-> green-0x20))
		  if(blue < 0xe0 (-> blue+0x20) (-> blue-0x20))
	    :
	      set_background_colour terminal colour

      -> terminal

$draw_title_bar:
  define_window &terminal 1 1 -1 1
  $colour_set colour_set_of(window)
  set_text_colour &terminal bar_text_colour_of(colour_set)
  set_background_colour &terminal bar_background_colour_of(colour_set)
  clear &terminal
  draw_text &terminal 1 1
    pad_left("@(y_of(window))/@(length_of(lines))" 11)
    ':' pad_right(x_of(window) 3)
    "  " filename
  -> terminal

$draw_command_bar:
  define_window &terminal 1 -1 -1 -1
  $colour_set colour_set_of(window)
  set_text_colour &terminal bar_text_colour_of(colour_set)
  set_background_colour &terminal bar_background_colour_of(colour_set)
  clear &terminal
  -> terminal

# Helper Functions

$tedi_line:
  (
    indent
    text
    mark = ""
    folds = undefined
    tokens = undefined
  )
  # must not be called with a text containing only space characters
  if
    text.is_empty
    -> undefined
    :
      $prefix_spaces count_prefix_spaces(text)
      $suffix_spaces count_suffix_spaces(text)
      range &text prefix_spaces+1 -(suffix_spaces+1)
      -> new(tedi_types::tedi_line indent+prefix_spaces text mark folds tokens)

$count_prefix_spaces: (str)
  $len length_of(str)
  $i 1
  loop:
    if
      i <= len && str(i) == ' ':
	inc &i
	next
      -> i-1

$count_suffix_spaces: (str)
  $len length_of(str)
  $i len
  loop:
    if
      i >= 1 && str(i) == ' ':
	dec &i
	next
      -> len-i

$get_next_indent: (y)
  loop:
    inc &y
    $line lines(y)
    if
      line.is_defined
      -> first(line)
      next

$create_indentation_patterns: (colour_set)
  $text_colour text_colour_of(colour_set)
  $background_colour background_colour_of(colour_set)
  $background_colour_2 background_colour_2_of(colour_set)
  $background_colour_3 background_colour_3_of(colour_set)
  ->
    colour_set
      .indentation_patterns_of
	list
	  dup
	    string
	      ' '
	      text_colour
	      background_colour
	      ' '
	      text_colour
	      background_colour
	      ' '
	      text_colour
	      background_colour_2
	      ' '
	      text_colour
	      background_colour_2
	    256
	  dup
	    string
	      ' '
	      text_colour
	      background_colour
	      ' '
	      text_colour
	      background_colour
	      ' '
	      text_colour
	      background_colour_3
	      ' '
	      text_colour
	      background_colour_3
	    256
	  dup
	    string
	      ' '
	      text_colour
	      background_colour_2
	      ' '
	      text_colour
	      background_colour_2
	      ' '
	      text_colour
	      background_colour_3
	      ' '
	      text_colour
	      background_colour_3
	    256
