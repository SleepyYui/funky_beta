#!/usr/bin/env fkyrun

  Copyright (C) 2024 by
  Dipl.-Ing. Michael Niederle

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License, version 2, or
  (at your option) version 3.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  For details of the GNU General Public License see the accompanying
  files GPLv2.txt and GLPv3.txt or
  http://www.gnu.org/licenses/gpl-2.0.html
  http://www.gnu.org/licenses/gpl-3.0.html
  or write to the
  Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

<require basic/stdlib>
<require terminal/terminal>
<require ./web/server>
<require ./web/terminal>

<allow unused>

# io (global data)

$clients_of () # virtual terminals
$board_of ()
$rng_of ()
$player_mask_of ()
$changed_fields_of ()
$job_id_of ()

# virtual terminal (per client data)

$player_no_of ()
$x_of ()
$y_of ()
$action_of ()

$RED_CIRCLE 'ðŸ”´'
$BLUE_CIRCLE 'ðŸ”µ'
$ORANGE_CIRCLE 'ðŸŸ '
$YELLOW_CIRCLE 'ðŸŸ¡'
$GREEN_CIRCLE 'ðŸŸ¢'
$PURPLE_CIRCLE 'ðŸŸ£'
$BROWN_CIRCLE 'ðŸŸ¤'

$circles
  list
    RED_CIRCLE
    BLUE_CIRCLE
    ORANGE_CIRCLE
    YELLOW_CIRCLE
    GREEN_CIRCLE
    PURPLE_CIRCLE
    BROWN_CIRCLE

$FRAME_RATE 6

load! $universal_client "universal_client.html"
append "<!DOCTYPE html>@nl;" &universal_client

$BOARD_WIDTH 20
$BOARD_HEIGHT 20

$io std_types::io
$io.clients_of empty_hash_table
$io.player_mask_of 0
$io.changed_fields_of empty_list

chain initialize_terminal_keys:
  $full_line dup("â–’" BOARD_WIDTH)
  !io.board_of
    append
      list(full_line)
      dup
	list
	  append
	    "â–’"
	    dup(" " BOARD_WIDTH-2)
	    "â–’"
	BOARD_HEIGHT-2
      list(full_line)
  current_time! $t
  !io.rng_of mersenne_twister((1'000'000'000*second_of(t)).to_integer)
  enable_logging &io 3
  on_websocket_message &io login
  start_web_server! &io 8000
  start_reading_from &io STDIN_FILENO
  loop:
    get_events! &io $events
    handle_web_server_events &io &events
    for_each events
      : (event)
	event $type $fd $argument
	case type
	  WEBSOCKET_CLOSED:
	    logout &io fd
	    next!
	  next
      :
	handle_terminal_events &io &events
	for_each events
	  : (event)
	    event $type $fd $argument
	    case type
	      READ:
		if
		  fd == STDIN_FILENO:
		    stop_web_server &io
		    terminate!
		  :
		    log_unhandled_event &io event
		    next!
	      GET:
		$uri argument
		get_requested_resource &io fd uri
		next!
	      :
		log_unhandled_event &io event
		next!
	  :
	    handle_jobs &io
	    next!

$get_requested_resource: (io fd uri)
  case uri
    "/":
      return_http_resource io fd uri universal_client
    :
      http_resource_not_found io fd uri

$login: (io fd message)
  log &io 3 -> "login from @(fd.serialize)"
  on_websocket_message &io fd handle_dom_input_event
  on_key_press &io fd handle_key_press
  $player_mask player_mask_of(io)
  from_to $player_no 1 7
    : (no)
      if
	player_mask & (1 << no) != 0
	next
	-> no
    -> undefined
  if
    player_no.is_undefined:
      log &io 1 "too many players"
      close_connection io fd
    :
      log &io 2 -> "player @(player_no) joined the game"
      !io.player_mask_of player_mask | (1 << player_no)
      next_value &io.rng_of $x BOARD_WIDTH-2
      next_value &io.rng_of $y BOARD_HEIGHT-2
      plus &x 1
      plus &y 1
      log &io 3 -> "board position: @(x) @(y)"
      !io.board_of(y)(x) circles(player_no)
      push &io.changed_fields_of tuple(x y)
      create_web_terminal &io $vt fd message
      !vt.player_no_of player_no
      !vt.x_of x
      !vt.y_of y
      !vt.action_of undefined
      draw_board &vt board_of(io)
      update &vt $commands
      send_websocket_text_message &io fd commands
      !io.clients_of(fd) vt
      if
	player_mask == 0:
	  log &io 2 -> "game started"
	  schedule &io !io.job_id_of 1/FRAME_RATE next_frame
	  -> io
	-> io

$logout: (io fd)
  $clients clients_of(io)
  $vt clients(fd)
  $player_no player_no_of(vt)
  log &io 2 -> "player @(player_no) left the game"
  !io.player_mask_of player_mask_of(io) ^ (1 << player_no)
  $x x_of(vt)
  $y y_of(vt)
  !io.board_of(y)(x) ' '
  push &io.changed_fields_of tuple(x y)
  !clients(fd) undefined
  !io.clients_of clients
  if
    clients.is_empty:
      cancel &io job_id_of(io)
      log io 2 "all players left the game"
    -> io

$handle_key_press: (io fd key)
  log &io 3 -> "key press: @(key)"
  $vt clients_of(io)(fd)
  case key
    CURSOR_LEFT, CURSOR_RIGHT, CURSOR_UP, CURSOR_DOWN:
      !vt.action_of key
      !io.clients_of(fd) vt
      -> io
    :
      !vt.action_of undefined
      !io.clients_of(fd) vt
      -> io

$next_frame: (io)
  log &io 4 -> "next frame"
  $clients clients_of(io)
  $board board_of(io)
  $changed_fields empty_list
  for_each changed_fields_of(io)
    : (field)
      field $x $y
      push &changed_fields field
      next
    :
      !io.changed_fields_of empty_list
      for_each clients
	: (fd vt)
	  $x x_of(vt)
	  $y y_of(vt)
	  case action_of(vt)
	    CURSOR_LEFT:
	      if
		board(y)(x-1) == ' ':
		  !board(y)(x) ' '
		  push &changed_fields tuple(x y)
		  minus &x 1
		  !board(y)(x) circles(player_no_of(vt))
		  push &changed_fields tuple(x y)
		  !vt.x_of x
		  !clients(fd) vt
		  next
		:
		  !vt.action_of undefined
		  next
	    CURSOR_RIGHT:
	      if
		board(y)(x+1) == ' ':
		  !board(y)(x) ' '
		  push &changed_fields tuple(x y)
		  plus &x 1
		  !board(y)(x) circles(player_no_of(vt))
		  push &changed_fields tuple(x y)
		  !vt.x_of x
		  !clients(fd) vt
		  next
		:
		  !vt.action_of undefined
		  next
	    CURSOR_UP:
	      if
		board(y-1)(x) == ' ':
		  !board(y)(x) ' '
		  push &changed_fields tuple(x y)
		  minus &y 1
		  !board(y)(x) circles(player_no_of(vt))
		  push &changed_fields tuple(x y)
		  !vt.y_of y
		  !clients(fd) vt
		  next
		:
		  !vt.action_of undefined
		  next
	    CURSOR_DOWN:
	      if
		board(y+1)(x) == ' ':
		  !board(y)(x) ' '
		  push &changed_fields tuple(x y)
		  plus &y 1
		  !board(y)(x) circles(player_no_of(vt))
		  push &changed_fields tuple(x y)
		  !vt.y_of y
		  !clients(fd) vt
		  next
		:
		  !vt.action_of undefined
		  next
	    next
	:
	  if
	    changed_fields.is_empty
	    reschedule
	    :
	      log &io 4 "sending new board"
	      for_each clients
		: (fd vt)
		  $cw character_width_of(vt)
		  $lh line_height_of(vt)
		  set_clear_colour &vt WHITE
		  set_draw_colour &vt BLACK
		  $sx 2*cw+1
		  $sy lh+1
		  for_each changed_fields
		    : (field)
		      field $x $y
		      $chr board(y)(x)
		      if
			width_of(chr) == 2:
			  draw_character &vt sx+x*2*cw sy+y*lh chr
			  next
			:
			  draw_text &vt sx+x*2*cw sy+y*lh string(chr chr)
			  next
		    :
		      update &vt $commands
		      !clients(fd) vt
		      #log &io 4 -> "sending commands: @(commands)"
		      send_websocket_text_message &io fd commands
		      next
		reschedule

      $reschedule:
	!io.board_of board
	!io.clients_of clients
	schedule &io !io.job_id_of 1/FRAME_RATE next_frame
	-> io

$draw_board: (vt board)
  $cw character_width_of(vt)
  $lh line_height_of(vt)
  set_clear_colour &vt GREEN
  clear &vt
  set_clear_colour &vt WHITE
  set_draw_colour &vt BLACK
  $sx 4*cw+1
  $sy 2*lh+1
  for_each board
    : (y row)
      $buf ""
      for_each row
	: (chr)
	  if
	    width_of(chr) > 1:
	      push &buf chr
	      next
	    :
	      push &buf chr
	      push &buf chr
	      next
	:
	  draw_text &vt sx sy+(y-1)*lh buf
	  next
    -> vt
