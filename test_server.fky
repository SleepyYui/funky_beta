#!/usr/bin/env fkyrun

  Copyright (C) 2024 by
  Dipl.-Ing. Michael Niederle

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License, version 2, or
  (at your option) version 3.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  For details of the GNU General Public License see the accompanying
  files GPLv2.txt and GLPv3.txt or
  http://www.gnu.org/licenses/gpl-2.0.html
  http://www.gnu.org/licenses/gpl-3.0.html
  or write to the
  Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

<require basic/stdlib>
<require terminal/terminal>
<require ./web/server>
<require ./web/terminal>

<allow unused>

$clients_of ()
$job_id_of ()
$board_of ()
$rng_of ()
$player_mask_of ()
$player_no_of ()
$x_of ()
$y_of ()

load! $universal_client "universal_client.html"
append "<!DOCTYPE html>@nl;" &universal_client

$BOARD_WIDTH 10
$BOARD_HEIGHT 10

$io std_types::io
$io.clients_of empty_hash_table
$io.player_mask_of 0

chain initialize_terminal_keys:
  !io.board_of
    dup
      list
	dup
	  list(undefined)
	  BOARD_WIDTH
      BOARD_HEIGHT
  current_time! $t
  !io.rng_of mersenne_twister((1'000'000'000*second_of(t)).to_integer)
  enable_logging &io 3
  on_websocket_message &io login
  start_web_server! &io 8000
  start_reading_from &io STDIN_FILENO
  loop:
    get_events! &io $events
    handle_web_server_events &io &events
    for_each events
      : (event)
	event $type $fd $argument
	case type
	  WEBSOCKET_CLOSED:
	    log &io 4 "client disconnected @(fd.serialize)"
	    $vt clients_of(io)(fd)
	    !io.clients_of(fd) undefined
	    $job_id job_id_of(vt)
	    if
	      job_id.is_defined:
		cancel &io job_id
		next!
	      next
	  next
      :
	handle_terminal_events &io &events
	for_each events
	  : (event)
	    event $type $fd $argument
	    case type
	      READ:
		if
		  fd == STDIN_FILENO:
		    stop_web_server &io
		    terminate!
		  :
		    log_unhandled_event &io event
		    next!
	      GET:
		$uri argument
		get_requested_resource &io fd uri
		next!
	      :
		log_unhandled_event &io event
		next!
	  :
	    handle_jobs &io
	    next!

$get_requested_resource: (io fd uri)
  case uri
    "/":
      return_http_resource io fd uri universal_client
    :
      http_resource_not_found io fd uri

$login: (io fd message)
  log &io 3 "login from @(fd.serialize)"
  on_websocket_message &io fd handle_dom_input_event
  on_key_press &io fd handle_key_press
  $player_mask player_mask_of(io)
  from_to $player_no 1 7
    : (no)
      if
	player_mask & (1 << no) != 0
	next
	-> no
    -> undefined
  if
    player_no.is_undefined:
      log &io 1 "too many players"
      close_connection io fd
    :
      log &io 3 "player @(player_no) joined"
      !io.player_mask_of player_mask | (1 << player_no)
      next_value &io.rng_of $x BOARD_WIDTH
      next_value &io.rng_of $y BOARD_HEIGHT
      log &io 3 "board position: @(x) @(y)"
      !io.board_of(y)(x) player_no
      create_web_terminal &io $vt fd message
      !vt.player_no_of player_no
      !vt.x_of x
      !vt.y_of y
      draw_board &vt board_of(io)
      update &vt $commands
      send_websocket_text_message &io fd commands
      schedule &io !vt.job_id_of 1 next_frame fd
      !io.clients_of(fd) vt
      -> io

$next_frame: (io fd)
  log &io 3 "next frame for @(fd.serialize)"
  $vt clients_of(io)(fd)
  draw_board &vt board_of(io)
  update &vt $commands
  send_websocket_text_message &io fd commands
  schedule &io !vt.job_id_of 1 next_frame fd
  !io.clients_of(fd) vt
  -> io

$handle_key_press: (io fd key)
  log &io 3 "key press: @(key)"
  $vt clients_of(io)(fd)
  $board board_of(io)
  $x x_of(vt)
  $y y_of(vt)
  $player_no player_no_of(vt)
  case key
    CURSOR_LEFT:
      if
	x > 1:
	  !board(y)(x) undefined
	  dec &x
	  !board(y)(x) player_no
	  !vt.x_of x
	  !io.board_of board
	  !io.clients_of(fd) vt
	  -> io
	-> io
    CURSOR_RIGHT:
      if
	x < BOARD_WIDTH:
	  !board(y)(x) undefined
	  inc &x
	  !board(y)(x) player_no
	  !vt.x_of x
	  !io.board_of board
	  !io.clients_of(fd) vt
	  -> io
	-> io
    CURSOR_UP:
      if
	y > 1:
	  !board(y)(x) undefined
	  dec &y
	  !board(y)(x) player_no
	  !vt.y_of y
	  !io.board_of board
	  !io.clients_of(fd) vt
	  -> io
	-> io
    CURSOR_DOWN:
      if
	y < BOARD_HEIGHT:
	  !board(y)(x) undefined
	  inc &y
	  !board(y)(x) player_no
	  !vt.y_of y
	  !io.board_of board
	  !io.clients_of(fd) vt
	  -> io
	-> io
    -> io

$RED_CIRCLE 'ðŸ”´'
$BLUE_CIRCLE 'ðŸ”µ'
$ORANGE_CIRCLE 'ðŸŸ '
$YELLOW_CIRCLE 'ðŸŸ¡'
$GREEN_CIRCLE 'ðŸŸ¢'
$PURPLE_CIRCLE 'ðŸŸ£'
$BROWN_CIRCLE 'ðŸŸ¤'

$circles
  list
    RED_CIRCLE
    BLUE_CIRCLE
    ORANGE_CIRCLE
    YELLOW_CIRCLE
    GREEN_CIRCLE
    PURPLE_CIRCLE
    BROWN_CIRCLE

$draw_board: (vt board)
  $cw character_width_of(vt)
  $ch character_height_of(vt)
  set_clear_colour &vt GREEN
  clear &vt
  set_clear_colour &vt WHITE
  $sx 4*cw+1
  $sy 2*ch+1
  clear &vt sx+2*cw sy+ch BOARD_WIDTH*2*cw BOARD_HEIGHT*ch
  for_each board
    : (y row)
      for_each row
	: (x player_no)
	  if
	    player_no.is_defined:
	      draw_character &vt sx+x*2*cw sy+y*ch circles(player_no)
	      next
	    next
	next
    -> vt
